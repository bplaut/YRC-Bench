diff --git a/.gitmodules b/.gitmodules
index 1569530..d946149 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -10,3 +10,6 @@
 [submodule "ravens"]
 	path = ravens
 	url = https://github.com/google-research/ravens.git
+[submodule "procgenAISC"]
+	path = procgenAISC
+	url = https://github.com/JacobPfau/procgenAISC.git
diff --git a/README.md b/README.md
index 964873a..0f23de5 100644
--- a/README.md
+++ b/README.md
@@ -22,4 +22,25 @@ while True:
     rew, obs, first = env.observe()
     print(f"step {step} reward {rew} first {first}")
     step += 1
-```
\ No newline at end of file
+```
+
+
+### Algorithm
+
+```
+- # assuming policy expert pi_e is given
+- train weak policy pi_w over the environment (online or offline)
+- train predictive model p over the environment
+- until goal is reached:
+  - take weak action: a_w = pi_w(s_t)
+  - take expert action: a_e = pi_e(s_t)
+  - calculate the cumulative cost over horizon h using p: c = p(s_t, a_w, pi_w, a_e, pi_e)
+  - if c > threshold:
+    - a = a_e
+  - else:
+    - a = a_w
+  - execute action a in the environment
+  - observe next state s_{t+1}
+  - s_t = s_{t+1}
+```
+
diff --git a/algorithms/__pycache__/models.cpython-38.pyc b/algorithms/__pycache__/models.cpython-38.pyc
index a492c3c..16e3801 100644
Binary files a/algorithms/__pycache__/models.cpython-38.pyc and b/algorithms/__pycache__/models.cpython-38.pyc differ
diff --git a/algorithms/__pycache__/utils.cpython-38.pyc b/algorithms/__pycache__/utils.cpython-38.pyc
index 91e0a1e..dec82e3 100644
Binary files a/algorithms/__pycache__/utils.cpython-38.pyc and b/algorithms/__pycache__/utils.cpython-38.pyc differ
diff --git a/algorithms/models.py b/algorithms/models.py
index 1a47b24..735fc7f 100644
--- a/algorithms/models.py
+++ b/algorithms/models.py
@@ -1,82 +1,383 @@
-from typing import Tuple
-
-import gym
 import numpy as np
 import torch
 import torch.nn as nn
+import torch.nn.functional as F
+import torch.optim as optim
 from torch.distributions.categorical import Categorical
 
+from utils import adjust_lr
+
+
+class PPO:
+    def __init__(self,
+                 env,
+                 policy,
+                 logger,
+                 storage,
+                 device,
+                 n_checkpoints,
+                 env_valid=None,
+                 storage_valid=None,
+                 n_steps=128,
+                 n_envs=8,
+                 epoch=3,
+                 mini_batch_per_epoch=8,
+                 mini_batch_size=32 * 8,
+                 gamma=0.99,
+                 lmbda=0.95,
+                 learning_rate=2.5e-4,
+                 grad_clip_norm=0.5,
+                 eps_clip=0.2,
+                 value_coef=0.5,
+                 entropy_coef=0.01,
+                 normalize_adv=True,
+                 normalize_rew=True,
+                 use_gae=True,
+                 **kwargs):
 
-class ResidualBlock(nn.Module):
-    def __init__(self, channels: int) -> None:
         super().__init__()
-        self.conv0 = nn.Conv2d(in_channels=channels, out_channels=channels, kernel_size=3, padding=1)
-        self.conv1 = nn.Conv2d(in_channels=channels, out_channels=channels, kernel_size=3, padding=1)
+        self.env = env
+        self.policy = policy
+        self.logger = logger
+        self.storage = storage
+        self.device = device
+        self.num_checkpoints = n_checkpoints
+        self.env_valid = env_valid
+        self.storage_valid = storage_valid
+        self.t = 0
+        self.n_steps = n_steps
+        self.n_envs = n_envs
+        self.epoch = epoch
+        self.mini_batch_per_epoch = mini_batch_per_epoch
+        self.mini_batch_size = mini_batch_size
+        self.gamma = gamma
+        self.lmbda = lmbda
+        self.learning_rate = learning_rate
+        self.optimizer = optim.Adam(self.policy.parameters(), lr=learning_rate, eps=1e-5)
+        self.grad_clip_norm = grad_clip_norm
+        self.eps_clip = eps_clip
+        self.value_coef = value_coef
+        self.entropy_coef = entropy_coef
+        self.normalize_adv = normalize_adv
+        self.normalize_rew = normalize_rew
+        self.use_gae = use_gae
 
-    def forward(self, x: torch.Tensor) -> torch.Tensor:
-        inputs = x
-        x = nn.functional.relu(x)
-        x = self.conv0(x)
-        x = nn.functional.relu(x)
-        x = self.conv1(x)
-        return x + inputs
+    def predict(self, obs, hidden_state, done):
+        with torch.no_grad():
+            obs = torch.FloatTensor(obs).to(device=self.device)
+            hidden_state = torch.FloatTensor(hidden_state).to(device=self.device)
+            mask = torch.FloatTensor(1 - done).to(device=self.device)
+            dist, value, hidden_state = self.policy(obs, hidden_state, mask)
+            act = dist.sample()
+            log_prob_act = dist.log_prob(act)
 
+        return act.cpu().numpy(), log_prob_act.cpu().numpy(), value.cpu().numpy(), hidden_state.cpu().numpy()
 
-class ConvSequence(nn.Module):
-    def __init__(self, input_shape: Tuple[int, int, int], out_channels: int) -> None:
-        super().__init__()
-        self._input_shape = input_shape
-        self._out_channels = out_channels
-        self.conv = nn.Conv2d(in_channels=self._input_shape[0], out_channels=self._out_channels, kernel_size=3, padding=1)
-        self.res_block0 = ResidualBlock(self._out_channels)
-        self.res_block1 = ResidualBlock(self._out_channels)
+    def predict_w_value_saliency(self, obs, hidden_state, done):
+        obs = torch.FloatTensor(obs).to(device=self.device)
+        obs.requires_grad_()
+        obs.retain_grad()
+        hidden_state = torch.FloatTensor(hidden_state).to(device=self.device)
+        mask = torch.FloatTensor(1 - done).to(device=self.device)
+        dist, value, hidden_state = self.policy(obs, hidden_state, mask)
+        value.backward(retain_graph=True)
+        act = dist.sample()
+        log_prob_act = dist.log_prob(act)
+
+        return act.detach().cpu().numpy(), log_prob_act.detach().cpu().numpy(), value.detach().cpu().numpy(), hidden_state.detach().cpu().numpy(), obs.grad.data.detach().cpu().numpy()
+
+    def optimize(self):
+        pi_loss_list, value_loss_list, entropy_loss_list = [], [], []
+        batch_size = self.n_steps * self.n_envs // self.mini_batch_per_epoch
+        if batch_size < self.mini_batch_size:
+            self.mini_batch_size = batch_size
+        grad_accumulation_steps = batch_size / self.mini_batch_size
+        grad_accumulation_cnt = 1
+
+        self.policy.train()
+        for e in range(self.epoch):
+            recurrent = self.policy.is_recurrent()
+            generator = self.storage.fetch_train_generator(mini_batch_size=self.mini_batch_size,
+                                                           recurrent=recurrent)
+            for sample in generator:
+                obs_batch, hidden_state_batch, act_batch, done_batch, \
+                    old_log_prob_act_batch, old_value_batch, return_batch, adv_batch = sample
+                mask_batch = (1 - done_batch)
+                dist_batch, value_batch, _ = self.policy(obs_batch, hidden_state_batch, mask_batch)
+
+                # Clipped Surrogate Objective
+                log_prob_act_batch = dist_batch.log_prob(act_batch)
+                ratio = torch.exp(log_prob_act_batch - old_log_prob_act_batch)
+                surr1 = ratio * adv_batch
+                surr2 = torch.clamp(ratio, 1.0 - self.eps_clip, 1.0 + self.eps_clip) * adv_batch
+                pi_loss = -torch.min(surr1, surr2).mean()
+
+                # Clipped Bellman-Error
+                clipped_value_batch = old_value_batch + (value_batch - old_value_batch).clamp(-self.eps_clip, self.eps_clip)
+                v_surr1 = (value_batch - return_batch).pow(2)
+                v_surr2 = (clipped_value_batch - return_batch).pow(2)
+                value_loss = 0.5 * torch.max(v_surr1, v_surr2).mean()
+
+                # Policy Entropy
+                entropy_loss = dist_batch.entropy().mean()
+                loss = pi_loss + self.value_coef * value_loss - self.entropy_coef * entropy_loss
+                loss.backward()
+
+                # Let model to handle the large batch-size with small gpu-memory
+                if grad_accumulation_cnt % grad_accumulation_steps == 0:
+                    torch.nn.utils.clip_grad_norm_(self.policy.parameters(), self.grad_clip_norm)
+                    self.optimizer.step()
+                    self.optimizer.zero_grad()
+                grad_accumulation_cnt += 1
+                pi_loss_list.append(-pi_loss.item())
+                value_loss_list.append(-value_loss.item())
+                entropy_loss_list.append(entropy_loss.item())
+
+        summary = {'Loss/pi': np.mean(pi_loss_list),
+                   'Loss/v': np.mean(value_loss_list),
+                   'Loss/entropy': np.mean(entropy_loss_list)}
+        return summary
+
+    def train(self, num_timesteps):
+        print('::[LOGGING]::START TRAINING...')
+        save_every = num_timesteps // self.num_checkpoints
+        checkpoint_cnt = 0
+        obs = self.env.reset()
+        hidden_state = np.zeros((self.n_envs, self.storage.hidden_state_size))
+        done = np.zeros(self.n_envs)
+
+        if self.env_valid is not None:
+            obs_v = self.env_valid.reset()
+            hidden_state_v = np.zeros((self.n_envs, self.storage.hidden_state_size))
+            done_v = np.zeros(self.n_envs)
+
+        while self.t < num_timesteps:
+            # Run Policy
+            self.policy.eval()
+            for _ in range(self.n_steps):
+                act, log_prob_act, value, next_hidden_state = self.predict(obs, hidden_state, done)
+                next_obs, rew, done, info = self.env.step(act)
+                self.storage.store(obs, hidden_state, act, rew, done, info, log_prob_act, value)
+                obs = next_obs
+                hidden_state = next_hidden_state
+            value_batch = self.storage.value_batch[:self.n_steps]
+            _, _, last_val, hidden_state = self.predict(obs, hidden_state, done)
+            self.storage.store_last(obs, hidden_state, last_val)
+            # Compute advantage estimates
+            self.storage.compute_estimates(self.gamma, self.lmbda, self.use_gae, self.normalize_adv)
+
+            # valid
+            if self.env_valid is not None:
+                for _ in range(self.n_steps):
+                    act_v, log_prob_act_v, value_v, next_hidden_state_v = self.predict(obs_v, hidden_state_v, done_v)
+                    next_obs_v, rew_v, done_v, info_v = self.env_valid.step(act_v)
+                    self.storage_valid.store(obs_v, hidden_state_v, act_v,
+                                             rew_v, done_v, info_v,
+                                             log_prob_act_v, value_v)
+                    obs_v = next_obs_v
+                    hidden_state_v = next_hidden_state_v
+                _, _, last_val_v, hidden_state_v = self.predict(obs_v, hidden_state_v, done_v)
+                self.storage_valid.store_last(obs_v, hidden_state_v, last_val_v)
+                self.storage_valid.compute_estimates(self.gamma, self.lmbda, self.use_gae, self.normalize_adv)
+
+            # Optimize policy & valueq
+            summary = self.optimize()
+            # Log the training-procedure
+            self.t += self.n_steps * self.n_envs
+            rew_batch, done_batch = self.storage.fetch_log_data()
+            if self.storage_valid is not None:
+                rew_batch_v, done_batch_v = self.storage_valid.fetch_log_data()
+            else:
+                rew_batch_v = done_batch_v = None
+            self.logger.feed(rew_batch, done_batch, rew_batch_v, done_batch_v)
+            self.logger.dump()
+            self.optimizer = adjust_lr(self.optimizer, self.learning_rate, self.t, num_timesteps)
+            # Save the model
+            if self.t > ((checkpoint_cnt + 1) * save_every):
+                print("Saving model.")
+                torch.save({'model_state_dict': self.policy.state_dict(),
+                            'optimizer_state_dict': self.optimizer.state_dict()},
+                           self.logger.logdir + '/model_' + str(self.t) + '.pth')
+                checkpoint_cnt += 1
+        self.env.close()
+        if self.env_valid is not None:
+            self.env_valid.close()
+
+
+class CategoricalPolicy(nn.Module):
+    def __init__(self,
+                 embedder,
+                 recurrent,
+                 action_size):
+        """
+        embedder: (torch.Tensor) model to extract the embedding for observation
+        action_size: number of the categorical actions
+        """
+        super(CategoricalPolicy, self).__init__()
+        self.embedder = embedder
+        # small scale weight-initialization in policy enhances the stability
+        self.fc_policy = orthogonal_init(nn.Linear(self.embedder.output_dim, action_size), gain=0.01)
+        self.fc_value = orthogonal_init(nn.Linear(self.embedder.output_dim, 1), gain=1.0)
+
+        self.recurrent = recurrent
+        if self.recurrent:
+            self.gru = GRU(self.embedder.output_dim, self.embedder.output_dim)
+
+    def is_recurrent(self):
+        return self.recurrent
+
+    def forward(self, x, hx, masks):
+        hidden = self.embedder(x)
+        if self.recurrent:
+            hidden, hx = self.gru(hidden, hx, masks)
+        logits = self.fc_policy(hidden)
+        log_probs = F.log_softmax(logits, dim=1)
+        p = Categorical(logits=log_probs)
+        v = self.fc_value(hidden).reshape(-1)
+        return p, v, hx
+
+
+class GRU(nn.Module):
+    def __init__(self, input_size, hidden_size):
+        super(GRU, self).__init__()
+        self.gru = orthogonal_init(nn.GRU(input_size, hidden_size), gain=1.0)
+
+    def forward(self, x, hxs, masks):
+        # Prediction
+        if x.size(0) == hxs.size(0):
+            # input for GRU-CELL: (L=sequence_length, N, H)
+            # output for GRU-CELL: (output: (L, N, H), hidden: (L, N, H))
+            masks = masks.unsqueeze(-1)
+            x, hxs = self.gru(x.unsqueeze(0), (hxs * masks).unsqueeze(0))
+            x = x.squeeze(0)
+            hxs = hxs.squeeze(0)
+        # Training
+        # We will recompute the hidden state to allow gradient to be back-propagated through time
+        else:
+            # x is a (T, N, -1) tensor that has been flatten to (T * N, -1)
+            N = hxs.size(0)
+            T = int(x.size(0) / N)
+
+            # unflatten
+            x = x.view(T, N, x.size(1))
 
-    def forward(self, x: torch.Tensor) -> torch.Tensor:
+            # Same deal with masks
+            masks = masks.view(T, N)
+
+            # Let's figure out which steps in the sequence have a zero for any agent
+            # We will always assume t=0 has a zero in it as that makes the logic cleaner
+            # (can be interpreted as a truncated back-propagation through time)
+            has_zeros = ((masks[1:] == 0.0) \
+                         .any(dim=-1)
+                         .nonzero()
+                         .squeeze()
+                         .cpu())
+
+            # +1 to correct the masks[1:]
+            if has_zeros.dim() == 0:
+                # Deal with scalar
+                has_zeros = [has_zeros.item() + 1]
+            else:
+                has_zeros = (has_zeros + 1).numpy().tolist()
+
+            # add t=0 and t=T to the list
+            has_zeros = [0] + has_zeros + [T]
+
+            hxs = hxs.unsqueeze(0)
+            outputs = []
+            for i in range(len(has_zeros) - 1):
+                # We can now process steps that don't have any zeros in masks together!
+                # This is much faster
+                start_idx = has_zeros[i]
+                end_idx = has_zeros[i + 1]
+
+                rnn_scores, hxs = self.gru(
+                    x[start_idx:end_idx],
+                    hxs * masks[start_idx].view(1, -1, 1))
+
+                outputs.append(rnn_scores)
+
+            # assert len(outputs) == T
+            # x is a (T, N, -1) tensor
+            x = torch.cat(outputs, dim=0)
+            # flatten
+            x = x.view(T * N, -1)
+            hxs = hxs.squeeze(0)
+
+        return x, hxs
+
+
+class ResidualBlock(nn.Module):
+    def __init__(self,
+                 in_channels):
+        super(ResidualBlock, self).__init__()
+        self.conv1 = nn.Conv2d(in_channels=in_channels, out_channels=in_channels, kernel_size=3, stride=1, padding=1)
+        self.conv2 = nn.Conv2d(in_channels=in_channels, out_channels=in_channels, kernel_size=3, stride=1, padding=1)
+
+    def forward(self, x):
+        out = nn.ReLU()(x)
+        out = self.conv1(out)
+        out = nn.ReLU()(out)
+        out = self.conv2(out)
+        return out + x
+
+
+class ImpalaBlock(nn.Module):
+    def __init__(self, in_channels, out_channels):
+        super(ImpalaBlock, self).__init__()
+        self.conv = nn.Conv2d(in_channels=in_channels, out_channels=out_channels, kernel_size=3, stride=1, padding=1)
+        self.res1 = ResidualBlock(out_channels)
+        self.res2 = ResidualBlock(out_channels)
+
+    def forward(self, x):
         x = self.conv(x)
-        x = nn.functional.max_pool2d(x, kernel_size=3, stride=2, padding=1)
-        x = self.res_block0(x)
-        x = self.res_block1(x)
-        assert x.shape[1:] == self.get_output_shape()
+        x = nn.MaxPool2d(kernel_size=3, stride=2, padding=1)(x)
+        x = self.res1(x)
+        x = self.res2(x)
         return x
 
-    def get_output_shape(self) -> Tuple[int, int, int]:
-        _c, h, w = self._input_shape
-        return self._out_channels, (h + 1) // 2, (w + 1) // 2
 
+scale = 1
 
-class PPOAgent(nn.Module):
-    def __init__(self, envs: gym.vector.SyncVectorEnv) -> None:
-        super().__init__()
-        h, w, c = envs.single_observation_space.shape
-        shape = (c, h, w)
-        conv_seqs = []
-        for out_channels in [16, 32, 32]:
-            conv_seq = ConvSequence(shape, out_channels)
-            shape = conv_seq.get_output_shape()
-            conv_seqs.append(conv_seq)
-        conv_seqs += [
-            nn.Flatten(),
-            nn.ReLU(),
-            nn.Linear(in_features=shape[0] * shape[1] * shape[2], out_features=256),
-            nn.ReLU(),
-        ]
-        self.network = nn.Sequential(*conv_seqs)
-        self.actor = layer_init(nn.Linear(256, envs.single_action_space.n), std=0.01)
-        self.critic = layer_init(nn.Linear(256, 1), std=1)
-
-    def get_value(self, x: torch.Tensor) -> torch.Tensor:
-        return self.critic(self.network(x.permute((0, 3, 1, 2)) / 255.0))  # "bhwc" -> "bchw"
-
-    def get_action_and_value(self, x: torch.Tensor, action: torch.Tensor = None) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor]:
-        hidden = self.network(x.permute((0, 3, 1, 2)) / 255.0)  # "bhwc" -> "bchw"
-        logits = self.actor(hidden)
-        probs = Categorical(logits=logits)
-        if action is None:
-            action = probs.sample()
-        return action, probs.log_prob(action), probs.entropy(), self.critic(hidden)
-
-
-def layer_init(layer: nn.Module, std: float = np.sqrt(2), bias_const: float = 0.0) -> nn.Module:
-    torch.nn.init.orthogonal_(layer.weight, std)
-    torch.nn.init.constant_(layer.bias, bias_const)
-    return layer
+
+class ImpalaModel(nn.Module):
+    def __init__(self,
+                 in_channels,
+                 **kwargs):
+        super(ImpalaModel, self).__init__()
+        self.block1 = ImpalaBlock(in_channels=in_channels, out_channels=16 * scale)
+        self.block2 = ImpalaBlock(in_channels=16 * scale, out_channels=32 * scale)
+        self.block3 = ImpalaBlock(in_channels=32 * scale, out_channels=32 * scale)
+        self.fc = nn.Linear(in_features=32 * scale * 8 * 8, out_features=256)
+
+        self.output_dim = 256
+        self.apply(xavier_uniform_init)
+
+    def forward(self, x):
+        x = self.block1(x)
+        x = self.block2(x)
+        x = self.block3(x)
+        x = nn.ReLU()(x)
+        x = Flatten()(x)
+        x = self.fc(x)
+        x = nn.ReLU()(x)
+        return x
+
+
+class Flatten(nn.Module):
+    def forward(self, x):
+        return torch.flatten(x, start_dim=1)
+
+
+def xavier_uniform_init(module, gain=1.0):
+    if isinstance(module, nn.Linear) or isinstance(module, nn.Conv2d):
+        nn.init.xavier_uniform_(module.weight.data, gain)
+        nn.init.constant_(module.bias.data, 0)
+    return module
+
+
+def orthogonal_init(module, gain=nn.init.calculate_gain('relu')):
+    if isinstance(module, nn.Linear) or isinstance(module, nn.Conv2d):
+        nn.init.orthogonal_(module.weight.data, gain)
+        nn.init.constant_(module.bias.data, 0)
+    return module
diff --git a/algorithms/ppo_procgen.py b/algorithms/ppo_procgen.py
deleted file mode 100644
index fcfaacc..0000000
--- a/algorithms/ppo_procgen.py
+++ /dev/null
@@ -1,282 +0,0 @@
-import argparse
-import os
-import random
-import time
-import uuid
-from typing import Tuple
-
-import gym
-import numpy as np
-import torch
-import torch.nn as nn
-import torch.optim as optim
-import wandb
-from procgen import ProcgenEnv
-from torch.utils.tensorboard import SummaryWriter
-
-from models import PPOAgent
-from utils import ReplayBuffer
-
-
-def get_args() -> argparse.Namespace:
-    parser = argparse.ArgumentParser()
-    parser.add_argument("--exp_name", type=str, default="ppo")
-    parser.add_argument("--seed", type=int, default=1)
-    parser.add_argument("--torch_deterministic", action="store_false")
-    parser.add_argument("--cuda", action="store_false")
-    parser.add_argument("--wandb", action="store_true")
-    parser.add_argument("--wandb_project_name", type=str, default="RYC")
-    parser.add_argument("--wandb_entity", type=str, default=None)
-    parser.add_argument("--capture_video", action="store_true")
-    parser.add_argument("--env_id", type=str, default="starpilot")
-    parser.add_argument("--total_timesteps", type=int, default=int(25e6))
-    parser.add_argument("--learning_rate", type=float, default=5e-4)
-    parser.add_argument("--num_envs", type=int, default=64)
-    parser.add_argument("--num_steps", type=int, default=256)
-    parser.add_argument("--gamma", type=float, default=0.999)
-    parser.add_argument("--gae_lambda", type=float, default=0.95)
-    parser.add_argument("--num_minibatches", type=int, default=8)
-    parser.add_argument("--update_epochs", type=int, default=3)
-    parser.add_argument("--eval_episodes", type=int, default=10)
-    parser.add_argument("--clip_coef", type=float, default=0.2)
-    parser.add_argument("--ent_coef", type=float, default=0.01)
-    parser.add_argument("--vf_coef", type=float, default=0.5)
-    parser.add_argument("--max_grad_norm", type=float, default=0.5)
-    return parser.parse_args()
-
-
-def tracker(args: argparse.Namespace, name: str) -> SummaryWriter:
-    if args.wandb:
-        wandb.init(
-            project=args.wandb_project_name,
-            entity=args.wandb_entity,
-            sync_tensorboard=True,
-            config=vars(args),
-            name=name,
-            monitor_gym=True,
-            save_code=True,
-        )
-    summary_writer = SummaryWriter(name)
-    summary_writer.add_text(
-        "hyperparameters",
-        "|param|value|\n|-|-|\n%s" % ("\n".join([f"|{k}|{v}|" for k, v in vars(args).items()])),
-    )
-    return summary_writer
-
-
-def set_seed(seed: int, torch_deterministic: bool, cuda: bool) -> None:
-    random.seed(seed)
-    np.random.seed(seed)
-    torch.manual_seed(seed)
-    if torch.cuda.is_available() and cuda:
-        torch.cuda.manual_seed_all(seed)
-    torch.backends.cudnn.deterministic = torch_deterministic
-    torch.backends.cudnn.benchmark = not torch_deterministic
-
-
-def env_setup(num_envs: int, env_id: str, gamma: float, capture_video: bool, name: str) -> ProcgenEnv:
-    procgen_envs = ProcgenEnv(num_envs=num_envs, env_name=env_id, num_levels=0, start_level=0, distribution_mode="easy")
-
-    # TODO: check for reward range for each environment
-    procgen_envs.reward_range = (-float('inf'), float('inf'))
-
-    procgen_envs = gym.wrappers.TransformObservation(procgen_envs, lambda observation: observation["rgb"])
-    procgen_envs.single_action_space = procgen_envs.action_space
-    procgen_envs.single_observation_space = procgen_envs.observation_space["rgb"]
-    procgen_envs.is_vector_env = True
-    procgen_envs = gym.wrappers.RecordEpisodeStatistics(procgen_envs)
-    if capture_video:
-        procgen_envs = gym.wrappers.RecordVideo(procgen_envs, f"videos/{name}")
-    procgen_envs = gym.wrappers.NormalizeReward(procgen_envs, gamma=gamma)
-    procgen_envs = gym.wrappers.TransformReward(procgen_envs, lambda reward: np.clip(reward, -10, 10))
-    assert isinstance(procgen_envs.single_action_space, gym.spaces.Discrete), "only discrete action space is supported"
-    return procgen_envs
-
-
-def train_ppo(rl_agent: PPOAgent, observations: torch.Tensor, actions: torch.Tensor, log_probs: torch.Tensor, inds: np.ndarray, returns: torch.Tensor,
-              values: torch.Tensor, optimizer: optim.Optimizer, b_advantages: torch.Tensor, **kwargs) \
-        -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor]:
-    _, new_logprob, entropy, new_value = rl_agent.get_action_and_value(observations, actions.long())
-    logratio = new_logprob - log_probs
-    ratio = logratio.exp()
-
-    with torch.no_grad():
-        # calculate approx_kl http://joschu.net/blog/kl-approx.html
-        old_approx_kl = (-logratio).mean()
-        approx_kl = ((ratio - 1) - logratio).mean()
-
-    mb_advantages = b_advantages[inds]
-    mb_advantages = (mb_advantages - mb_advantages.mean()) / (mb_advantages.std() + 1e-8)
-
-    # Policy loss
-    pg_loss1 = -mb_advantages * ratio
-    pg_loss2 = -mb_advantages * torch.clamp(ratio, 1 - kwargs["clip_coef"], 1 + kwargs["clip_coef"])
-    pg_loss = torch.max(pg_loss1, pg_loss2).mean()
-
-    # Value loss
-    new_value = new_value.view(-1)
-    v_loss_unclipped = (new_value - returns[inds]) ** 2
-    v_clipped = values + torch.clamp(
-        new_value - values,
-        -kwargs["clip_coef"],
-        kwargs["clip_coef"],
-    )
-    v_loss_clipped = (v_clipped - returns[inds]) ** 2
-    v_loss_max = torch.max(v_loss_unclipped, v_loss_clipped)
-    v_loss = 0.5 * v_loss_max.mean()
-
-    ent_loss = entropy.mean()
-    loss = pg_loss - kwargs["ent_coef"] * ent_loss + v_loss * kwargs["vf_coef"]
-
-    optimizer.zero_grad()
-    loss.backward()
-    nn.utils.clip_grad_norm_(rl_agent.parameters(), kwargs["max_grad_norm"])
-    optimizer.step()
-    return approx_kl, v_loss, pg_loss, ent_loss, old_approx_kl
-
-
-def record_stats(summary_writer: SummaryWriter, global_step: int, **kwargs) -> None:
-    for k, v in kwargs.items():
-        if isinstance(v, torch.Tensor):
-            v = v.item()
-        summary_writer.add_scalar(f"charts/{k}", v, global_step)
-
-
-def bootstrap_value(observation: torch.Tensor, rb: ReplayBuffer, rl_agent: PPOAgent, device: torch.device, next_done: torch.Tensor, num_steps: int,
-                    gamma: float, gae_lambda: float) -> torch.Tensor:
-    with torch.no_grad():
-        next_value = rl_agent.get_value(observation).reshape(1, -1)
-        advantages = torch.zeros_like(rb._rewards).to(device)
-        lastgaelam = 0
-        for t in reversed(range(num_steps)):
-            if t == num_steps - 1:
-                next_nonterminal = 1.0 - next_done
-                next_values = next_value
-            else:
-                next_nonterminal = 1.0 - rb._dones[t + 1]
-                next_values = rb._values[t + 1]
-            delta = rb._rewards[t] + gamma * next_values * next_nonterminal - rb._values[t]
-            advantages[t] = lastgaelam = delta + gamma * gae_lambda * next_nonterminal * lastgaelam
-    return advantages
-
-
-def evaluate(agent: PPOAgent, env_id: str, eval_episodes: int, run_name: str, device: torch.device, capture_video: bool, gamma: float) -> np.array:
-    envs = env_setup(1, env_id, gamma, capture_video, run_name)
-    agent.eval()
-    obs = torch.Tensor(envs.reset()).to(device)
-    episodic_returns = []
-    while len(episodic_returns) < eval_episodes:
-        actions, _, _, _ = agent.get_action_and_value(torch.Tensor(obs).to(device))
-        next_obs, reward, done, info = envs.step(actions.cpu().numpy())
-        reward, done, info = reward[0], done[0], info[0]
-        if done:
-            print(f"eval_episode={len(episodic_returns)}, episodic_return={info['episode']['r']}")
-            episodic_returns += [info["episode"]["r"]]
-        obs = next_obs
-    agent.train()
-    print(f"mean eval perforamnce: {np.mean(episodic_returns)}")
-    return np.array(episodic_returns)
-
-
-def variable_initialization(args: argparse.Namespace) -> Tuple[int, int, int, str, str, float, SummaryWriter, torch.device]:
-    b_size = int(args.num_envs * args.num_steps)
-    num_iter = args.total_timesteps // b_size
-    mini_b_size = b_size // args.num_minibatches
-    uuid_code = str(uuid.uuid4())[:8]
-    run = f"./runs/{args.env_id}/{args.exp_name}/{uuid_code}"
-    if not os.path.exists(run):
-        os.makedirs(run)
-    model_dir = f"{run}/best.pt"
-    best_p = -np.infty
-    summary_writer = tracker(args, run)
-    set_seed(args.seed, args.torch_deterministic, args.cuda)
-    device = torch.device("cuda" if torch.cuda.is_available() and args.cuda else "cpu")
-    return batch_size, num_iter, mini_b_size, run, model_dir, best_p, summary_writer, device
-
-
-if __name__ == "__main__":
-    input_args = get_args()
-    batch_size, num_iterations, minibatch_size, run_name, model_path, best_performance, writer, device = variable_initialization(input_args)
-
-    envs = env_setup(input_args.num_envs, input_args.env_id, input_args.gamma, input_args.capture_video, run_name)
-    agent = PPOAgent(envs).to(device)
-    optimizer = optim.Adam(agent.parameters(), lr=input_args.learning_rate, eps=1e-5)
-
-    # ALGO Logic: Storage setup
-    replay_buffer = ReplayBuffer(input_args.num_steps, input_args.num_envs, envs.single_observation_space, envs.single_action_space, device)
-
-    # TRY NOT TO MODIFY: start the game
-    global_step = 0
-    start_time = time.time()
-    obs = torch.Tensor(envs.reset()).to(device)
-    dones = torch.zeros(input_args.num_envs).to(device)
-
-    ppo_kwargs = {
-        "clip_coef": input_args.clip_coef,
-        "ent_coef": input_args.ent_coef,
-        "vf_coef": input_args.vf_coef,
-        "max_grad_norm": input_args.max_grad_norm,
-    }
-
-    for iteration in range(1, num_iterations + 1):
-        for step in range(0, input_args.num_steps):
-            global_step += input_args.num_envs
-
-            # ALGO LOGIC: action logic
-            with torch.no_grad():
-                actions, logprobs, _, value = agent.get_action_and_value(obs)
-                values = value.flatten()
-
-            # TRY NOT TO MODIFY: execute the game and log data.
-            next_obs, rewards, dones, info = envs.step(actions.cpu().numpy())
-            rewards = torch.tensor(rewards).to(device).view(-1)
-            next_obs = torch.Tensor(next_obs).to(device)
-            dones = torch.Tensor(dones).to(device)
-
-            replay_buffer.add_transition(obs, actions, rewards, next_obs, dones, values, logprobs)
-
-            obs = torch.Tensor(next_obs).to(device)
-            for item in info:
-                if "episode" in item.keys():
-                    writer.add_scalar("charts/episodic_return", item["episode"]["r"], global_step)
-                    writer.add_scalar("charts/episodic_length", item["episode"]["l"], global_step)
-                    break
-
-        # bootstrap value if not done
-        advantages = bootstrap_value(obs, replay_buffer, agent, device, dones, input_args.num_steps, input_args.gamma, input_args.gae_lambda)
-        returns = advantages + values
-        b_returns = returns.reshape(-1)
-
-        # Optimizing the policy and value network
-        b_inds = np.arange(batch_size)
-        for epoch in range(input_args.update_epochs):
-            np.random.shuffle(b_inds)
-            for start in range(0, batch_size, minibatch_size):
-                end = start + minibatch_size
-                mb_inds = b_inds[start:end]
-                rb_obs, rb_actions, rb_logprobs, rb_values = replay_buffer.sample_by_indices(mb_inds, envs.single_observation_space.shape,
-                                                                                             envs.single_action_space.shape)
-
-                kl, value_loss, policy_loss, entropy_loss, old_kl = train_ppo(agent, rb_obs, rb_actions, rb_logprobs, mb_inds, b_returns, rb_values,
-                                                                              optimizer, advantages.reshape(-1), **ppo_kwargs)
-        explained_var = torch.nan if torch.var(b_returns) == 0 else 1 - torch.var(b_returns - replay_buffer._values.reshape(-1)) / torch.var(b_returns)
-        record_kwargs = {
-            "value_loss": value_loss,
-            "policy_loss": policy_loss,
-            "entropy_loss": entropy_loss,
-            "old_approx_kl": old_kl,
-            "approx_kl": kl,
-            "explained_variance": explained_var
-        }
-        record_stats(writer, global_step, **record_kwargs)
-
-        episodic_returns = evaluate(agent, input_args.env_id, input_args.eval_episodes, f"{run_name}-eval", device, input_args.capture_video,
-                                    input_args.gamma)
-        if episodic_returns.mean() > best_performance:
-            torch.save(agent.state_dict(), model_path)
-            print(f"best model saved to {model_path} - performance: {episodic_returns.mean()}")
-        for idx, episodic_return in enumerate(episodic_returns):
-            writer.add_scalar("eval/episodic_return", episodic_return, idx)
-
-    envs.close()
-    writer.close()
diff --git a/algorithms/utils.py b/algorithms/utils.py
index 452f1f7..c46be27 100644
--- a/algorithms/utils.py
+++ b/algorithms/utils.py
@@ -1,78 +1,152 @@
-from typing import List, Dict, Tuple
+import random
+from collections import deque
 
-import gym
-import numpy as np
 import torch
+from torch.utils.data.sampler import BatchSampler, SubsetRandomSampler
 
+from procgen_wrappers import *
 
-class ReplayBuffer:
-    def __init__(self, num_steps: int, num_envs: int, observation_space: gym.spaces.Space, action_space: gym.spaces.Space, device: str):
-        self._buffer_size = num_steps
-        self._pointer = 0
-        self._size = 0
-        self._obs = torch.zeros((num_steps, num_envs) + observation_space.shape).to(device)
-        self._next_obs = torch.zeros((num_steps, num_envs) + observation_space.shape).to(device)
-        self._actions = torch.zeros((num_steps, num_envs) + action_space.shape).to(device)
-        self._logprobs = torch.zeros((num_steps, num_envs)).to(device)
-        self._rewards = torch.zeros((num_steps, num_envs)).to(device)
-        self._dones = torch.zeros((num_steps, num_envs)).to(device)
-        self._values = torch.zeros((num_steps, num_envs)).to(device)
-        self._device = device
-
-    def _to_tensor(self, data: np.ndarray) -> torch.Tensor:
-        return torch.tensor(data, dtype=torch.float32, device=self._device)
-
-    # Loads data in d4rl format, i.e. from Dict[str, np.array].
-    def load_dataset(self, data: Dict[str, np.ndarray]) -> None:
-        n_transitions = data["observations"].shape[0]
-        if n_transitions > self._buffer_size + self._size:
-            raise ValueError("Replay buffer is smaller than the dataset you are trying to load!")
-        self._obs[self._size:n_transitions + self._size] = self._to_tensor(data["observations"])
-        self._actions[self._size:n_transitions + self._size] = self._to_tensor(data["actions"])
-        self._rewards[self._size:n_transitions + self._size] = self._to_tensor(data["rewards"][..., None])
-        self._next_obs[self._size:n_transitions + self._size] = self._to_tensor(data["next_observations"])
-        self._dones[self._size:n_transitions + self._size] = self._to_tensor(data["terminals"][..., None])
-        self._size += n_transitions
-        self._pointer = min(self._size, n_transitions)
-
-        print(f"Dataset size: {self._size}")
-
-    def sample(self, batch_size: int) -> List[torch.Tensor]:
-        indices = np.random.randint(0, min(self._size, self._pointer), size=batch_size)
-        obs = self._obs[indices]
-        actions = self._actions[indices]
-        rewards = self._rewards[indices]
-        next_obs = self._next_obs[indices]
-        dones = self._dones[indices]
-        return [obs, actions, rewards, next_obs, dones]
-
-    def sample_by_range(self, start_i: int, end_i: int) -> List[torch.Tensor]:
-        indices = np.arange(start_i, end_i)
-        obs = self._obs[indices]
-        actions = self._actions[indices]
-        rewards = self._rewards[indices]
-        next_obs = self._next_obs[indices]
-        dones = self._dones[indices]
-        return [obs, actions, rewards, next_obs, dones]
-
-    def sample_by_indices(self, indices: List, obs_shape: Tuple, action_shape: Tuple) -> List[torch.Tensor]:
-        obs = self._obs.reshape((-1,) + obs_shape)[indices]
-        actions = self._actions.reshape((-1,) + action_shape)[indices]
-        logprobs = self._logprobs.reshape(-1)[indices]
-        values = self._values.reshape(-1)[indices]
-        return [obs, actions, logprobs, values]
-
-    def add_transition(self, obs: torch.Tensor, actions: torch.Tensor, rewards: torch.Tensor, next_obs: torch.Tensor, dones: torch.Tensor,
-                       values: torch.Tensor = None, logprobs: torch.Tensor = None) -> None:
-        self._obs[self._pointer] = obs
-        self._actions[self._pointer] = actions
-        self._rewards[self._pointer] = rewards
-        self._next_obs[self._pointer] = next_obs
-        self._dones[self._pointer] = dones
-        if values is not None:
-            self._values[self._pointer] = values
-        if logprobs is not None:
-            self._logprobs[self._pointer] = logprobs
-
-        self._pointer = (self._pointer + 1) % self._buffer_size
-        self._size = min(self._size + 1, self._buffer_size)
+
+class Storage:
+    def __init__(self, obs_shape, hidden_state_size, num_steps, num_envs, device):
+        print('::[LOGGING]::INITIALIZING STORAGE...')
+        self.obs_shape = obs_shape
+        self.hidden_state_size = hidden_state_size
+        self.num_steps = num_steps
+        self.num_envs = num_envs
+        self.device = device
+        self.reset()
+
+    def reset(self):
+        self.obs_batch = torch.zeros(self.num_steps + 1, self.num_envs, *self.obs_shape)
+        self.hidden_states_batch = torch.zeros(self.num_steps + 1, self.num_envs, self.hidden_state_size)
+        self.act_batch = torch.zeros(self.num_steps, self.num_envs)
+        self.rew_batch = torch.zeros(self.num_steps, self.num_envs)
+        self.done_batch = torch.zeros(self.num_steps, self.num_envs)
+        self.log_prob_act_batch = torch.zeros(self.num_steps, self.num_envs)
+        self.value_batch = torch.zeros(self.num_steps + 1, self.num_envs)
+        self.return_batch = torch.zeros(self.num_steps, self.num_envs)
+        self.adv_batch = torch.zeros(self.num_steps, self.num_envs)
+        self.info_batch = deque(maxlen=self.num_steps)
+        self.step = 0
+
+    def store(self, obs, hidden_state, act, rew, done, info, log_prob_act, value):
+        self.obs_batch[self.step] = torch.from_numpy(obs.copy())
+        self.hidden_states_batch[self.step] = torch.from_numpy(hidden_state.copy())
+        self.act_batch[self.step] = torch.from_numpy(act.copy())
+        self.rew_batch[self.step] = torch.from_numpy(rew.copy())
+        self.done_batch[self.step] = torch.from_numpy(done.copy())
+        self.log_prob_act_batch[self.step] = torch.from_numpy(log_prob_act.copy())
+        self.value_batch[self.step] = torch.from_numpy(value.copy())
+        self.info_batch.append(info)
+
+        self.step = (self.step + 1) % self.num_steps
+
+    def store_last(self, last_obs, last_hidden_state, last_value):
+        self.obs_batch[-1] = torch.from_numpy(last_obs.copy())
+        self.hidden_states_batch[-1] = torch.from_numpy(last_hidden_state.copy())
+        self.value_batch[-1] = torch.from_numpy(last_value.copy())
+
+    def compute_estimates(self, gamma=0.99, lmbda=0.95, use_gae=True, normalize_adv=True):
+        rew_batch = self.rew_batch
+        if use_gae:
+            A = 0
+            for i in reversed(range(self.num_steps)):
+                rew = rew_batch[i]
+                done = self.done_batch[i]
+                value = self.value_batch[i]
+                next_value = self.value_batch[i + 1]
+
+                delta = (rew + gamma * next_value * (1 - done)) - value
+                self.adv_batch[i] = A = gamma * lmbda * A * (1 - done) + delta
+        else:
+            G = self.value_batch[-1]
+            for i in reversed(range(self.num_steps)):
+                rew = rew_batch[i]
+                done = self.done_batch[i]
+
+                G = rew + gamma * G * (1 - done)
+                self.return_batch[i] = G
+
+        self.return_batch = self.adv_batch + self.value_batch[:-1]
+        if normalize_adv:
+            self.adv_batch = (self.adv_batch - torch.mean(self.adv_batch)) / (torch.std(self.adv_batch) + 1e-8)
+
+    def fetch_train_generator(self, mini_batch_size=None, recurrent=False):
+        batch_size = self.num_steps * self.num_envs
+        if mini_batch_size is None:
+            mini_batch_size = batch_size
+        # If agent's policy is not recurrent, data could be sampled without considering the time-horizon
+        if not recurrent:
+            sampler = BatchSampler(SubsetRandomSampler(range(batch_size)),
+                                   mini_batch_size,
+                                   drop_last=True)
+            for indices in sampler:
+                obs_batch = torch.FloatTensor(self.obs_batch[:-1]).reshape(-1, *self.obs_shape)[indices].to(self.device)
+                hidden_state_batch = torch.FloatTensor(self.hidden_states_batch[:-1]).reshape(-1, self.hidden_state_size).to(self.device)
+                act_batch = torch.FloatTensor(self.act_batch).reshape(-1)[indices].to(self.device)
+                done_batch = torch.FloatTensor(self.done_batch).reshape(-1)[indices].to(self.device)
+                log_prob_act_batch = torch.FloatTensor(self.log_prob_act_batch).reshape(-1)[indices].to(self.device)
+                value_batch = torch.FloatTensor(self.value_batch[:-1]).reshape(-1)[indices].to(self.device)
+                return_batch = torch.FloatTensor(self.return_batch).reshape(-1)[indices].to(self.device)
+                adv_batch = torch.FloatTensor(self.adv_batch).reshape(-1)[indices].to(self.device)
+                yield obs_batch, hidden_state_batch, act_batch, done_batch, log_prob_act_batch, value_batch, return_batch, adv_batch
+        # If agent's policy is recurrent, data should be sampled along the time-horizon
+        else:
+            num_mini_batch_per_epoch = batch_size // mini_batch_size
+            num_envs_per_batch = self.num_envs // num_mini_batch_per_epoch
+            perm = torch.randperm(self.num_envs)
+            for start_ind in range(0, self.num_envs, num_envs_per_batch):
+                idxes = perm[start_ind:start_ind + num_envs_per_batch]
+                obs_batch = torch.FloatTensor(self.obs_batch[:-1, idxes]).reshape(-1, *self.obs_shape).to(self.device)
+                # [0:1] instead of [0] to keep two-dimensional array
+                hidden_state_batch = torch.FloatTensor(self.hidden_states_batch[0:1, idxes]).reshape(-1, self.hidden_state_size).to(self.device)
+                act_batch = torch.FloatTensor(self.act_batch[:, idxes]).reshape(-1).to(self.device)
+                done_batch = torch.FloatTensor(self.done_batch[:, idxes]).reshape(-1).to(self.device)
+                log_prob_act_batch = torch.FloatTensor(self.log_prob_act_batch[:, idxes]).reshape(-1).to(self.device)
+                value_batch = torch.FloatTensor(self.value_batch[:-1, idxes]).reshape(-1).to(self.device)
+                return_batch = torch.FloatTensor(self.return_batch[:, idxes]).reshape(-1).to(self.device)
+                adv_batch = torch.FloatTensor(self.adv_batch[:, idxes]).reshape(-1).to(self.device)
+                yield obs_batch, hidden_state_batch, act_batch, done_batch, log_prob_act_batch, value_batch, return_batch, adv_batch
+
+    def fetch_log_data(self):
+        if 'env_reward' in self.info_batch[0][0]:
+            rew_batch = []
+            for step in range(self.num_steps):
+                infos = self.info_batch[step]
+                rew_batch.append([info['env_reward'] for info in infos])
+            rew_batch = np.array(rew_batch)
+        else:
+            rew_batch = self.rew_batch.numpy()
+        if 'env_done' in self.info_batch[0][0]:
+            done_batch = []
+            for step in range(self.num_steps):
+                infos = self.info_batch[step]
+                done_batch.append([info['env_done'] for info in infos])
+            done_batch = np.array(done_batch)
+        else:
+            done_batch = self.done_batch.numpy()
+        return rew_batch, done_batch
+
+
+def set_global_seeds(seed, torch_deterministic=True):
+    random.seed(seed)
+    np.random.seed(seed)
+    torch.manual_seed(seed)
+    torch.cuda.manual_seed_all(seed)
+    torch.backends.cudnn.deterministic = torch_deterministic
+    torch.backends.cudnn.benchmark = not torch_deterministic
+
+
+def adjust_lr(optimizer, init_lr, timesteps, max_timesteps):
+    lr = init_lr * (1 - (timesteps / max_timesteps))
+    for param_group in optimizer.param_groups:
+        param_group['lr'] = lr
+    return optimizer
+
+
+def get_latest_model(model_dir):
+    """given model_dir with files named model_n.pth where n is an integer,
+    return the filename with largest n"""
+    steps = [int(filename[6:-4]) for filename in os.listdir(model_dir) if filename.startswith("model_")]
+    return list(os.listdir(model_dir))[np.argmax(steps)]
Submodule cliport contains untracked content
Submodule cliport contains modified content
diff --git a/cliport/cliport/models/core/clip.py b/cliport/cliport/models/core/clip.py
index 0ba6e95..fe2c96d 100644
--- a/cliport/cliport/models/core/clip.py
+++ b/cliport/cliport/models/core/clip.py
@@ -488,7 +488,8 @@ def build_model(state_dict: dict):
     )
 
     for key in ["input_resolution", "context_length", "vocab_size"]:
-        del state_dict[key]
+        if key in state_dict.keys():
+            del state_dict[key]
 
     convert_weights(model)
     model.load_state_dict(state_dict)
@@ -531,7 +532,7 @@ def available_models():
     return list(_MODELS.keys())
 
 
-def load_clip(name: str, device: Union[str, torch.device] = "cuda" if torch.cuda.is_available() else "cpu", jit=True):
+def load_clip(name: str, device: Union[str, torch.device] = "cuda" if torch.cuda.is_available() else "cpu", jit=False):
     if name not in _MODELS:
         raise RuntimeError(f"Model {name} not found; available models = {available_models()}")
 
@@ -556,7 +557,6 @@ def load_clip(name: str, device: Union[str, torch.device] = "cuda" if torch.cuda
     # patch the device names
     device_holder = torch.jit.trace(lambda: torch.ones([]).to(torch.device(device)), example_inputs=[])
     device_node = [n for n in device_holder.graph.findAllNodes("prim::Constant") if "Device" in repr(n)][-1]
-
     def patch_device(module):
         graphs = [module.graph] if hasattr(module, "graph") else []
         if hasattr(module, "forward1"):
Submodule procgenAISC 0000000...7821f2c (new submodule)
diff --git a/procgenAISC/.gitignore b/procgenAISC/.gitignore
new file mode 100644
index 0000000..892edd8
--- /dev/null
+++ b/procgenAISC/.gitignore
@@ -0,0 +1,117 @@
+# Byte-compiled / optimized / DLL files
+__pycache__/
+*.py[cod]
+*$py.class
+
+# C extensions
+*.so
+
+# Distribution / packaging
+.Python
+build/
+develop-eggs/
+dist/
+downloads/
+eggs/
+.eggs/
+lib/
+lib64/
+parts/
+sdist/
+var/
+wheels/
+*.egg-info/
+.installed.cfg
+*.egg
+MANIFEST
+
+# PyInstaller
+#  Usually these files are written by a python script from a template
+#  before PyInstaller builds the exe, so as to inject date/other infos into it.
+*.manifest
+*.spec
+
+# Installer logs
+pip-log.txt
+pip-delete-this-directory.txt
+
+# Unit test / coverage reports
+htmlcov/
+.tox/
+.coverage
+.coverage.*
+.cache
+nosetests.xml
+coverage.xml
+*.cover
+.hypothesis/
+.pytest_cache/
+
+# Translations
+*.mo
+*.pot
+
+# Django stuff:
+*.log
+local_settings.py
+db.sqlite3
+
+# Flask stuff:
+instance/
+.webassets-cache
+
+# Scrapy stuff:
+.scrapy
+
+# Sphinx documentation
+docs/_build/
+
+# PyBuilder
+target/
+
+# Jupyter Notebook
+.ipynb_checkpoints
+
+# pyenv
+.python-version
+
+# celery beat schedule file
+celerybeat-schedule
+
+# SageMath parsed files
+*.sage.py
+
+# Environments
+.env
+.venv
+env/
+venv/
+ENV/
+env.bak/
+venv.bak/
+
+# Spyder project settings
+.spyderproject
+.spyproject
+
+# Rope project settings
+.ropeproject
+
+# mkdocs documentation
+/site
+
+# mypy
+.mypy_cache/
+
+.envrc
+.build/
+
+
+
+**.vscode
+**scratch
+**temp*
+NOTES.md
+build.sh
+pip-reqs.txt
+procgen/data/assets/aisc
diff --git a/procgenAISC/.travis.yml b/procgenAISC/.travis.yml
new file mode 100644
index 0000000..fd8a89c
--- /dev/null
+++ b/procgenAISC/.travis.yml
@@ -0,0 +1,72 @@
+before_script:
+  - $PIP --version
+  - $PIP install -e procgen-build
+
+jobs:
+  include:
+    - name: "Linux Development"
+      os: linux
+      language: python
+      python: 3.7
+      sudo: required
+      script: python -u -m procgen_build.dev_test
+      env:
+        - PIP=pip
+
+    - name: "Linux Package"
+      os: linux
+      dist: bionic  # Ubuntu 18.04 LTS, the packages are built inside docker so this doesn't affect much
+      language: python
+      python: 3.7
+      sudo: required
+      services:
+        - docker
+      script: python -u -m procgen_build.build_package
+      env:
+        - PIP=pip
+
+    - name: "Mac Development"
+      os: osx
+      osx_image: xcode11.2  # MacOS X 10.14 (https://docs.travis-ci.com/user/reference/osx/#macos-version)
+      language: generic
+      before_install:
+        - curl https://pyenv.run | bash
+        - pyenv install 3.7.5
+        - pyenv global 3.7.5
+      script: python -u -m procgen_build.dev_test
+      env:
+        - PIP=pip3
+        - PATH=/Users/travis/.pyenv/shims:$PATH
+
+    - name: "Mac Package"
+      os: osx
+      osx_image: xcode11.2
+      language: generic
+      before_install:
+        - curl https://pyenv.run | bash
+        - pyenv install 3.7.5
+        - pyenv global 3.7.5
+      script: python3 -u -m procgen_build.build_package
+      env:
+        - PIP=pip3
+        - PATH=/Users/travis/.pyenv/shims:$PATH
+
+    - name: "Windows Development"
+      os: windows
+      language: shell
+      before_install:
+        - choco install python3 --version 3.7.5 --no-progress --yes
+      env:
+        - PIP=pip
+        - PATH=/c/Python37:/c/Python37/Scripts:$PATH
+      script: python -u -m procgen_build.dev_test
+
+    - name: "Windows Package"
+      os: windows
+      language: shell
+      before_install:
+        - choco install python3 --version 3.7.5 --no-progress --yes
+      env:
+        - PIP=pip
+        - PATH=/c/Python37:/c/Python37/Scripts:$PATH
+      script: python -u -m procgen_build.build_package
\ No newline at end of file
diff --git a/procgenAISC/ASSET_LICENSES.md b/procgenAISC/ASSET_LICENSES.md
new file mode 100644
index 0000000..07247d4
--- /dev/null
+++ b/procgenAISC/ASSET_LICENSES.md
@@ -0,0 +1,85 @@
+```
+Many Game Asset Packs
+Author: kenney
+CC0: https://www.kenney.nl/assets
+
+Frog Asset
+Author: GameArtGuppy.com
+CC-BY 4.0: https://www.gameartguppy.com/shop/frog-lilypad/
+
+Food Icons
+Author: thekingphoenix
+CC0: https://opengameart.org/content/icons-food
+
+Space Background
+Author: ansimuz
+CC0: https://opengameart.org/content/space-background-3
+
+Sci-Fi Background
+Author: ansimuz
+CC0: https://ansimuz.itch.io/sideview-sci-fi
+
+Mountain Background
+Author: ansimuz
+CC-BY 4.0: https://ansimuz.itch.io/mountain-dusk-parallax-background
+
+Forest Background
+Author: ansimuz
+CC-BY 4.0: https://ansimuz.itch.io/parallax-forest
+
+Background
+Author: rubberduck
+CC0: https://opengameart.org/content/background-from-glitch-assets
+
+Space Backgrounds
+Author: Rawdanitsu
+CC0: https://opengameart.org/content/space-backgrounds-3
+
+Snow Background
+Author: ramses2099
+CC0: https://opengameart.org/content/background-2
+
+Top-Down Backgrounds
+Author: davis123
+CC-BY 3.0: https://opengameart.org/content/backgrounds-topdown-games
+
+Water Backgrounds
+Author: rh0
+CC0: https://opengameart.org/content/few-water-backgrounds-1366%C3%97768
+
+Water Backgrounds
+Author: Alucard
+CC-BY 3.0: https://opengameart.org/content/2d-background-underwater
+
+Water Backgrounds
+Author: SugarMoonWitch
+CC-BY 3.0: https://opengameart.org/content/underwater-bg
+
+Water Backgrounds
+Author: lzubiaur
+CC0: https://opengameart.org/content/underwater-background-0
+
+2D Background Set
+Author: Alucard
+CC-BY 3.0: https://opengameart.org/content/2d-backgrounds-set
+
+Parallax 2D Backgrounds
+Author: CraftPix.net 2D Game Assets
+OGA-BY 3.0: https://opengameart.org/content/parallax-2d-backgrounds
+
+Fantasy Cartoon Game Backgrounds
+Author: CraftPix.net 2D Game Assets
+OGA-BY 3.0: https://opengameart.org/content/fantasy-cartoon-game-backgrounds
+
+Beach Backgrounds
+Author: CraftPix.net 2D Game Assets
+OGA-BY 3.0: https://opengameart.org/content/beach-2d-backgrounds
+
+Battle Backgrounds
+Author: Nidhoggn
+CC0: https://opengameart.org/content/backgrounds-3
+
+Sunrise Background
+Author: tgfcoder
+CC0: https://opengameart.org/content/morning-sunrise-background
+```
\ No newline at end of file
diff --git a/procgenAISC/CHANGES.md b/procgenAISC/CHANGES.md
new file mode 100644
index 0000000..702e5aa
--- /dev/null
+++ b/procgenAISC/CHANGES.md
@@ -0,0 +1,50 @@
+# Changelog
+
+## 0.10.4
+
+* Support `render_mode` to gym environment and update docs to remove references to the confusing `render=True` option.
+
+## 0.10.3
+
+* fix render option for gym environment
+
+## 0.10.2
+
+* fix interactive script
+
+## 0.10.1
+
+* build fixes
+* save action during libenv_act
+
+## 0.10.0
+
+* add `set_state`, `get_state` methods to save/restore environment state
+* new flags: `use_backgrounds`, `restrict_themes`, `use_monocrhome_assets`
+* switch to use `gym3` instead of `libenv` + `Scalarize`, `gym` and `baselines.VecEnv` interfaces are still available with the same names, the `gym3` environment is called `ProcgenGym3Env`
+* zero initialize more member variables
+* changed `info` dict to have more clear keys, `prev_level_complete` tells you if the level was complete on the previous timestep, since the `info` dict corresponds to the current timestep, and the current timestep is never on a complete level due to automatic resetting.  Similarly, `prev_level_seed` is the level seed from the previous timestep.
+* environment creation should be slightly faster
+
+## 0.9.5
+
+* zero initialize member variables from base classes
+
+## 0.9.4
+
+* add random agent script
+* add example Dockerfile
+
+## 0.9.3
+
+* changed pyglet dependency to `pyglet~=1.4.8`
+* fix issue with procgen thinking it was installed in development mode and attempting to build when installed from a pypi package
+* make procgen more fork safe when `num_threads=0`
+
+## 0.9.2
+
+* fixed type bug in interactive script that would sometimes cause the script to not start
+
+## 0.9.1
+
+* initial release
diff --git a/procgenAISC/CONTRIBUTING.md b/procgenAISC/CONTRIBUTING.md
new file mode 100644
index 0000000..5190d11
--- /dev/null
+++ b/procgenAISC/CONTRIBUTING.md
@@ -0,0 +1,7 @@
+# Contributing
+
+Please report reproducible bugs through the issue tracker (please include a `level_seed` if applicable), as well as issues with installing or running on any supported platform.  
+
+Because these environments are meant for experiments, we would like to minimize changes.  Changing anything that impacts training results will make it hard to compare results from previous experiments and so this should be avoided. As a result, PRs that add new functionality are unlikely to be accepted.
+
+Feel free to fork this repo and make your own customizations.  The build setup uses Travis to make creating a fork and producing your own packages relatively easy.
\ No newline at end of file
diff --git a/procgenAISC/LICENSE b/procgenAISC/LICENSE
new file mode 100644
index 0000000..b8b3158
--- /dev/null
+++ b/procgenAISC/LICENSE
@@ -0,0 +1,21 @@
+MIT License
+
+Copyright (c) 2019 OpenAI
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
\ No newline at end of file
diff --git a/procgenAISC/README.md b/procgenAISC/README.md
new file mode 100644
index 0000000..b94af5b
--- /dev/null
+++ b/procgenAISC/README.md
@@ -0,0 +1,51 @@
+# Goal Misgeneralization in Procgen
+
+This is a fork of the [procgen benchmark](https://github.com/openai/procgen) that implements modifications for the paper Goal Misgeneralization in Deep Reinforcement Learning.
+
+## Descriptions of the modified environments
+
+* `coinrun_aisc`: Like `coinrun`, but the coin is placed randomly on ground level instead of at the far right end.
+* `coinrun`: Added a flag `--random_percent`, which places the coin randomly in a given percentage of environments. Default 0.
+* `heist_aisc_many_chests`: A heavily modified `heist`. Doors are now 'chests' (they do not prevent the agent from passing). Every key can open every chest. The agent is rewarded for opening chests. This version generates twice as many chests as keys. 
+* `heist_aisc_many_keys`: Same as `heist_aisc_many_chests`, but instead has twice as many keys as chests.
+* `maze_aisc`: Like maze, but the cheese is always to be found in the top right corner.
+* `maze_yellowgem`: like maze, but the goal is a yellow gem.
+* `maze_redgem_yellowstar`: like maze, but two objects are placed in the maze: a red gem, and a yellow star. The objective is the red gem.
+* `maze_yellowstar_redgem`: Identical to `maze_yellowstar_redgem`, but the objective is instead the yellow star.
+
+
+For both 'Keys and Chests' environments we added two options:
+* `--key_penalty`: integer. Every time the agent picks up a key it loses `options.key_penalty / 10` reward.
+* `--step_penalty`: integer time penalty. Each step, `options.step_penalty / 1000` is subtracted from the reward.
+
+For more information on the standard environments see the original repository.
+
+## Installation
+
+Below we reproduce the instructions to install from source, copied from the [original repo](https://github.com/openai/procgen).
+
+---
+
+First make sure you have a supported version of python:
+
+```
+# run these commands to check for the correct python version
+python -c "import sys; assert (3,6,0) <= sys.version_info <= (3,9,0), 'python is incorrect version'; print('ok')"
+python -c "import platform; assert platform.architecture()[0] == '64bit', 'python is not 64-bit'; print('ok')"
+```
+
+If you want to change the environments or create new ones, you should build from source.  You can get miniconda from https://docs.conda.io/en/latest/miniconda.html if you don't have it, or install the dependencies from [`environment.yml`](environment.yml) manually.  On Windows you will also need "Visual Studio 15 2017" installed.
+
+```
+git clone git@github.com:openai/procgen.git
+cd procgen
+conda env update --name procgen --file environment.yml
+conda activate procgen
+pip install -e .
+# this should say "building procgen...done"
+python -c "from procgen import ProcgenGym3Env; ProcgenGym3Env(num=1, env_name='coinrun')"
+# this should create a window where you can play the coinrun environment
+python -m procgen.interactive
+```
+
+The environment code is in C++ and is compiled into a shared library exposing the [`gym3.libenv`](https://github.com/openai/gym3/blob/master/gym3/libenv.h) C interface that is then loaded by python.  The C++ code uses [Qt](https://www.qt.io/) for drawing.
diff --git a/procgenAISC/docker/Dockerfile b/procgenAISC/docker/Dockerfile
new file mode 100644
index 0000000..6d3d597
--- /dev/null
+++ b/procgenAISC/docker/Dockerfile
@@ -0,0 +1,4 @@
+FROM ubuntu:bionic-20191202
+RUN apt-get update && apt-get install --yes --no-install-recommends python3-pip python3-setuptools libglib2.0-0
+RUN pip3 install --upgrade pip
+RUN pip3 install procgen
diff --git a/procgenAISC/environment.yml b/procgenAISC/environment.yml
new file mode 100644
index 0000000..0cef30f
--- /dev/null
+++ b/procgenAISC/environment.yml
@@ -0,0 +1,15 @@
+channels:
+  - conda-forge
+
+dependencies:
+  - python=3.7.3
+  # https://www.anaconda.com/utilizing-the-new-compilers-in-anaconda-distribution-5/
+  - c-compiler=1.0.4
+  - cmake=3.14.0
+  - qt=5.12.5  # conda-forge does not have 5.13.2 available
+  - pip
+  - pip:
+    - gym3==0.3.3
+    - numpy==1.17.2
+    - gym==0.15.3
+    - filelock==3.0.10
diff --git a/procgenAISC/procgen-build/procgen_build/__init__.py b/procgenAISC/procgen-build/procgen_build/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/procgenAISC/procgen-build/procgen_build/build_package.py b/procgenAISC/procgen-build/procgen_build/build_package.py
new file mode 100644
index 0000000..c367b93
--- /dev/null
+++ b/procgenAISC/procgen-build/procgen_build/build_package.py
@@ -0,0 +1,126 @@
+import platform
+from urllib.request import urlretrieve
+import os
+import subprocess as sp
+import fnmatch
+
+import blobfile as bf
+
+from .common import run, GCS_BUCKET
+
+
+SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
+
+
+# https://stackoverflow.com/a/50135504
+def init_vsvars():
+    print("Initializing environment for Visual Studio")
+
+    vcvars_path = "C:/Program Files (x86)/Microsoft Visual Studio/2017/BuildTools/VC/Auxiliary/Build/vcvars64.bat"
+
+    env_bat_file_path = "setup_build_environment_temp.bat"
+    env_txt_file_path = "build_environment_temp.txt"
+    with open(env_bat_file_path, "w") as env_bat_file:
+        env_bat_file.write('call "%s"\n' % vcvars_path)
+        env_bat_file.write("set > %s\n" % env_txt_file_path)
+
+    os.system(env_bat_file_path)
+    with open(env_txt_file_path, "r") as env_txt_file:
+        lines = env_txt_file.read().splitlines()
+
+    os.remove(env_bat_file_path)
+    os.remove(env_txt_file_path)
+    for line in lines:
+        if "=" not in line:
+            print(f"invalid line {repr(line)}")
+            continue
+        k, v = line.split("=", 1)
+        os.environ[k] = v
+
+
+def get_var(pattern):
+    for key, value in os.environ:
+        if fnmatch.fnmatch(key, pattern):
+            return os.environ[key]
+    return None
+
+
+def setup_google_credentials():
+    # brew install travis
+    # travis login --org
+    # gcloud iam service-accounts create procgen-travis-ci --project <project>
+    # gcloud iam service-accounts keys create /tmp/key.json --iam-account procgen-travis-ci@<project>.iam.gserviceaccount.com
+    # gsutil iam ch serviceAccount:procgen-travis-ci@<project>.iam.gserviceaccount.com:objectAdmin gs://{GCS_BUCKET}
+    # travis encrypt-file --org /tmp/key.json
+    input_path = os.path.join(SCRIPT_DIR, "key.json.enc")
+    output_path = os.path.join(os.getcwd(), "key.json")
+    for h in ["d853b3b05b79", "41b34d34b52c"]:
+        key = os.environ.get(f"encrypted_{h}_key")
+        iv = os.environ.get(f"encrypted_{h}_iv")
+        if key is not None:
+            break
+    if key is None:
+        # being compiled on a fork
+        return False
+    sp.run(["openssl", "aes-256-cbc", "-K", key, "-iv", iv, "-in", input_path, "-out", output_path, "-d"], check=True)
+    os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = output_path
+    return True
+
+
+def main():
+    have_credentials = setup_google_credentials()
+
+    os.environ.update(
+        {
+            "CIBW_BUILD": "cp36-macosx_x86_64 cp37-macosx_x86_64 cp38-macosx_x86_64 cp36-manylinux_x86_64 cp37-manylinux_x86_64 cp38-manylinux_x86_64 cp36-win_amd64 cp37-win_amd64 cp38-win_amd64",
+            "CIBW_BEFORE_BUILD": "pip install -e procgen-build && python -u -m procgen_build.build_qt --output-dir /tmp/qt5",
+            "CIBW_TEST_EXTRAS": "test",
+            # the --pyargs option causes pytest to use the installed procgen wheel
+            "CIBW_TEST_COMMAND": "pytest --verbose --benchmark-disable --durations=16 --pyargs procgen",
+            # this is where build-qt.py will put the files
+            "CIBW_ENVIRONMENT": "PROCGEN_CMAKE_PREFIX_PATH=/tmp/qt5/qt/build/qtbase/lib/cmake/Qt5",
+            # this is a bit too verbose normally
+            # "CIBW_BUILD_VERBOSITY": "3",
+        }
+    )
+    if platform.system() == "Darwin":
+        # cibuildwheel's python copy on mac os x sometimes fails with this error:
+        # [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1076)
+        urlretrieve(
+            "https://curl.haxx.se/ca/cacert.pem",
+            os.environ["TRAVIS_BUILD_DIR"] + "/cacert.pem",
+        )
+        os.environ["SSL_CERT_FILE"] = os.environ["TRAVIS_BUILD_DIR"] + "/cacert.pem"
+    elif platform.system() == "Linux":
+        # since we're inside a docker container, adjust the credentials path to point at the mounted location
+        if have_credentials:
+            os.environ["CIBW_ENVIRONMENT"] = (
+                os.environ["CIBW_ENVIRONMENT"]
+                + " GOOGLE_APPLICATION_CREDENTIALS=/host"
+                + os.environ["GOOGLE_APPLICATION_CREDENTIALS"]
+            )
+        if "TRAVIS_TAG" in os.environ:
+            # pass TRAVIS_TAG to the container so that it can build wheels with the correct version number
+            os.environ["CIBW_ENVIRONMENT"] = (
+                os.environ["CIBW_ENVIRONMENT"]
+                + " TRAVIS_TAG=" + os.environ["TRAVIS_TAG"]
+            )
+    elif platform.system() == "Windows":
+        init_vsvars()
+
+    run("pip install cibuildwheel==1.4.1")
+    run("cibuildwheel --output-dir wheelhouse")
+
+    if have_credentials:
+        print("upload wheels", platform.system())
+        input_dir = "wheelhouse"
+        output_dir = f"gs://{GCS_BUCKET}/builds/"
+        for filename in bf.listdir(input_dir):
+            src = bf.join(input_dir, filename)
+            dst = bf.join(output_dir, filename)
+            print(src, "=>", dst)
+            bf.copy(src, dst, overwrite=True)
+
+
+if __name__ == "__main__":
+    main()
diff --git a/procgenAISC/procgen-build/procgen_build/build_qt.py b/procgenAISC/procgen-build/procgen_build/build_qt.py
new file mode 100644
index 0000000..3f0b68e
--- /dev/null
+++ b/procgenAISC/procgen-build/procgen_build/build_qt.py
@@ -0,0 +1,152 @@
+import subprocess as sp
+import multiprocessing as mp
+import os
+import time
+import tarfile
+import argparse
+import threading
+import platform
+import shutil
+import hashlib
+
+import blobfile as bf
+
+from .common import run, GCS_BUCKET
+
+BUILD_VERSION = 11
+
+
+def cache_folder(name, dirpath, options, build_fn):
+    if os.path.exists(dirpath):
+        print(f"cache for {name} found locally")
+        return
+    
+    options_hash = hashlib.md5("|".join(options).encode("utf8")).hexdigest()
+    cache_path = bf.join(f"gs://{GCS_BUCKET}", "cache", f"{name}-{options_hash}.tar")
+    if "GOOGLE_APPLICATION_CREDENTIALS" not in os.environ:
+        # we don't have any credentials to do the caching, always build in this case
+        print(f"building without cache for {name}")
+        start = time.time()
+        build_fn()
+        print(f"build elapsed {time.time() - start}")
+    elif bf.exists(cache_path):
+        print(f"downloading cache for {name}: {cache_path}")
+        start = time.time()
+        with bf.BlobFile(cache_path, "rb") as f:
+            with tarfile.open(fileobj=f, mode="r") as tf:
+                tf.extractall()
+        print(f"download elapsed {time.time() - start}")
+    else:
+        print(f"building cache for {name}")
+        start = time.time()
+        build_fn()
+        print(f"cache build elapsed {time.time() - start}")
+        print(f"uploading cache for {name}")
+        start = time.time()
+        if not bf.exists(cache_path):
+            with bf.BlobFile(cache_path, "wb") as f:
+                with tarfile.open(fileobj=f, mode="w") as tf:
+                    tf.add(dirpath)
+        print(f"upload elapsed {time.time() - start}")
+
+# workaround for timeout error
+# https://docs.travis-ci.com/user/common-build-problems/#build-times-out-because-no-output-was-received
+# since we may be running inside a docker image without the travis_wait command, do this manually
+def no_timeout_worker():
+    while True:
+        time.sleep(60)
+        print(".")
+
+
+def build_qt(output_dir):
+    no_timeout_thread = threading.Thread(target=no_timeout_worker, daemon=True)
+    no_timeout_thread.start()
+
+    qt_version = "5.13.2"
+    os.makedirs(output_dir, exist_ok=True)
+    os.chdir(output_dir)
+    os.makedirs("qt", exist_ok=True)
+    os.chdir("qt")
+
+    modules = ["qtbase"]
+
+    def download_source():
+        run("git clone https://code.qt.io/qt/qt5.git")
+        os.chdir("qt5")
+        run(f"git checkout v{qt_version}")
+        run("perl init-repository --module-subset=" + ",".join(modules))
+        os.chdir("..")
+
+    # downloading the source from git takes 25 minutes on travis
+    # so cache the source so we don't have to use git
+    cache_folder("qt-source", dirpath="qt5", options=[qt_version, platform.system()] + modules, build_fn=download_source)
+
+    qt_options = [
+        "-confirm-license",
+        "-static",
+        "-release",
+        # -qtnamespace should in theory reduce the likelihood of symbol conflicts
+        "-qtnamespace",
+        "ProcGenQt",
+        "-opensource",
+        "-nomake",
+        "examples",
+        "-nomake",
+        "tests",
+        "-nomake",
+        "tools",
+        # travis mac os x server does not seem to support avx2
+        "-no-avx2",
+        "-no-avx512",
+        # extra stuff we don't need
+        "-no-pch",
+        "-no-harfbuzz",
+        "-no-openssl",
+        "-no-dbus",
+        "-no-opengl",
+        "-no-xcb",
+        "-no-libjpeg",
+        "-no-ico",
+        "-no-gif",
+        # useful for profiling
+        # "-force-debug-info",
+    ]
+    if platform.system() == "Windows":
+        # parallelize the windows build
+        qt_options.append("-mp")
+    
+    def compile_qt():
+        os.makedirs("build")
+        os.chdir("build")
+        if platform.system() == "Windows":
+            qt_configure = "..\\qt5\\configure"
+        else:
+            qt_configure = "../qt5/configure"
+        run(f"{qt_configure} -prefix {os.getcwd()}/qtbase " + " ".join(qt_options))
+        if platform.system() == "Windows":
+            run("nmake", stdout=sp.PIPE, stderr=sp.STDOUT)
+        else:
+            run(f"make -j{mp.cpu_count()}", stdout=sp.PIPE, stderr=sp.STDOUT)
+        os.chdir("..")
+        run("du -hsc build")
+        for root, dirs, files in os.walk("."):
+            for dirname in dirs:
+                if dirname in (".obj", ".pch"):
+                    dirpath = os.path.join(root, dirname)
+                    print(f"remove dir {dirpath}")
+                    shutil.rmtree(dirpath)
+        run("du -hsc build")
+
+    cache_folder("qt-build", dirpath="build", options=[platform.system(), os.environ.get("TRAVIS_OSX_IMAGE", "")] + qt_options, build_fn=compile_qt)
+
+
+def main():
+    parser = argparse.ArgumentParser()
+    parser.add_argument("--output-dir", required=True)
+    args = parser.parse_args()
+
+    build_qt(args.output_dir)
+
+
+if __name__ == "__main__":
+    main()
diff --git a/procgenAISC/procgen-build/procgen_build/common.py b/procgenAISC/procgen-build/procgen_build/common.py
new file mode 100644
index 0000000..aa35645
--- /dev/null
+++ b/procgenAISC/procgen-build/procgen_build/common.py
@@ -0,0 +1,20 @@
+import subprocess as sp
+import time
+import shlex
+
+
+GCS_BUCKET = "openai-procgen"
+
+
+def run(cmd, shell=True, **kwargs):
+    print(f"RUN: {cmd}")
+    start = time.time()
+    if not shell:
+        cmd = shlex.split(cmd)
+    p = sp.run(cmd, shell=shell, encoding="utf8", **kwargs)
+    print(f"ELAPSED: {time.time() - start}")
+    if p.returncode != 0:
+        print(f"cmd {cmd} failed")
+        if p.stdout is not None:
+            print(p.stdout[-100000:])
+        raise Exception(f"command {cmd} failed")
\ No newline at end of file
diff --git a/procgenAISC/procgen-build/procgen_build/dev_test.py b/procgenAISC/procgen-build/procgen_build/dev_test.py
new file mode 100644
index 0000000..d8e784e
--- /dev/null
+++ b/procgenAISC/procgen-build/procgen_build/dev_test.py
@@ -0,0 +1,51 @@
+import subprocess as sp
+from urllib.request import urlretrieve
+import os
+import platform
+
+from .common import run
+
+
+def apt_install(packages, recommends=False):
+    os.environ["DEBIAN_FRONTEND"] = "noninteractive"
+    sp.run(["sudo", "apt-get", "update"], check=True)
+    cmd = ["sudo", "apt-get", "install", "--yes"]
+    if not recommends:
+        cmd += ["--no-install-recommends"]
+    sp.run(cmd + list(packages), check=True)
+
+
+def main():
+    if platform.system() == "Linux":
+        apt_install(["mesa-common-dev"])
+
+    installer_urls = {
+        "Linux": "https://repo.anaconda.com/miniconda/Miniconda3-4.7.12.1-Linux-x86_64.sh",
+        "Darwin": "https://repo.anaconda.com/miniconda/Miniconda3-4.7.12.1-MacOSX-x86_64.sh",
+        "Windows": "https://repo.anaconda.com/miniconda/Miniconda3-4.7.12.1-Windows-x86_64.exe",
+    }
+    installer_url = installer_urls[platform.system()]
+    urlretrieve(
+        installer_url,
+        "miniconda-installer.exe" if platform.system() == "Windows" else "miniconda-installer.sh",
+    )
+    if platform.system() == "Windows":
+        run("miniconda-installer.exe /S /D=c:\\miniconda3")
+        os.environ["PATH"] = "C:\\miniconda3;C:\\miniconda3\\Library\\bin;C:\\miniconda3\\Scripts;" + os.environ["PATH"]
+    else:
+        conda_path = os.path.join(os.getcwd(), "miniconda")
+        run(f"bash miniconda-installer.sh -b -p {conda_path}")
+        os.environ["PATH"] = f"/{conda_path}/bin/:" + os.environ["PATH"]
+
+    def run_in_conda_env(cmd):
+        run(f"conda run --name dev {cmd}", shell=False)
+
+    run("conda env update --name dev --file environment.yml")
+    run_in_conda_env("pip show gym3")
+    run_in_conda_env("pip install -e .[test]")
+    run_in_conda_env("""python -c "from procgen import ProcgenGym3Env; ProcgenGym3Env(num=1, env_name='coinrun')" """)
+    run_in_conda_env("pytest --verbose --benchmark-disable --durations=16 .")
+
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
diff --git a/procgenAISC/procgen-build/procgen_build/key.json.enc b/procgenAISC/procgen-build/procgen_build/key.json.enc
new file mode 100644
index 0000000..ed89323
Binary files /dev/null and b/procgenAISC/procgen-build/procgen_build/key.json.enc differ
diff --git a/procgenAISC/procgen-build/setup.py b/procgenAISC/procgen-build/setup.py
new file mode 100644
index 0000000..a58aa13
--- /dev/null
+++ b/procgenAISC/procgen-build/setup.py
@@ -0,0 +1,14 @@
+from setuptools import setup, find_packages
+
+setup(
+    name="procgen_build",
+    packages=find_packages(),
+    version="0.0.1",
+    install_requires=[
+        "blobfile==0.8.0",
+        # rather than rely on system cmake, install it here
+        "cmake==3.15.3",
+        # this is required by procgen/build.py
+        "gym3==0.3.0",
+    ],
+)
diff --git a/procgenAISC/procgen/CMakeLists.txt b/procgenAISC/procgen/CMakeLists.txt
new file mode 100644
index 0000000..06807bf
--- /dev/null
+++ b/procgenAISC/procgen/CMakeLists.txt
@@ -0,0 +1,87 @@
+cmake_minimum_required(VERSION 3.10 FATAL_ERROR)
+project(codegen)
+
+set(CMAKE_CXX_STANDARD 17)
+set(CMAKE_CXX_STANDARD_REQUIRED ON)
+set(CMAKE_POSITION_INDEPENDENT_CODE ON)
+set(CMAKE_CXX_VISIBILITY_PRESET hidden)
+
+option(PROCGEN_PACKAGE "Set if the python package is being built" OFF)
+
+# print commands used, useful for debugging build
+set(CMAKE_VERBOSE_MAKEFILE ${PROCGEN_PACKAGE})
+
+
+if(APPLE)
+  # clang defaults to 20 errors, but usually only the first one is useful
+  add_compile_options(-ferror-limit=1)
+  # only produce errors on mac where development is done
+  add_compile_options(-Werror -Wextra -Wshadow -Wall -Wformat=2 -Wundef -Wvla -Wmissing-include-dirs -Wnon-virtual-dtor -Wno-unused-parameter)
+endif()
+
+if(MSVC)
+  # allow strcpy
+  add_definitions(-D_CRT_SECURE_NO_WARNINGS)
+endif()
+
+if (APPLE OR UNIX)
+  if(PROCGEN_PACKAGE)
+    # compile for the minimum spec processor
+    set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO} -march=ivybridge")
+  else()
+    set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO} -march=native")
+  endif()
+
+  # leave frame pointers so that profiling tools will still work
+  set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO} -fno-omit-frame-pointer")
+endif()
+
+# include qt5
+find_package(Qt5 COMPONENTS Gui REQUIRED)
+
+add_library(env
+  SHARED
+  src/assetgen.cpp
+  src/basic-abstract-game.cpp
+  src/cpp-utils.cpp
+  src/entity.cpp
+  src/game.cpp
+  src/game-registry.cpp
+  src/games/dodgeball.cpp
+  src/games/bigfish.cpp
+  src/games/bossfight.cpp
+  src/games/caveflyer.cpp
+  src/games/climber.cpp
+  src/games/coinrun_old.cpp
+  src/games/coinrun.cpp
+  src/games/coinrun_aisc.cpp
+  src/games/coinrun_mod_wall.cpp
+  src/games/fruitbot.cpp
+  src/games/heist.cpp
+  src/games/heist_aisc_many_chests.cpp
+  src/games/heist_aisc_many_keys.cpp
+  src/games/jumper.cpp
+  src/games/leaper.cpp
+  src/games/maze.cpp
+  src/games/maze_fixed_size.cpp
+  src/games/maze_aisc.cpp
+  src/games/maze_yellowline.cpp
+  src/games/maze_redline_yellowgem.cpp
+  src/games/maze_yellowstar_redgem.cpp
+  src/games/miner.cpp
+  src/games/ninja.cpp
+  src/games/chaser.cpp
+  src/games/plunder.cpp
+  src/games/starpilot.cpp
+  src/mazegen.cpp
+  src/randgen.cpp
+  src/roomgen.cpp
+  src/resources.cpp
+  src/vecgame.cpp
+  src/vecoptions.cpp
+)
+
+# find libenv.h header
+target_include_directories(env PUBLIC ${LIBENV_DIR})
+
+target_link_libraries(env Qt5::Gui)
diff --git a/procgenAISC/procgen/__init__.py b/procgenAISC/procgen/__init__.py
new file mode 100644
index 0000000..bd1dc3f
--- /dev/null
+++ b/procgenAISC/procgen/__init__.py
@@ -0,0 +1,12 @@
+import os
+
+SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
+version_path = os.path.join(SCRIPT_DIR, "version.txt")
+__version__ = open(version_path).read()
+
+from .env import ProcgenEnv, ProcgenGym3Env
+from .gym_registration import register_environments
+
+register_environments()
+
+__all__ = ["ProcgenEnv", "ProcgenGym3Env"]
diff --git a/procgenAISC/procgen/build.py b/procgenAISC/procgen/build.py
new file mode 100644
index 0000000..ebe1ddd
--- /dev/null
+++ b/procgenAISC/procgen/build.py
@@ -0,0 +1,144 @@
+import threading
+import os
+import contextlib
+import subprocess as sp
+import shutil
+import json
+import sys
+import platform
+import multiprocessing as mp
+
+import gym3
+
+SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
+
+
+global_build_lock = threading.Lock()
+global_builds = set()
+
+
+class RunFailure(Exception):
+    pass
+
+
+@contextlib.contextmanager
+def nullcontext():
+    # this is here for python 3.6 support
+    yield
+
+
+@contextlib.contextmanager
+def chdir(newdir):
+    curdir = os.getcwd()
+    try:
+        os.chdir(newdir)
+        yield
+    finally:
+        os.chdir(curdir)
+
+
+def run(cmd):
+    return sp.run(cmd, stdout=sp.PIPE, stderr=sp.STDOUT, encoding="utf8")
+
+
+def check(proc, verbose):
+    if proc.returncode != 0:
+        print(f"RUN FAILED {proc.args}:\n{proc.stdout}")
+        raise RunFailure("failed to build procgen from source")
+    if verbose:
+        print(f"RUN {proc.args}:\n{proc.stdout}")
+
+
+def _attempt_configure(build_type, package):
+    if "PROCGEN_CMAKE_PREFIX_PATH" in os.environ:
+        cmake_prefix_paths = [os.environ["PROCGEN_CMAKE_PREFIX_PATH"]]
+    else:
+        # guess some common qt cmake paths, it's unclear why cmake can't find qt without this
+        cmake_prefix_paths = ["/usr/local/opt/qt5/lib/cmake"]
+        conda_exe = shutil.which("conda")
+        if conda_exe is not None:
+            conda_info = json.loads(
+                sp.run(["conda", "info", "--json"], stdout=sp.PIPE).stdout
+            )
+            conda_prefix = conda_info["active_prefix"]
+            if conda_prefix is None:
+                conda_prefix = conda_info["conda_prefix"]
+            if platform.system() == "Windows":
+                conda_prefix = os.path.join(conda_prefix, "library")
+            conda_cmake_path = os.path.join(conda_prefix, "lib", "cmake", "Qt5")
+            # prepend this qt since it's likely to be loaded already by the python process
+            cmake_prefix_paths.insert(0, conda_cmake_path)
+
+    generator = "Unix Makefiles"
+    if platform.system() == "Windows":
+        generator = "Visual Studio 15 2017 Win64"
+    configure_cmd = [
+        "cmake",
+        "-G",
+        generator,
+        "-DCMAKE_PREFIX_PATH=" + ";".join(cmake_prefix_paths),
+        f"-DLIBENV_DIR={gym3.libenv.get_header_dir()}",
+        "../..",
+    ]
+    if package:
+        configure_cmd.append("-DPROCGEN_PACKAGE=ON")
+    if platform.system() != "Windows":
+        # this is not used on windows, the option needs to be passed to cmake --build instead
+        configure_cmd.append(f"-DCMAKE_BUILD_TYPE={build_type}")
+
+    check(run(configure_cmd), verbose=package)
+
+
+def build(package=False, debug=False):
+    """
+    Build the requested environment in a process-safe manner and only once per process.
+    """
+    build_dir = os.path.join(SCRIPT_DIR, ".build")
+    os.makedirs(build_dir, exist_ok=True)
+
+    build_type = "relwithdebinfo"
+    if debug:
+        build_type = "debug"
+
+    with chdir(build_dir), global_build_lock:
+        # check if we have built yet in this process
+        if build_type not in global_builds:
+            if package:
+                # avoid the filelock dependency when building from setup.py
+                lock_ctx = nullcontext()
+            else:
+                # prevent multiple processes from trying to build at the same time
+                import filelock
+
+                lock_ctx = filelock.FileLock(".build-lock")
+            with lock_ctx:
+                sys.stdout.write("building procgen...")
+                sys.stdout.flush()
+                try:
+                    os.makedirs(build_type, exist_ok=True)
+                    with chdir(build_type):
+                        _attempt_configure(build_type, package)
+                except RunFailure:
+                    # cmake can get into a weird state, so nuke the build directory and retry once
+                    sys.stdout.write("retrying configure due to failure...")
+                    sys.stdout.flush()
+                    shutil.rmtree(build_type)
+                    os.makedirs(build_type, exist_ok=True)
+                    with chdir(build_type):
+                        _attempt_configure(build_type, package)
+
+                if "MAKEFLAGS" not in os.environ:
+                    os.environ["MAKEFLAGS"] = f"-j{mp.cpu_count()}"
+
+                with chdir(build_type):
+                    build_cmd = ["cmake", "--build", ".", "--config", build_type]
+                    check(run(build_cmd), verbose=package)
+                print("done")
+
+            global_builds.add(build_type)
+
+    lib_dir = os.path.join(build_dir, build_type)
+    if platform.system() == "Windows":
+        # the built library is in a different location on windows
+        lib_dir = os.path.join(lib_dir, build_type)
+    return lib_dir
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set1_background.png b/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set1_background.png
new file mode 100644
index 0000000..32cd3c2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set1_background.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set1_hills.png b/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set1_hills.png
new file mode 100644
index 0000000..9439bc1
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set1_hills.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set1_tiles.png b/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set1_tiles.png
new file mode 100644
index 0000000..eb18979
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set1_tiles.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set2_background.png b/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set2_background.png
new file mode 100644
index 0000000..2dba815
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set2_background.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set2_hills.png b/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set2_hills.png
new file mode 100644
index 0000000..9f1277a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set2_hills.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set2_tiles.png b/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set2_tiles.png
new file mode 100644
index 0000000..fd80dd1
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set2_tiles.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set3_background.png b/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set3_background.png
new file mode 100644
index 0000000..77e9517
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set3_background.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set3_hills.png b/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set3_hills.png
new file mode 100644
index 0000000..482e7d4
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set3_hills.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set3_tiles.png b/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set3_tiles.png
new file mode 100644
index 0000000..406ee71
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set3_tiles.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set4_background.png b/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set4_background.png
new file mode 100644
index 0000000..761701d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set4_background.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set4_hills.png b/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set4_hills.png
new file mode 100644
index 0000000..1531fef
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set4_hills.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set4_tiles.png b/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set4_tiles.png
new file mode 100644
index 0000000..e258098
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Backgrounds/set4_tiles.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFloating_1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFloating_1.png
new file mode 100644
index 0000000..2682305
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFloating_1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFloating_2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFloating_2.png
new file mode 100644
index 0000000..95c1790
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFloating_2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFloating_3.png b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFloating_3.png
new file mode 100644
index 0000000..ef2e9d2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFloating_3.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFloating_4.png b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFloating_4.png
new file mode 100644
index 0000000..59ea433
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFloating_4.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFlyingAlt_1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFlyingAlt_1.png
new file mode 100644
index 0000000..c315b68
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFlyingAlt_1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFlyingAlt_2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFlyingAlt_2.png
new file mode 100644
index 0000000..e582c0e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFlyingAlt_2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFlyingAlt_3.png b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFlyingAlt_3.png
new file mode 100644
index 0000000..a4cc110
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFlyingAlt_3.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFlyingAlt_4.png b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFlyingAlt_4.png
new file mode 100644
index 0000000..772d4ef
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFlyingAlt_4.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFlying_1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFlying_1.png
new file mode 100644
index 0000000..5ce6cbf
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFlying_1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFlying_2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFlying_2.png
new file mode 100644
index 0000000..9fbfa5d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFlying_2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFlying_3.png b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFlying_3.png
new file mode 100644
index 0000000..1253061
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFlying_3.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFlying_4.png b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFlying_4.png
new file mode 100644
index 0000000..9f1c941
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyFlying_4.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemySpikey_1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemySpikey_1.png
new file mode 100644
index 0000000..e9b937d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemySpikey_1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemySpikey_2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemySpikey_2.png
new file mode 100644
index 0000000..a9e1301
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemySpikey_2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemySpikey_3.png b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemySpikey_3.png
new file mode 100644
index 0000000..7c8d5fd
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemySpikey_3.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemySpikey_4.png b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemySpikey_4.png
new file mode 100644
index 0000000..9640a6b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemySpikey_4.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemySwimming_1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemySwimming_1.png
new file mode 100644
index 0000000..9b5ef24
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemySwimming_1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemySwimming_2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemySwimming_2.png
new file mode 100644
index 0000000..429cd8e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemySwimming_2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemySwimming_3.png b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemySwimming_3.png
new file mode 100644
index 0000000..9568f8b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemySwimming_3.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemySwimming_4.png b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemySwimming_4.png
new file mode 100644
index 0000000..12831f6
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemySwimming_4.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyWalking_1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyWalking_1.png
new file mode 100644
index 0000000..f7fa516
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyWalking_1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyWalking_2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyWalking_2.png
new file mode 100644
index 0000000..047d503
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyWalking_2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyWalking_3.png b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyWalking_3.png
new file mode 100644
index 0000000..0991893
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyWalking_3.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyWalking_4.png b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyWalking_4.png
new file mode 100644
index 0000000..ae54731
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Enemies/enemyWalking_4.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/ .png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/ .png
new file mode 100644
index 0000000..2577dba
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/ .png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/!.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/!.png
new file mode 100644
index 0000000..35f6861
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/!.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/#.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/#.png
new file mode 100644
index 0000000..2ca053c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/#.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/$.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/$.png
new file mode 100644
index 0000000..af8d7ec
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/$.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/%.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/%.png
new file mode 100644
index 0000000..3d7b125
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/%.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/&.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/&.png
new file mode 100644
index 0000000..596b858
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/&.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/1.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/1.png
new file mode 100644
index 0000000..bf7e45e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/2.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/2.png
new file mode 100644
index 0000000..63f164a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/=.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/=.png
new file mode 100644
index 0000000..8004a2c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/=.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/L.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/L.png
new file mode 100644
index 0000000..2ff091b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/L.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/S.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/S.png
new file mode 100644
index 0000000..d0f0a45
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/S.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/^.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/^.png
new file mode 100644
index 0000000..facff7e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/^.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/a.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/a.png
new file mode 100644
index 0000000..05a0785
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/a.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/b.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/b.png
new file mode 100644
index 0000000..79237db
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/b.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/default.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/default.png
new file mode 100644
index 0000000..edba842
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Blue/default.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/ .png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/ .png
new file mode 100644
index 0000000..181ed1d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/ .png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/!.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/!.png
new file mode 100644
index 0000000..7545231
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/!.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/#.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/#.png
new file mode 100644
index 0000000..2ca053c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/#.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/$.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/$.png
new file mode 100644
index 0000000..af8d7ec
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/$.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/%.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/%.png
new file mode 100644
index 0000000..3d7b125
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/%.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/&.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/&.png
new file mode 100644
index 0000000..596b858
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/&.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/1.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/1.png
new file mode 100644
index 0000000..2577dba
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/2.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/2.png
new file mode 100644
index 0000000..17d616b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/=.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/=.png
new file mode 100644
index 0000000..1159f1a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/=.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/L.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/L.png
new file mode 100644
index 0000000..b5573fc
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/L.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/S.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/S.png
new file mode 100644
index 0000000..ee0fcf9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/S.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/^.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/^.png
new file mode 100644
index 0000000..b2d7cc2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/^.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/a.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/a.png
new file mode 100644
index 0000000..3dcc2d4
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/a.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/b.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/b.png
new file mode 100644
index 0000000..5c93b9e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/b.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/default.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/default.png
new file mode 100644
index 0000000..a54bf38
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Brown/default.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/ .png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/ .png
new file mode 100644
index 0000000..963fd1e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/ .png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/!.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/!.png
new file mode 100644
index 0000000..22bf34b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/!.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/#.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/#.png
new file mode 100644
index 0000000..2ca053c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/#.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/$.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/$.png
new file mode 100644
index 0000000..af8d7ec
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/$.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/%.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/%.png
new file mode 100644
index 0000000..3d7b125
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/%.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/&.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/&.png
new file mode 100644
index 0000000..596b858
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/&.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/1.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/1.png
new file mode 100644
index 0000000..0fb3ec3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/2.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/2.png
new file mode 100644
index 0000000..618a9a2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/=.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/=.png
new file mode 100644
index 0000000..c9025a0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/=.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/L.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/L.png
new file mode 100644
index 0000000..33d8ea5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/L.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/S.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/S.png
new file mode 100644
index 0000000..f455f71
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/S.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/^.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/^.png
new file mode 100644
index 0000000..3564763
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/^.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/a.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/a.png
new file mode 100644
index 0000000..e64b158
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/a.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/b.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/b.png
new file mode 100644
index 0000000..294ccb2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/b.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/default.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/default.png
new file mode 100644
index 0000000..5cab207
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Green/default.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/ .png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/ .png
new file mode 100644
index 0000000..0fb3ec3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/ .png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/!.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/!.png
new file mode 100644
index 0000000..22bf34b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/!.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/#.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/#.png
new file mode 100644
index 0000000..2ca053c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/#.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/$.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/$.png
new file mode 100644
index 0000000..af8d7ec
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/$.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/%.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/%.png
new file mode 100644
index 0000000..3d7b125
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/%.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/&.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/&.png
new file mode 100644
index 0000000..596b858
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/&.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/1.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/1.png
new file mode 100644
index 0000000..e132128
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/2.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/2.png
new file mode 100644
index 0000000..6afac57
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/=.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/=.png
new file mode 100644
index 0000000..100545f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/=.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/L.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/L.png
new file mode 100644
index 0000000..0b558a7
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/L.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/S.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/S.png
new file mode 100644
index 0000000..a79e6c7
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/S.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/^.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/^.png
new file mode 100644
index 0000000..a5be1b9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/^.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/a.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/a.png
new file mode 100644
index 0000000..ca5eb41
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/a.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/b.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/b.png
new file mode 100644
index 0000000..62f8dd0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/b.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/default.png b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/default.png
new file mode 100644
index 0000000..c6b6c86
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/GroundThemes/Yellow/default.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Items/blueCrystal.png b/procgenAISC/procgen/data/assets/kenney-abstract/Items/blueCrystal.png
new file mode 100644
index 0000000..2577dba
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Items/blueCrystal.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Items/blueGem.png b/procgenAISC/procgen/data/assets/kenney-abstract/Items/blueGem.png
new file mode 100644
index 0000000..f221e8c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Items/blueGem.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Items/blueJewel.png b/procgenAISC/procgen/data/assets/kenney-abstract/Items/blueJewel.png
new file mode 100644
index 0000000..0fb3ec3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Items/blueJewel.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Items/discGreen.png b/procgenAISC/procgen/data/assets/kenney-abstract/Items/discGreen.png
new file mode 100644
index 0000000..63f164a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Items/discGreen.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Items/discRed.png b/procgenAISC/procgen/data/assets/kenney-abstract/Items/discRed.png
new file mode 100644
index 0000000..12de5c2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Items/discRed.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Items/greenCrystal.png b/procgenAISC/procgen/data/assets/kenney-abstract/Items/greenCrystal.png
new file mode 100644
index 0000000..a819f86
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Items/greenCrystal.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Items/greenGem.png b/procgenAISC/procgen/data/assets/kenney-abstract/Items/greenGem.png
new file mode 100644
index 0000000..17d616b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Items/greenGem.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Items/greenJewel.png b/procgenAISC/procgen/data/assets/kenney-abstract/Items/greenJewel.png
new file mode 100644
index 0000000..11746ed
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Items/greenJewel.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Items/keyGreen.png b/procgenAISC/procgen/data/assets/kenney-abstract/Items/keyGreen.png
new file mode 100644
index 0000000..bf7e45e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Items/keyGreen.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Items/keyRed.png b/procgenAISC/procgen/data/assets/kenney-abstract/Items/keyRed.png
new file mode 100644
index 0000000..618a9a2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Items/keyRed.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Items/outlineCrystal.png b/procgenAISC/procgen/data/assets/kenney-abstract/Items/outlineCrystal.png
new file mode 100644
index 0000000..9547580
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Items/outlineCrystal.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Items/outlineDisc.png b/procgenAISC/procgen/data/assets/kenney-abstract/Items/outlineDisc.png
new file mode 100644
index 0000000..1614aab
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Items/outlineDisc.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Items/outlineDisc_alt.png b/procgenAISC/procgen/data/assets/kenney-abstract/Items/outlineDisc_alt.png
new file mode 100644
index 0000000..03882d7
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Items/outlineDisc_alt.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Items/outlineGem.png b/procgenAISC/procgen/data/assets/kenney-abstract/Items/outlineGem.png
new file mode 100644
index 0000000..1157f67
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Items/outlineGem.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Items/outlineJewel.png b/procgenAISC/procgen/data/assets/kenney-abstract/Items/outlineJewel.png
new file mode 100644
index 0000000..5519ffd
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Items/outlineJewel.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Items/outlineKey.png b/procgenAISC/procgen/data/assets/kenney-abstract/Items/outlineKey.png
new file mode 100644
index 0000000..c70a72b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Items/outlineKey.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Items/outlinePuzzle.png b/procgenAISC/procgen/data/assets/kenney-abstract/Items/outlinePuzzle.png
new file mode 100644
index 0000000..a50a03c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Items/outlinePuzzle.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Items/puzzleGreen.png b/procgenAISC/procgen/data/assets/kenney-abstract/Items/puzzleGreen.png
new file mode 100644
index 0000000..e132128
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Items/puzzleGreen.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Items/puzzleRed.png b/procgenAISC/procgen/data/assets/kenney-abstract/Items/puzzleRed.png
new file mode 100644
index 0000000..6df7fff
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Items/puzzleRed.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Items/redCrystal.png b/procgenAISC/procgen/data/assets/kenney-abstract/Items/redCrystal.png
new file mode 100644
index 0000000..47b0db3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Items/redCrystal.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Items/redGem.png b/procgenAISC/procgen/data/assets/kenney-abstract/Items/redGem.png
new file mode 100644
index 0000000..905de6c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Items/redGem.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Items/redJewel.png b/procgenAISC/procgen/data/assets/kenney-abstract/Items/redJewel.png
new file mode 100644
index 0000000..6afac57
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Items/redJewel.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Items/yellowCrystal.png b/procgenAISC/procgen/data/assets/kenney-abstract/Items/yellowCrystal.png
new file mode 100644
index 0000000..bee03f0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Items/yellowCrystal.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Items/yellowGem.png b/procgenAISC/procgen/data/assets/kenney-abstract/Items/yellowGem.png
new file mode 100644
index 0000000..08552de
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Items/yellowGem.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Items/yellowJewel.png b/procgenAISC/procgen/data/assets/kenney-abstract/Items/yellowJewel.png
new file mode 100644
index 0000000..963fd1e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Items/yellowJewel.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockBrown.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockBrown.png
new file mode 100644
index 0000000..2ca053c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockBrown.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockBrown_broken.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockBrown_broken.png
new file mode 100644
index 0000000..4a63bef
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockBrown_broken.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockGreen.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockGreen.png
new file mode 100644
index 0000000..af8d7ec
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockGreen.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockGreen_key.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockGreen_key.png
new file mode 100644
index 0000000..ce7a888
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockGreen_key.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockGreen_lock.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockGreen_lock.png
new file mode 100644
index 0000000..5fc60ff
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockGreen_lock.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockGreen_puzzle.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockGreen_puzzle.png
new file mode 100644
index 0000000..beca7a2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockGreen_puzzle.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockGrey.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockGrey.png
new file mode 100644
index 0000000..596b858
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockGrey.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockGrey_broken.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockGrey_broken.png
new file mode 100644
index 0000000..4182096
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockGrey_broken.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockRed.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockRed.png
new file mode 100644
index 0000000..3d7b125
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockRed.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockRed_key.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockRed_key.png
new file mode 100644
index 0000000..ba18910
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockRed_key.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockRed_lock.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockRed_lock.png
new file mode 100644
index 0000000..aca29d6
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockRed_lock.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockRed_puzzle.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockRed_puzzle.png
new file mode 100644
index 0000000..92b21f2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/blockRed_puzzle.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/buttonFloor.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/buttonFloor.png
new file mode 100644
index 0000000..ae33ce3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/buttonFloor.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/buttonFloor_pressed.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/buttonFloor_pressed.png
new file mode 100644
index 0000000..368918c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/buttonFloor_pressed.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/buttonGreen.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/buttonGreen.png
new file mode 100644
index 0000000..7e4419b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/buttonGreen.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/buttonGreen_pressed.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/buttonGreen_pressed.png
new file mode 100644
index 0000000..59d03e3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/buttonGreen_pressed.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/buttonRed.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/buttonRed.png
new file mode 100644
index 0000000..385af6d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/buttonRed.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/buttonRed_pressed.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/buttonRed_pressed.png
new file mode 100644
index 0000000..8426cc1
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/buttonRed_pressed.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/doorGreen.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/doorGreen.png
new file mode 100644
index 0000000..1c7d21f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/doorGreen.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/doorGreen_lock.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/doorGreen_lock.png
new file mode 100644
index 0000000..0f19aa3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/doorGreen_lock.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/doorGreen_top.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/doorGreen_top.png
new file mode 100644
index 0000000..e171ffe
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/doorGreen_top.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/doorOpen.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/doorOpen.png
new file mode 100644
index 0000000..502dc33
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/doorOpen.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/doorOpen_top.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/doorOpen_top.png
new file mode 100644
index 0000000..11da13b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/doorOpen_top.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/doorRed.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/doorRed.png
new file mode 100644
index 0000000..2975e1b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/doorRed.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/doorRed_lock.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/doorRed_lock.png
new file mode 100644
index 0000000..3fae86c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/doorRed_lock.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/doorRed_top.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/doorRed_top.png
new file mode 100644
index 0000000..98aa9c6
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/doorRed_top.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/fence.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fence.png
new file mode 100644
index 0000000..7628379
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fence.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/fenceBroken.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fenceBroken.png
new file mode 100644
index 0000000..c6ef4ca
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fenceBroken.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/fenceLeft.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fenceLeft.png
new file mode 100644
index 0000000..e3c23d6
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fenceLeft.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/fenceMid.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fenceMid.png
new file mode 100644
index 0000000..501679c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fenceMid.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/fenceOpen.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fenceOpen.png
new file mode 100644
index 0000000..5134a75
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fenceOpen.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/fenceRight.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fenceRight.png
new file mode 100644
index 0000000..e3438a3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fenceRight.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/flagGreen_down.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/flagGreen_down.png
new file mode 100644
index 0000000..37ef914
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/flagGreen_down.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/flagGreen_up.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/flagGreen_up.png
new file mode 100644
index 0000000..3a3ff12
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/flagGreen_up.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/flagRed_down.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/flagRed_down.png
new file mode 100644
index 0000000..94985e3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/flagRed_down.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/flagRed_up.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/flagRed_up.png
new file mode 100644
index 0000000..83164d2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/flagRed_up.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/fluidBlue.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fluidBlue.png
new file mode 100644
index 0000000..0b558a7
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fluidBlue.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/fluidBlue_top.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fluidBlue_top.png
new file mode 100644
index 0000000..a5be1b9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fluidBlue_top.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/fluidBrown.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fluidBrown.png
new file mode 100644
index 0000000..33d8ea5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fluidBrown.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/fluidBrown_top.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fluidBrown_top.png
new file mode 100644
index 0000000..3564763
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fluidBrown_top.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/fluidGreen.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fluidGreen.png
new file mode 100644
index 0000000..2ff091b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fluidGreen.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/fluidGreen_top.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fluidGreen_top.png
new file mode 100644
index 0000000..facff7e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fluidGreen_top.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/fluidRed.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fluidRed.png
new file mode 100644
index 0000000..b5573fc
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fluidRed.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/fluidRed_top.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fluidRed_top.png
new file mode 100644
index 0000000..b2d7cc2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/fluidRed_top.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/ladderNarrow_mid.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/ladderNarrow_mid.png
new file mode 100644
index 0000000..c9025a0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/ladderNarrow_mid.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/ladderNarrow_top.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/ladderNarrow_top.png
new file mode 100644
index 0000000..432233c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/ladderNarrow_top.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/ladderWide_mid.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/ladderWide_mid.png
new file mode 100644
index 0000000..100545f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/ladderWide_mid.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/ladderWide_top.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/ladderWide_top.png
new file mode 100644
index 0000000..849311e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/ladderWide_top.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockGreen.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockGreen.png
new file mode 100644
index 0000000..6cf0fe5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockGreen.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockGreenBottom.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockGreenBottom.png
new file mode 100644
index 0000000..c3d57b9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockGreenBottom.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockGreenLeft.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockGreenLeft.png
new file mode 100644
index 0000000..f8ac54d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockGreenLeft.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockGreenLock.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockGreenLock.png
new file mode 100644
index 0000000..d01d6c1
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockGreenLock.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockGreenMid.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockGreenMid.png
new file mode 100644
index 0000000..32ab06b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockGreenMid.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockGreenRight.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockGreenRight.png
new file mode 100644
index 0000000..3302b19
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockGreenRight.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockGreenTop.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockGreenTop.png
new file mode 100644
index 0000000..a2fd376
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockGreenTop.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockRed.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockRed.png
new file mode 100644
index 0000000..5a24593
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockRed.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockRedBottom.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockRedBottom.png
new file mode 100644
index 0000000..1dd312a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockRedBottom.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockRedLeft.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockRedLeft.png
new file mode 100644
index 0000000..8fc97b9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockRedLeft.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockRedLock.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockRedLock.png
new file mode 100644
index 0000000..61d3631
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockRedLock.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockRedMid.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockRedMid.png
new file mode 100644
index 0000000..b5573fc
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockRedMid.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockRedRight.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockRedRight.png
new file mode 100644
index 0000000..c6d99dc
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockRedRight.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockRedTop.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockRedTop.png
new file mode 100644
index 0000000..570e7d0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/lockRedTop.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantBlue_1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantBlue_1.png
new file mode 100644
index 0000000..7545231
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantBlue_1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantBlue_2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantBlue_2.png
new file mode 100644
index 0000000..07555d3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantBlue_2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantBlue_3.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantBlue_3.png
new file mode 100644
index 0000000..e482ea9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantBlue_3.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantBlue_4.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantBlue_4.png
new file mode 100644
index 0000000..02fd7bc
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantBlue_4.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantBlue_5.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantBlue_5.png
new file mode 100644
index 0000000..053b1e0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantBlue_5.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantBlue_6.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantBlue_6.png
new file mode 100644
index 0000000..6e83e91
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantBlue_6.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantBottom_1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantBottom_1.png
new file mode 100644
index 0000000..4f91fbe
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantBottom_1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantBottom_2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantBottom_2.png
new file mode 100644
index 0000000..dfe1861
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantBottom_2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantDark_1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantDark_1.png
new file mode 100644
index 0000000..3401fe6
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantDark_1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantDark_2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantDark_2.png
new file mode 100644
index 0000000..145358b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantDark_2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantDark_3.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantDark_3.png
new file mode 100644
index 0000000..489531d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantDark_3.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantDark_4.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantDark_4.png
new file mode 100644
index 0000000..13ea51f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantDark_4.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantDark_5.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantDark_5.png
new file mode 100644
index 0000000..8a6cef4
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantDark_5.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantDark_6.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantDark_6.png
new file mode 100644
index 0000000..edf712a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantDark_6.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantGreen_1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantGreen_1.png
new file mode 100644
index 0000000..bd4cd4c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantGreen_1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantGreen_2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantGreen_2.png
new file mode 100644
index 0000000..6546668
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantGreen_2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantGreen_3.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantGreen_3.png
new file mode 100644
index 0000000..10cc518
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantGreen_3.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantGreen_4.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantGreen_4.png
new file mode 100644
index 0000000..d7eea06
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantGreen_4.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantGreen_5.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantGreen_5.png
new file mode 100644
index 0000000..cb144e2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantGreen_5.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantGreen_6.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantGreen_6.png
new file mode 100644
index 0000000..181ed1d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantGreen_6.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantLeaves_1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantLeaves_1.png
new file mode 100644
index 0000000..766ea12
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantLeaves_1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantLeaves_3.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantLeaves_3.png
new file mode 100644
index 0000000..1159f1a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantLeaves_3.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantRed_1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantRed_1.png
new file mode 100644
index 0000000..1f70834
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantRed_1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantRed_2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantRed_2.png
new file mode 100644
index 0000000..cca80b7
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantRed_2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantRed_3.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantRed_3.png
new file mode 100644
index 0000000..ed2e8c8
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantRed_3.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantRed_4.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantRed_4.png
new file mode 100644
index 0000000..7fcfe83
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantRed_4.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantRed_5.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantRed_5.png
new file mode 100644
index 0000000..d789779
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantRed_5.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantRed_6.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantRed_6.png
new file mode 100644
index 0000000..db1474d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantRed_6.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantStem_Tleft.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantStem_Tleft.png
new file mode 100644
index 0000000..47ad963
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantStem_Tleft.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantStem_Tright.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantStem_Tright.png
new file mode 100644
index 0000000..03700ea
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantStem_Tright.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantStem_cornerLeft.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantStem_cornerLeft.png
new file mode 100644
index 0000000..2183880
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantStem_cornerLeft.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantStem_cornerRight.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantStem_cornerRight.png
new file mode 100644
index 0000000..ddd037b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantStem_cornerRight.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantStem_cross.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantStem_cross.png
new file mode 100644
index 0000000..24b7376
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantStem_cross.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantStem_horizontal.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantStem_horizontal.png
new file mode 100644
index 0000000..652120e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantStem_horizontal.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantStem_vertical.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantStem_vertical.png
new file mode 100644
index 0000000..1745552
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantStem_vertical.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantThorns_horizontal.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantThorns_horizontal.png
new file mode 100644
index 0000000..05bbe61
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantThorns_horizontal.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantThorns_vertical.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantThorns_vertical.png
new file mode 100644
index 0000000..8004a2c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantThorns_vertical.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantTop_blue.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantTop_blue.png
new file mode 100644
index 0000000..32945d6
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantTop_blue.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantTop_leaves.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantTop_leaves.png
new file mode 100644
index 0000000..6b5759d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantTop_leaves.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantTop_red.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantTop_red.png
new file mode 100644
index 0000000..20735d5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantTop_red.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantTop_yellow.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantTop_yellow.png
new file mode 100644
index 0000000..14e21fc
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/plantTop_yellow.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow.png
new file mode 100644
index 0000000..f8d9902
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow_BL.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow_BL.png
new file mode 100644
index 0000000..6e3af39
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow_BL.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow_BR.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow_BR.png
new file mode 100644
index 0000000..6964c9b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow_BR.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow_TL.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow_TL.png
new file mode 100644
index 0000000..765dfce
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow_TL.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow_TR.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow_TR.png
new file mode 100644
index 0000000..cca081d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow_TR.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow_down.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow_down.png
new file mode 100644
index 0000000..345feaa
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow_down.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow_left.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow_left.png
new file mode 100644
index 0000000..c9fe6d7
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow_right.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow_right.png
new file mode 100644
index 0000000..a9a1aa6
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow_up.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow_up.png
new file mode 100644
index 0000000..7de6d5e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/signArrow_up.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/signLarge.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/signLarge.png
new file mode 100644
index 0000000..2e9d743
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/signLarge.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/signSmall.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/signSmall.png
new file mode 100644
index 0000000..1ae761a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/signSmall.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/signpost.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/signpost.png
new file mode 100644
index 0000000..fe1df6a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/signpost.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/spikesHigh.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/spikesHigh.png
new file mode 100644
index 0000000..22bf34b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/spikesHigh.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/spikesLow.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/spikesLow.png
new file mode 100644
index 0000000..35f6861
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/spikesLow.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchGreen_left.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchGreen_left.png
new file mode 100644
index 0000000..365497d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchGreen_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchGreen_mid.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchGreen_mid.png
new file mode 100644
index 0000000..7136816
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchGreen_mid.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchGreen_off.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchGreen_off.png
new file mode 100644
index 0000000..047c44a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchGreen_off.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchGreen_on.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchGreen_on.png
new file mode 100644
index 0000000..db4ea65
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchGreen_on.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchGreen_right.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchGreen_right.png
new file mode 100644
index 0000000..f7656d8
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchGreen_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchRed_left.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchRed_left.png
new file mode 100644
index 0000000..29f595f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchRed_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchRed_mid.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchRed_mid.png
new file mode 100644
index 0000000..fb82f8c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchRed_mid.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchRed_off.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchRed_off.png
new file mode 100644
index 0000000..3bfb813
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchRed_off.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchRed_on.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchRed_on.png
new file mode 100644
index 0000000..06fc8bd
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchRed_on.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchRed_right.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchRed_right.png
new file mode 100644
index 0000000..ba6d92c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/switchRed_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/vine.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/vine.png
new file mode 100644
index 0000000..ed5cfd2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/vine.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/vine_bottom.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/vine_bottom.png
new file mode 100644
index 0000000..7c76fed
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/vine_bottom.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Other/vine_bottomAlt.png b/procgenAISC/procgen/data/assets/kenney-abstract/Other/vine_bottomAlt.png
new file mode 100644
index 0000000..e4915a1
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Other/vine_bottomAlt.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_dead.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_dead.png
new file mode 100644
index 0000000..5bd8dbb
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_dead.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_duck.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_duck.png
new file mode 100644
index 0000000..a662412
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_duck.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_fall.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_fall.png
new file mode 100644
index 0000000..a5852ab
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_fall.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_hit.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_hit.png
new file mode 100644
index 0000000..991fa0a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_hit.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_roll.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_roll.png
new file mode 100644
index 0000000..30b7c51
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_roll.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_stand.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_stand.png
new file mode 100644
index 0000000..f2c165d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_stand.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_swim1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_swim1.png
new file mode 100644
index 0000000..79568cb
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_swim1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_swim2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_swim2.png
new file mode 100644
index 0000000..94e7eb5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_swim2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_switch1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_switch1.png
new file mode 100644
index 0000000..0ff8785
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_switch1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_switch2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_switch2.png
new file mode 100644
index 0000000..f972724
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_switch2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_up1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_up1.png
new file mode 100644
index 0000000..21e9055
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_up1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_up2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_up2.png
new file mode 100644
index 0000000..ce69e27
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_up2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_up3.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_up3.png
new file mode 100644
index 0000000..598758a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_up3.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_walk1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_walk1.png
new file mode 100644
index 0000000..382dd9b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_walk1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_walk2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_walk2.png
new file mode 100644
index 0000000..a76bd35
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_walk2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_walk3.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_walk3.png
new file mode 100644
index 0000000..52dad24
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_walk3.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_walk4.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_walk4.png
new file mode 100644
index 0000000..1785073
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_walk4.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_walk5.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_walk5.png
new file mode 100644
index 0000000..c776cad
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Blue/playerBlue_walk5.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_dead.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_dead.png
new file mode 100644
index 0000000..21b30b0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_dead.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_duck.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_duck.png
new file mode 100644
index 0000000..fec216c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_duck.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_fall.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_fall.png
new file mode 100644
index 0000000..b30dff8
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_fall.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_hit.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_hit.png
new file mode 100644
index 0000000..dca7692
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_hit.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_roll.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_roll.png
new file mode 100644
index 0000000..306345f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_roll.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_stand.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_stand.png
new file mode 100644
index 0000000..bc96b78
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_stand.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_swim1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_swim1.png
new file mode 100644
index 0000000..2f2becd
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_swim1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_swim2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_swim2.png
new file mode 100644
index 0000000..04cfbba
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_swim2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_switch1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_switch1.png
new file mode 100644
index 0000000..53d1619
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_switch1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_switch2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_switch2.png
new file mode 100644
index 0000000..06c5665
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_switch2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_up1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_up1.png
new file mode 100644
index 0000000..ee637e2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_up1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_up2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_up2.png
new file mode 100644
index 0000000..53483a8
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_up2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_up3.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_up3.png
new file mode 100644
index 0000000..2128de5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_up3.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_walk1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_walk1.png
new file mode 100644
index 0000000..86abb82
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_walk1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_walk2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_walk2.png
new file mode 100644
index 0000000..15b0008
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_walk2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_walk3.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_walk3.png
new file mode 100644
index 0000000..12fd780
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_walk3.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_walk4.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_walk4.png
new file mode 100644
index 0000000..ba3e976
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_walk4.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_walk5.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_walk5.png
new file mode 100644
index 0000000..fa00ebd
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Green/playerGreen_walk5.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_dead.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_dead.png
new file mode 100644
index 0000000..79315fa
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_dead.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_duck.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_duck.png
new file mode 100644
index 0000000..087e89b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_duck.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_fall.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_fall.png
new file mode 100644
index 0000000..1ed2064
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_fall.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_hit.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_hit.png
new file mode 100644
index 0000000..34e07dd
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_hit.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_roll.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_roll.png
new file mode 100644
index 0000000..b803732
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_roll.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_stand.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_stand.png
new file mode 100644
index 0000000..d454a77
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_stand.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_swim1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_swim1.png
new file mode 100644
index 0000000..5f71ce8
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_swim1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_swim2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_swim2.png
new file mode 100644
index 0000000..9b0c5eb
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_swim2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_switch1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_switch1.png
new file mode 100644
index 0000000..fc2ab93
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_switch1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_switch2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_switch2.png
new file mode 100644
index 0000000..5ca9d3c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_switch2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_up1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_up1.png
new file mode 100644
index 0000000..53514aa
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_up1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_up2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_up2.png
new file mode 100644
index 0000000..b3dec17
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_up2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_up3.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_up3.png
new file mode 100644
index 0000000..a4cc7ce
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_up3.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_walk1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_walk1.png
new file mode 100644
index 0000000..312e21b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_walk1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_walk2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_walk2.png
new file mode 100644
index 0000000..36e34ed
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_walk2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_walk3.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_walk3.png
new file mode 100644
index 0000000..16022b5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_walk3.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_walk4.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_walk4.png
new file mode 100644
index 0000000..bf81c0a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_walk4.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_walk5.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_walk5.png
new file mode 100644
index 0000000..4883fef
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Grey/playerGrey_walk5.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_dead.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_dead.png
new file mode 100644
index 0000000..5db34af
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_dead.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_duck.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_duck.png
new file mode 100644
index 0000000..5b1b19f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_duck.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_fall.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_fall.png
new file mode 100644
index 0000000..52829ab
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_fall.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_hit.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_hit.png
new file mode 100644
index 0000000..776bfe4
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_hit.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_roll.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_roll.png
new file mode 100644
index 0000000..76ae76a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_roll.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_stand.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_stand.png
new file mode 100644
index 0000000..5574e40
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_stand.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_swim1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_swim1.png
new file mode 100644
index 0000000..448e944
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_swim1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_swim2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_swim2.png
new file mode 100644
index 0000000..1065f7c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_swim2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_switch1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_switch1.png
new file mode 100644
index 0000000..ebcebe9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_switch1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_switch2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_switch2.png
new file mode 100644
index 0000000..d86e7b4
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_switch2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_up1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_up1.png
new file mode 100644
index 0000000..423728d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_up1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_up2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_up2.png
new file mode 100644
index 0000000..06b7673
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_up2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_up3.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_up3.png
new file mode 100644
index 0000000..f118f54
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_up3.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_walk1.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_walk1.png
new file mode 100644
index 0000000..dbd219c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_walk1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_walk2.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_walk2.png
new file mode 100644
index 0000000..6df569d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_walk2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_walk3.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_walk3.png
new file mode 100644
index 0000000..b98d070
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_walk3.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_walk4.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_walk4.png
new file mode 100644
index 0000000..fdb127a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_walk4.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_walk5.png b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_walk5.png
new file mode 100644
index 0000000..987a252
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Players/Player Red/playerRed_walk5.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_01.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_01.png
new file mode 100644
index 0000000..2885e74
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_01.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_02.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_02.png
new file mode 100644
index 0000000..dc22a79
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_02.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_03.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_03.png
new file mode 100644
index 0000000..edba842
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_03.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_04.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_04.png
new file mode 100644
index 0000000..05a0785
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_04.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_05.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_05.png
new file mode 100644
index 0000000..d0f0a45
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_05.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_06.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_06.png
new file mode 100644
index 0000000..79237db
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_06.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_07.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_07.png
new file mode 100644
index 0000000..745fa9e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_07.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_08.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_08.png
new file mode 100644
index 0000000..350d05c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_08.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_09.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_09.png
new file mode 100644
index 0000000..f9b33ef
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_09.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_10.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_10.png
new file mode 100644
index 0000000..38c8847
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_10.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_11.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_11.png
new file mode 100644
index 0000000..6fdab3c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_11.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_12.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_12.png
new file mode 100644
index 0000000..a5f9764
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_12.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_13.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_13.png
new file mode 100644
index 0000000..1a1bba8
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_13.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_14.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_14.png
new file mode 100644
index 0000000..215b534
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_14.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_15.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_15.png
new file mode 100644
index 0000000..c628326
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_15.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_16.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_16.png
new file mode 100644
index 0000000..eccae50
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_16.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_17.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_17.png
new file mode 100644
index 0000000..082f985
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_17.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_18.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_18.png
new file mode 100644
index 0000000..0545fb0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_18.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_19.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_19.png
new file mode 100644
index 0000000..0f2410d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_19.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_20.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_20.png
new file mode 100644
index 0000000..7a1565f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_20.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_21.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_21.png
new file mode 100644
index 0000000..fea572e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_21.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_22.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_22.png
new file mode 100644
index 0000000..2b11e8a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_22.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_23.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_23.png
new file mode 100644
index 0000000..62098f9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_23.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_24.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_24.png
new file mode 100644
index 0000000..777180c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_24.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_25.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_25.png
new file mode 100644
index 0000000..42ffad9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_25.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_26.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_26.png
new file mode 100644
index 0000000..07c9124
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_26.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_27.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_27.png
new file mode 100644
index 0000000..480466a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Blue tiles/tileBlue_27.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_01.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_01.png
new file mode 100644
index 0000000..3dcc2d4
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_01.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_02.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_02.png
new file mode 100644
index 0000000..ee0fcf9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_02.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_03.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_03.png
new file mode 100644
index 0000000..5c93b9e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_03.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_04.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_04.png
new file mode 100644
index 0000000..b26d858
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_04.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_05.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_05.png
new file mode 100644
index 0000000..1a0ce4b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_05.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_06.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_06.png
new file mode 100644
index 0000000..b72e919
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_06.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_07.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_07.png
new file mode 100644
index 0000000..c375616
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_07.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_08.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_08.png
new file mode 100644
index 0000000..2d48834
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_08.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_09.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_09.png
new file mode 100644
index 0000000..a54bf38
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_09.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_10.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_10.png
new file mode 100644
index 0000000..7b19d61
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_10.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_11.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_11.png
new file mode 100644
index 0000000..3309b45
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_11.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_12.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_12.png
new file mode 100644
index 0000000..fef9227
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_12.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_13.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_13.png
new file mode 100644
index 0000000..658de55
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_13.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_14.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_14.png
new file mode 100644
index 0000000..9abe40d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_14.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_15.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_15.png
new file mode 100644
index 0000000..cd9c1b2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_15.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_16.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_16.png
new file mode 100644
index 0000000..6587ffa
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_16.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_17.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_17.png
new file mode 100644
index 0000000..b6e9e98
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_17.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_18.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_18.png
new file mode 100644
index 0000000..e9d0d2e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_18.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_19.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_19.png
new file mode 100644
index 0000000..6b75573
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_19.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_20.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_20.png
new file mode 100644
index 0000000..fe0deaa
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_20.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_21.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_21.png
new file mode 100644
index 0000000..cc05d8f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_21.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_22.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_22.png
new file mode 100644
index 0000000..afa8d9a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_22.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_23.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_23.png
new file mode 100644
index 0000000..7ae0f74
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_23.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_24.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_24.png
new file mode 100644
index 0000000..526c693
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_24.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_25.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_25.png
new file mode 100644
index 0000000..ee410f6
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_25.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_26.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_26.png
new file mode 100644
index 0000000..e2fc177
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_26.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_27.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_27.png
new file mode 100644
index 0000000..33d8ea5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Brown tiles/tileBrown_27.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_01.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_01.png
new file mode 100644
index 0000000..f536950
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_01.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_02.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_02.png
new file mode 100644
index 0000000..4a02faf
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_02.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_03.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_03.png
new file mode 100644
index 0000000..f1b121f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_03.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_04.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_04.png
new file mode 100644
index 0000000..e64b158
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_04.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_05.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_05.png
new file mode 100644
index 0000000..f455f71
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_05.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_06.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_06.png
new file mode 100644
index 0000000..294ccb2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_06.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_07.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_07.png
new file mode 100644
index 0000000..487e342
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_07.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_08.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_08.png
new file mode 100644
index 0000000..aa00abf
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_08.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_09.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_09.png
new file mode 100644
index 0000000..03da2ec
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_09.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_10.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_10.png
new file mode 100644
index 0000000..792520d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_10.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_11.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_11.png
new file mode 100644
index 0000000..bd5bb1c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_11.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_12.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_12.png
new file mode 100644
index 0000000..5ee220e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_12.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_13.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_13.png
new file mode 100644
index 0000000..41add60
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_13.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_14.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_14.png
new file mode 100644
index 0000000..2c9cdcd
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_14.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_15.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_15.png
new file mode 100644
index 0000000..a5e5aed
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_15.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_16.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_16.png
new file mode 100644
index 0000000..48444fc
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_16.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_17.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_17.png
new file mode 100644
index 0000000..5cab207
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_17.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_18.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_18.png
new file mode 100644
index 0000000..ed270da
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_18.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_19.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_19.png
new file mode 100644
index 0000000..97cf1d0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_19.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_20.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_20.png
new file mode 100644
index 0000000..dc31909
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_20.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_21.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_21.png
new file mode 100644
index 0000000..3e0f475
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_21.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_22.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_22.png
new file mode 100644
index 0000000..f836ba3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_22.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_23.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_23.png
new file mode 100644
index 0000000..d9524c9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_23.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_24.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_24.png
new file mode 100644
index 0000000..4b392bd
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_24.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_25.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_25.png
new file mode 100644
index 0000000..eecc319
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_25.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_26.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_26.png
new file mode 100644
index 0000000..eccda19
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_26.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_27.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_27.png
new file mode 100644
index 0000000..9ffc4a5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Green tiles/tileGreen_27.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_01.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_01.png
new file mode 100644
index 0000000..cecc76f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_01.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_02.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_02.png
new file mode 100644
index 0000000..451b97b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_02.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_03.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_03.png
new file mode 100644
index 0000000..74783bd
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_03.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_04.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_04.png
new file mode 100644
index 0000000..2ff091b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_04.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_05.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_05.png
new file mode 100644
index 0000000..ca5eb41
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_05.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_06.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_06.png
new file mode 100644
index 0000000..a79e6c7
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_06.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_07.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_07.png
new file mode 100644
index 0000000..62f8dd0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_07.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_08.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_08.png
new file mode 100644
index 0000000..15db385
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_08.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_09.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_09.png
new file mode 100644
index 0000000..c6b6c86
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_09.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_10.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_10.png
new file mode 100644
index 0000000..e58a367
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_10.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_11.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_11.png
new file mode 100644
index 0000000..c647d17
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_11.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_12.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_12.png
new file mode 100644
index 0000000..21401fc
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_12.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_13.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_13.png
new file mode 100644
index 0000000..6e4e34f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_13.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_14.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_14.png
new file mode 100644
index 0000000..56cfd14
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_14.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_15.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_15.png
new file mode 100644
index 0000000..8bafb8a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_15.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_16.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_16.png
new file mode 100644
index 0000000..e81151e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_16.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_17.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_17.png
new file mode 100644
index 0000000..7a51cdd
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_17.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_18.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_18.png
new file mode 100644
index 0000000..f4d1998
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_18.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_19.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_19.png
new file mode 100644
index 0000000..54bdf9b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_19.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_20.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_20.png
new file mode 100644
index 0000000..15e0ee4
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_20.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_21.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_21.png
new file mode 100644
index 0000000..a1a5bb2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_21.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_22.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_22.png
new file mode 100644
index 0000000..b6e7361
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_22.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_23.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_23.png
new file mode 100644
index 0000000..c2874ae
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_23.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_24.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_24.png
new file mode 100644
index 0000000..e7f5613
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_24.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_25.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_25.png
new file mode 100644
index 0000000..7fc5442
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_25.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_26.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_26.png
new file mode 100644
index 0000000..c1b669b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_26.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_27.png b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_27.png
new file mode 100644
index 0000000..e9bfc69
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney-abstract/Tiles/Yellow tiles/tileYellow_27.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Backgrounds/blue_desert.png b/procgenAISC/procgen/data/assets/kenney/Backgrounds/blue_desert.png
new file mode 100644
index 0000000..7e8e078
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Backgrounds/blue_desert.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Backgrounds/blue_grass.png b/procgenAISC/procgen/data/assets/kenney/Backgrounds/blue_grass.png
new file mode 100644
index 0000000..cf470c9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Backgrounds/blue_grass.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Backgrounds/blue_land.png b/procgenAISC/procgen/data/assets/kenney/Backgrounds/blue_land.png
new file mode 100644
index 0000000..5f33d67
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Backgrounds/blue_land.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Backgrounds/blue_shroom.png b/procgenAISC/procgen/data/assets/kenney/Backgrounds/blue_shroom.png
new file mode 100644
index 0000000..932291e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Backgrounds/blue_shroom.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Backgrounds/colored_desert.png b/procgenAISC/procgen/data/assets/kenney/Backgrounds/colored_desert.png
new file mode 100644
index 0000000..af050cd
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Backgrounds/colored_desert.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Backgrounds/colored_grass.png b/procgenAISC/procgen/data/assets/kenney/Backgrounds/colored_grass.png
new file mode 100644
index 0000000..8469d4a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Backgrounds/colored_grass.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Backgrounds/colored_land.png b/procgenAISC/procgen/data/assets/kenney/Backgrounds/colored_land.png
new file mode 100644
index 0000000..a6ffcd3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Backgrounds/colored_land.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Backgrounds/colored_shroom.png b/procgenAISC/procgen/data/assets/kenney/Backgrounds/colored_shroom.png
new file mode 100644
index 0000000..38d1458
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Backgrounds/colored_shroom.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/barnacle.png b/procgenAISC/procgen/data/assets/kenney/Enemies/barnacle.png
new file mode 100644
index 0000000..2c91a44
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/barnacle.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/barnacle_attack.png b/procgenAISC/procgen/data/assets/kenney/Enemies/barnacle_attack.png
new file mode 100644
index 0000000..0f5121f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/barnacle_attack.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/barnacle_dead.png b/procgenAISC/procgen/data/assets/kenney/Enemies/barnacle_dead.png
new file mode 100644
index 0000000..d1ddfec
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/barnacle_dead.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/bee.png b/procgenAISC/procgen/data/assets/kenney/Enemies/bee.png
new file mode 100644
index 0000000..8f2b2d0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/bee.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/bee_dead.png b/procgenAISC/procgen/data/assets/kenney/Enemies/bee_dead.png
new file mode 100644
index 0000000..b726699
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/bee_dead.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/bee_move.png b/procgenAISC/procgen/data/assets/kenney/Enemies/bee_move.png
new file mode 100644
index 0000000..dd0d437
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/bee_move.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/fishBlue.png b/procgenAISC/procgen/data/assets/kenney/Enemies/fishBlue.png
new file mode 100644
index 0000000..9021d4e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/fishBlue.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/fishBlue_dead.png b/procgenAISC/procgen/data/assets/kenney/Enemies/fishBlue_dead.png
new file mode 100644
index 0000000..4a187ac
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/fishBlue_dead.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/fishBlue_fall.png b/procgenAISC/procgen/data/assets/kenney/Enemies/fishBlue_fall.png
new file mode 100644
index 0000000..0070378
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/fishBlue_fall.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/fishGreen.png b/procgenAISC/procgen/data/assets/kenney/Enemies/fishGreen.png
new file mode 100644
index 0000000..0ee8a64
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/fishGreen.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/fishGreen_dead.png b/procgenAISC/procgen/data/assets/kenney/Enemies/fishGreen_dead.png
new file mode 100644
index 0000000..eefd3e9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/fishGreen_dead.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/fishGreen_move.png b/procgenAISC/procgen/data/assets/kenney/Enemies/fishGreen_move.png
new file mode 100644
index 0000000..a3747ec
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/fishGreen_move.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/fishPink.png b/procgenAISC/procgen/data/assets/kenney/Enemies/fishPink.png
new file mode 100644
index 0000000..925cc60
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/fishPink.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/fishPink_dead.png b/procgenAISC/procgen/data/assets/kenney/Enemies/fishPink_dead.png
new file mode 100644
index 0000000..4d7e0b6
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/fishPink_dead.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/fishPink_move.png b/procgenAISC/procgen/data/assets/kenney/Enemies/fishPink_move.png
new file mode 100644
index 0000000..058d0d4
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/fishPink_move.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/fly.png b/procgenAISC/procgen/data/assets/kenney/Enemies/fly.png
new file mode 100644
index 0000000..a733879
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/fly.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/fly_dead.png b/procgenAISC/procgen/data/assets/kenney/Enemies/fly_dead.png
new file mode 100644
index 0000000..9613ff1
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/fly_dead.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/fly_move.png b/procgenAISC/procgen/data/assets/kenney/Enemies/fly_move.png
new file mode 100644
index 0000000..de56d13
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/fly_move.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/frog.png b/procgenAISC/procgen/data/assets/kenney/Enemies/frog.png
new file mode 100644
index 0000000..8107bb4
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/frog.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/frog_dead.png b/procgenAISC/procgen/data/assets/kenney/Enemies/frog_dead.png
new file mode 100644
index 0000000..5bb49ed
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/frog_dead.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/frog_move.png b/procgenAISC/procgen/data/assets/kenney/Enemies/frog_move.png
new file mode 100644
index 0000000..87a39af
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/frog_move.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/ladybug.png b/procgenAISC/procgen/data/assets/kenney/Enemies/ladybug.png
new file mode 100644
index 0000000..3f95a2d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/ladybug.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/ladybug_fly.png b/procgenAISC/procgen/data/assets/kenney/Enemies/ladybug_fly.png
new file mode 100644
index 0000000..ad4e8f9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/ladybug_fly.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/ladybug_move.png b/procgenAISC/procgen/data/assets/kenney/Enemies/ladybug_move.png
new file mode 100644
index 0000000..6682580
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/ladybug_move.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/mouse.png b/procgenAISC/procgen/data/assets/kenney/Enemies/mouse.png
new file mode 100644
index 0000000..5d98c41
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/mouse.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/mouse_dead.png b/procgenAISC/procgen/data/assets/kenney/Enemies/mouse_dead.png
new file mode 100644
index 0000000..0bc0ea1
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/mouse_dead.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/mouse_move.png b/procgenAISC/procgen/data/assets/kenney/Enemies/mouse_move.png
new file mode 100644
index 0000000..e461c3f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/mouse_move.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/saw.png b/procgenAISC/procgen/data/assets/kenney/Enemies/saw.png
new file mode 100644
index 0000000..4494ec7
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/saw.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/sawHalf.png b/procgenAISC/procgen/data/assets/kenney/Enemies/sawHalf.png
new file mode 100644
index 0000000..c5f7732
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/sawHalf.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/sawHalf_dead.png b/procgenAISC/procgen/data/assets/kenney/Enemies/sawHalf_dead.png
new file mode 100644
index 0000000..9747f90
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/sawHalf_dead.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/sawHalf_move.png b/procgenAISC/procgen/data/assets/kenney/Enemies/sawHalf_move.png
new file mode 100644
index 0000000..bbf85f6
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/sawHalf_move.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/saw_dead.png b/procgenAISC/procgen/data/assets/kenney/Enemies/saw_dead.png
new file mode 100644
index 0000000..72b605f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/saw_dead.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/saw_move.png b/procgenAISC/procgen/data/assets/kenney/Enemies/saw_move.png
new file mode 100644
index 0000000..572e58b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/saw_move.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/slimeBlock.png b/procgenAISC/procgen/data/assets/kenney/Enemies/slimeBlock.png
new file mode 100644
index 0000000..790350a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/slimeBlock.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/slimeBlock_dead.png b/procgenAISC/procgen/data/assets/kenney/Enemies/slimeBlock_dead.png
new file mode 100644
index 0000000..0fa82ce
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/slimeBlock_dead.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/slimeBlock_move.png b/procgenAISC/procgen/data/assets/kenney/Enemies/slimeBlock_move.png
new file mode 100644
index 0000000..1ee0aaa
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/slimeBlock_move.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/slimeBlue.png b/procgenAISC/procgen/data/assets/kenney/Enemies/slimeBlue.png
new file mode 100644
index 0000000..6d18e27
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/slimeBlue.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/slimeBlue_dead.png b/procgenAISC/procgen/data/assets/kenney/Enemies/slimeBlue_dead.png
new file mode 100644
index 0000000..2508089
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/slimeBlue_dead.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/slimeBlue_hit.png b/procgenAISC/procgen/data/assets/kenney/Enemies/slimeBlue_hit.png
new file mode 100644
index 0000000..fcb3cdb
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/slimeBlue_hit.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/slimeBlue_move.png b/procgenAISC/procgen/data/assets/kenney/Enemies/slimeBlue_move.png
new file mode 100644
index 0000000..e676dcc
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/slimeBlue_move.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/slimeGreen.png b/procgenAISC/procgen/data/assets/kenney/Enemies/slimeGreen.png
new file mode 100644
index 0000000..397b623
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/slimeGreen.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/slimeGreen_dead.png b/procgenAISC/procgen/data/assets/kenney/Enemies/slimeGreen_dead.png
new file mode 100644
index 0000000..519aac9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/slimeGreen_dead.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/slimeGreen_hit.png b/procgenAISC/procgen/data/assets/kenney/Enemies/slimeGreen_hit.png
new file mode 100644
index 0000000..67139db
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/slimeGreen_hit.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/slimeGreen_move.png b/procgenAISC/procgen/data/assets/kenney/Enemies/slimeGreen_move.png
new file mode 100644
index 0000000..1aaa6ac
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/slimeGreen_move.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/slimePurple.png b/procgenAISC/procgen/data/assets/kenney/Enemies/slimePurple.png
new file mode 100644
index 0000000..e72ac04
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/slimePurple.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/slimePurple_dead.png b/procgenAISC/procgen/data/assets/kenney/Enemies/slimePurple_dead.png
new file mode 100644
index 0000000..cd79996
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/slimePurple_dead.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/slimePurple_hit.png b/procgenAISC/procgen/data/assets/kenney/Enemies/slimePurple_hit.png
new file mode 100644
index 0000000..54647aa
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/slimePurple_hit.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/slimePurple_move.png b/procgenAISC/procgen/data/assets/kenney/Enemies/slimePurple_move.png
new file mode 100644
index 0000000..0d538dc
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/slimePurple_move.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/snail.png b/procgenAISC/procgen/data/assets/kenney/Enemies/snail.png
new file mode 100644
index 0000000..8792331
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/snail.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/snail_move.png b/procgenAISC/procgen/data/assets/kenney/Enemies/snail_move.png
new file mode 100644
index 0000000..a372de4
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/snail_move.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/snail_shell.png b/procgenAISC/procgen/data/assets/kenney/Enemies/snail_shell.png
new file mode 100644
index 0000000..37dc4e5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/snail_shell.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/wormGreen.png b/procgenAISC/procgen/data/assets/kenney/Enemies/wormGreen.png
new file mode 100644
index 0000000..045161a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/wormGreen.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/wormGreen_dead.png b/procgenAISC/procgen/data/assets/kenney/Enemies/wormGreen_dead.png
new file mode 100644
index 0000000..fba0f23
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/wormGreen_dead.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/wormGreen_move.png b/procgenAISC/procgen/data/assets/kenney/Enemies/wormGreen_move.png
new file mode 100644
index 0000000..999416e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/wormGreen_move.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/wormPink.png b/procgenAISC/procgen/data/assets/kenney/Enemies/wormPink.png
new file mode 100644
index 0000000..4ee861a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/wormPink.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/wormPink_dead.png b/procgenAISC/procgen/data/assets/kenney/Enemies/wormPink_dead.png
new file mode 100644
index 0000000..7eb3f56
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/wormPink_dead.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Enemies/wormPink_move.png b/procgenAISC/procgen/data/assets/kenney/Enemies/wormPink_move.png
new file mode 100644
index 0000000..e20ae69
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Enemies/wormPink_move.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirt.png b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirt.png
new file mode 100644
index 0000000..9cd4c2b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirt.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtCenter.png b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtCenter.png
new file mode 100644
index 0000000..f6458f0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtCenter.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtCenter_rounded.png b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtCenter_rounded.png
new file mode 100644
index 0000000..d3be245
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtCenter_rounded.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtCliffAlt_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtCliffAlt_left.png
new file mode 100644
index 0000000..ee77778
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtCliffAlt_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtCliffAlt_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtCliffAlt_right.png
new file mode 100644
index 0000000..f5d19aa
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtCliffAlt_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtCliff_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtCliff_left.png
new file mode 100644
index 0000000..0aa844f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtCliff_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtCliff_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtCliff_right.png
new file mode 100644
index 0000000..508bfbf
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtCliff_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtCorner_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtCorner_left.png
new file mode 100644
index 0000000..7919775
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtCorner_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtCorner_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtCorner_right.png
new file mode 100644
index 0000000..fb0cb54
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtCorner_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtHalf.png b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtHalf.png
new file mode 100644
index 0000000..8e3a462
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtHalf.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtHalf_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtHalf_left.png
new file mode 100644
index 0000000..497d658
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtHalf_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtHalf_mid.png b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtHalf_mid.png
new file mode 100644
index 0000000..a656a0f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtHalf_mid.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtHalf_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtHalf_right.png
new file mode 100644
index 0000000..9b4de8c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtHalf_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtHill_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtHill_left.png
new file mode 100644
index 0000000..313d33c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtHill_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtHill_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtHill_right.png
new file mode 100644
index 0000000..f45ef32
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtHill_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtLeft.png b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtLeft.png
new file mode 100644
index 0000000..0d18085
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtLeft.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtMid.png b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtMid.png
new file mode 100644
index 0000000..d9612cf
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtMid.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtRight.png b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtRight.png
new file mode 100644
index 0000000..695eaf8
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Dirt/dirtRight.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grass.png b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grass.png
new file mode 100644
index 0000000..e23656a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grass.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassCenter.png b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassCenter.png
new file mode 100644
index 0000000..d595bdc
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassCenter.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassCenter_round.png b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassCenter_round.png
new file mode 100644
index 0000000..acb578f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassCenter_round.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassCliffAlt_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassCliffAlt_left.png
new file mode 100644
index 0000000..f92955f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassCliffAlt_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassCliffAlt_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassCliffAlt_right.png
new file mode 100644
index 0000000..b3d5aa4
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassCliffAlt_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassCliff_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassCliff_left.png
new file mode 100644
index 0000000..c5d47fc
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassCliff_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassCliff_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassCliff_right.png
new file mode 100644
index 0000000..92be008
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassCliff_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassCorner_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassCorner_left.png
new file mode 100644
index 0000000..385aa96
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassCorner_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassCorner_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassCorner_right.png
new file mode 100644
index 0000000..407a7d0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassCorner_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassHalf.png b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassHalf.png
new file mode 100644
index 0000000..42f62ff
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassHalf.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassHalf_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassHalf_left.png
new file mode 100644
index 0000000..0ac58a9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassHalf_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassHalf_mid.png b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassHalf_mid.png
new file mode 100644
index 0000000..f1cd7c1
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassHalf_mid.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassHalf_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassHalf_right.png
new file mode 100644
index 0000000..4b65788
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassHalf_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassHill_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassHill_left.png
new file mode 100644
index 0000000..d9aab2e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassHill_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassHill_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassHill_right.png
new file mode 100644
index 0000000..2d769d7
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassHill_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassLeft.png b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassLeft.png
new file mode 100644
index 0000000..f7cdc03
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassLeft.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassMid.png b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassMid.png
new file mode 100644
index 0000000..acd03cd
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassMid.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassRight.png b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassRight.png
new file mode 100644
index 0000000..2e15ec4
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Grass/grassRight.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planet.png b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planet.png
new file mode 100644
index 0000000..15a48b8
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planet.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetCenter.png b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetCenter.png
new file mode 100644
index 0000000..b635b6f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetCenter.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetCenter_rounded.png b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetCenter_rounded.png
new file mode 100644
index 0000000..acba26d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetCenter_rounded.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetCliffAlt_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetCliffAlt_left.png
new file mode 100644
index 0000000..3206176
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetCliffAlt_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetCliffAlt_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetCliffAlt_right.png
new file mode 100644
index 0000000..10ee32e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetCliffAlt_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetCliff_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetCliff_left.png
new file mode 100644
index 0000000..f4a8d47
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetCliff_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetCliff_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetCliff_right.png
new file mode 100644
index 0000000..152db3e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetCliff_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetCorner_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetCorner_left.png
new file mode 100644
index 0000000..62e3e2a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetCorner_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetCorner_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetCorner_right.png
new file mode 100644
index 0000000..2197fd2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetCorner_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetHalf.png b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetHalf.png
new file mode 100644
index 0000000..59522fc
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetHalf.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetHalf_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetHalf_left.png
new file mode 100644
index 0000000..2ae6221
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetHalf_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetHalf_mid.png b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetHalf_mid.png
new file mode 100644
index 0000000..db09438
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetHalf_mid.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetHalf_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetHalf_right.png
new file mode 100644
index 0000000..7f8c4e0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetHalf_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetHill_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetHill_left.png
new file mode 100644
index 0000000..601e362
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetHill_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetHill_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetHill_right.png
new file mode 100644
index 0000000..aa36c85
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetHill_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetLeft.png b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetLeft.png
new file mode 100644
index 0000000..1140caf
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetLeft.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetMid.png b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetMid.png
new file mode 100644
index 0000000..530cd69
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetMid.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetRight.png b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetRight.png
new file mode 100644
index 0000000..5a1a0f8
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Planet/planetRight.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sand.png b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sand.png
new file mode 100644
index 0000000..13194f0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sand.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandCenter.png b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandCenter.png
new file mode 100644
index 0000000..c2517e3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandCenter.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandCenter_rounded.png b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandCenter_rounded.png
new file mode 100644
index 0000000..659b8a0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandCenter_rounded.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandCliffAlt_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandCliffAlt_left.png
new file mode 100644
index 0000000..f358511
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandCliffAlt_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandCliffAlt_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandCliffAlt_right.png
new file mode 100644
index 0000000..ac61f89
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandCliffAlt_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandCliff_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandCliff_left.png
new file mode 100644
index 0000000..a919e7b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandCliff_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandCliff_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandCliff_right.png
new file mode 100644
index 0000000..e4f0032
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandCliff_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandCorner_leftg.png b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandCorner_leftg.png
new file mode 100644
index 0000000..56690f2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandCorner_leftg.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandCorner_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandCorner_right.png
new file mode 100644
index 0000000..164ea4e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandCorner_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandHalf.png b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandHalf.png
new file mode 100644
index 0000000..210abd2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandHalf.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandHalf_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandHalf_left.png
new file mode 100644
index 0000000..e46782c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandHalf_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandHalf_mid.png b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandHalf_mid.png
new file mode 100644
index 0000000..b48e2ca
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandHalf_mid.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandHalf_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandHalf_right.png
new file mode 100644
index 0000000..58c67a2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandHalf_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandHill_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandHill_left.png
new file mode 100644
index 0000000..3404419
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandHill_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandHill_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandHill_right.png
new file mode 100644
index 0000000..34e0d12
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandHill_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandLeft.png b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandLeft.png
new file mode 100644
index 0000000..7767e14
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandLeft.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandMid.png b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandMid.png
new file mode 100644
index 0000000..8ecd234
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandMid.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandRight.png b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandRight.png
new file mode 100644
index 0000000..e51d3e2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Sand/sandRight.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snow.png b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snow.png
new file mode 100644
index 0000000..1932a4a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snow.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowCenter.png b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowCenter.png
new file mode 100644
index 0000000..5908ca1
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowCenter.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowCenter_rounded.png b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowCenter_rounded.png
new file mode 100644
index 0000000..8c4689a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowCenter_rounded.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowCliffAlt_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowCliffAlt_left.png
new file mode 100644
index 0000000..7fc57e5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowCliffAlt_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowCliffAlt_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowCliffAlt_right.png
new file mode 100644
index 0000000..d797efc
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowCliffAlt_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowCliff_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowCliff_left.png
new file mode 100644
index 0000000..75c7cc6
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowCliff_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowCliff_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowCliff_right.png
new file mode 100644
index 0000000..0a78861
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowCliff_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowCorner_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowCorner_left.png
new file mode 100644
index 0000000..59882cb
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowCorner_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowCorner_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowCorner_right.png
new file mode 100644
index 0000000..e235c82
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowCorner_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowHalf.png b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowHalf.png
new file mode 100644
index 0000000..a9c09c5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowHalf.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowHalf_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowHalf_left.png
new file mode 100644
index 0000000..179801e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowHalf_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowHalf_mid.png b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowHalf_mid.png
new file mode 100644
index 0000000..4b8387a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowHalf_mid.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowHalf_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowHalf_right.png
new file mode 100644
index 0000000..dfe967a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowHalf_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowHill_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowHill_left.png
new file mode 100644
index 0000000..c20fe15
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowHill_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowHill_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowHill_right.png
new file mode 100644
index 0000000..8a4d9c8
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowHill_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowLeft.png b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowLeft.png
new file mode 100644
index 0000000..ae82d1d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowLeft.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowMid.png b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowMid.png
new file mode 100644
index 0000000..bf541b4
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowMid.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowRight.png b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowRight.png
new file mode 100644
index 0000000..2cf0d64
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Snow/snowRight.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stone.png b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stone.png
new file mode 100644
index 0000000..9e1fe8f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stone.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneCenter.png b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneCenter.png
new file mode 100644
index 0000000..05393e0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneCenter.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneCenter_rounded.png b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneCenter_rounded.png
new file mode 100644
index 0000000..4d1be1f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneCenter_rounded.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneCliffAlt_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneCliffAlt_left.png
new file mode 100644
index 0000000..cc4f5b8
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneCliffAlt_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneCliffAlt_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneCliffAlt_right.png
new file mode 100644
index 0000000..2983549
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneCliffAlt_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneCliff_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneCliff_left.png
new file mode 100644
index 0000000..814b779
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneCliff_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneCliff_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneCliff_right.png
new file mode 100644
index 0000000..a0b4b64
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneCliff_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneCorner_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneCorner_left.png
new file mode 100644
index 0000000..d7e0fdf
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneCorner_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneCorner_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneCorner_right.png
new file mode 100644
index 0000000..7de3cc6
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneCorner_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneHalf.png b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneHalf.png
new file mode 100644
index 0000000..adea72f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneHalf.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneHalf_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneHalf_left.png
new file mode 100644
index 0000000..5b1355a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneHalf_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneHalf_mid.png b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneHalf_mid.png
new file mode 100644
index 0000000..82bdd72
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneHalf_mid.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneHalf_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneHalf_right.png
new file mode 100644
index 0000000..43b6175
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneHalf_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneHill_left.png b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneHill_left.png
new file mode 100644
index 0000000..25c3a06
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneHill_left.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneHill_right.png b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneHill_right.png
new file mode 100644
index 0000000..8a33781
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneHill_right.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneLeft.png b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneLeft.png
new file mode 100644
index 0000000..7cf175f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneLeft.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneMid.png b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneMid.png
new file mode 100644
index 0000000..e11b3c1
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneMid.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneRight.png b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneRight.png
new file mode 100644
index 0000000..2f74870
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Ground/Stone/stoneRight.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hud0.png b/procgenAISC/procgen/data/assets/kenney/HUD/hud0.png
new file mode 100644
index 0000000..9e5c585
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hud0.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hud1.png b/procgenAISC/procgen/data/assets/kenney/HUD/hud1.png
new file mode 100644
index 0000000..4cf80b0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hud1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hud2.png b/procgenAISC/procgen/data/assets/kenney/HUD/hud2.png
new file mode 100644
index 0000000..9c4f1dd
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hud2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hud3.png b/procgenAISC/procgen/data/assets/kenney/HUD/hud3.png
new file mode 100644
index 0000000..e275958
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hud3.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hud4.png b/procgenAISC/procgen/data/assets/kenney/HUD/hud4.png
new file mode 100644
index 0000000..97a7654
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hud4.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hud5.png b/procgenAISC/procgen/data/assets/kenney/HUD/hud5.png
new file mode 100644
index 0000000..1d67536
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hud5.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hud6.png b/procgenAISC/procgen/data/assets/kenney/HUD/hud6.png
new file mode 100644
index 0000000..ec9083c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hud6.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hud7.png b/procgenAISC/procgen/data/assets/kenney/HUD/hud7.png
new file mode 100644
index 0000000..72324d4
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hud7.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hud8.png b/procgenAISC/procgen/data/assets/kenney/HUD/hud8.png
new file mode 100644
index 0000000..e5b1000
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hud8.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hud9.png b/procgenAISC/procgen/data/assets/kenney/HUD/hud9.png
new file mode 100644
index 0000000..10e2ed6
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hud9.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hudCoin.png b/procgenAISC/procgen/data/assets/kenney/HUD/hudCoin.png
new file mode 100644
index 0000000..d39b869
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hudCoin.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hudHeart_empty.png b/procgenAISC/procgen/data/assets/kenney/HUD/hudHeart_empty.png
new file mode 100644
index 0000000..cc5e808
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hudHeart_empty.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hudHeart_full.png b/procgenAISC/procgen/data/assets/kenney/HUD/hudHeart_full.png
new file mode 100644
index 0000000..9b8aab9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hudHeart_full.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hudHeart_half.png b/procgenAISC/procgen/data/assets/kenney/HUD/hudHeart_half.png
new file mode 100644
index 0000000..4626126
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hudHeart_half.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hudJewel_blue.png b/procgenAISC/procgen/data/assets/kenney/HUD/hudJewel_blue.png
new file mode 100644
index 0000000..c6421d3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hudJewel_blue.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hudJewel_blue_empty.png b/procgenAISC/procgen/data/assets/kenney/HUD/hudJewel_blue_empty.png
new file mode 100644
index 0000000..271d3ec
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hudJewel_blue_empty.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hudJewel_green.png b/procgenAISC/procgen/data/assets/kenney/HUD/hudJewel_green.png
new file mode 100644
index 0000000..7ac275a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hudJewel_green.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hudJewel_green_empty.png b/procgenAISC/procgen/data/assets/kenney/HUD/hudJewel_green_empty.png
new file mode 100644
index 0000000..b1b5846
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hudJewel_green_empty.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hudJewel_red.png b/procgenAISC/procgen/data/assets/kenney/HUD/hudJewel_red.png
new file mode 100644
index 0000000..718637b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hudJewel_red.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hudJewel_red_empty.png b/procgenAISC/procgen/data/assets/kenney/HUD/hudJewel_red_empty.png
new file mode 100644
index 0000000..25819d6
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hudJewel_red_empty.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hudJewel_yellow.png b/procgenAISC/procgen/data/assets/kenney/HUD/hudJewel_yellow.png
new file mode 100644
index 0000000..9a64e69
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hudJewel_yellow.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hudJewel_yellow_empty.png b/procgenAISC/procgen/data/assets/kenney/HUD/hudJewel_yellow_empty.png
new file mode 100644
index 0000000..b2bb515
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hudJewel_yellow_empty.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hudKey_blue.png b/procgenAISC/procgen/data/assets/kenney/HUD/hudKey_blue.png
new file mode 100644
index 0000000..436bc69
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hudKey_blue.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hudKey_blue_empty.png b/procgenAISC/procgen/data/assets/kenney/HUD/hudKey_blue_empty.png
new file mode 100644
index 0000000..6bbc87d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hudKey_blue_empty.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hudKey_green.png b/procgenAISC/procgen/data/assets/kenney/HUD/hudKey_green.png
new file mode 100644
index 0000000..0e45e5c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hudKey_green.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hudKey_green_empty.png b/procgenAISC/procgen/data/assets/kenney/HUD/hudKey_green_empty.png
new file mode 100644
index 0000000..e384fbb
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hudKey_green_empty.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hudKey_red.png b/procgenAISC/procgen/data/assets/kenney/HUD/hudKey_red.png
new file mode 100644
index 0000000..72610b2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hudKey_red.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hudKey_red_empty.png b/procgenAISC/procgen/data/assets/kenney/HUD/hudKey_red_empty.png
new file mode 100644
index 0000000..09f947f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hudKey_red_empty.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hudKey_yellow.png b/procgenAISC/procgen/data/assets/kenney/HUD/hudKey_yellow.png
new file mode 100644
index 0000000..eeb9601
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hudKey_yellow.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hudKey_yellow_empty.png b/procgenAISC/procgen/data/assets/kenney/HUD/hudKey_yellow_empty.png
new file mode 100644
index 0000000..1187c3e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hudKey_yellow_empty.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hudPlayer_beige.png b/procgenAISC/procgen/data/assets/kenney/HUD/hudPlayer_beige.png
new file mode 100644
index 0000000..bc66d66
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hudPlayer_beige.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hudPlayer_blue.png b/procgenAISC/procgen/data/assets/kenney/HUD/hudPlayer_blue.png
new file mode 100644
index 0000000..6691950
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hudPlayer_blue.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hudPlayer_green.png b/procgenAISC/procgen/data/assets/kenney/HUD/hudPlayer_green.png
new file mode 100644
index 0000000..747b2d5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hudPlayer_green.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hudPlayer_pink.png b/procgenAISC/procgen/data/assets/kenney/HUD/hudPlayer_pink.png
new file mode 100644
index 0000000..7aa94fb
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hudPlayer_pink.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hudPlayer_yellow.png b/procgenAISC/procgen/data/assets/kenney/HUD/hudPlayer_yellow.png
new file mode 100644
index 0000000..944f439
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hudPlayer_yellow.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/HUD/hudX.png b/procgenAISC/procgen/data/assets/kenney/HUD/hudX.png
new file mode 100644
index 0000000..4ca0593
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/HUD/hudX.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Items/coinBronze.png b/procgenAISC/procgen/data/assets/kenney/Items/coinBronze.png
new file mode 100644
index 0000000..cf346cb
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Items/coinBronze.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Items/coinGold.png b/procgenAISC/procgen/data/assets/kenney/Items/coinGold.png
new file mode 100644
index 0000000..4df83e2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Items/coinGold.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Items/coinSilver.png b/procgenAISC/procgen/data/assets/kenney/Items/coinSilver.png
new file mode 100644
index 0000000..dc36564
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Items/coinSilver.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Items/flagBlue1.png b/procgenAISC/procgen/data/assets/kenney/Items/flagBlue1.png
new file mode 100644
index 0000000..3651d8e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Items/flagBlue1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Items/flagBlue2.png b/procgenAISC/procgen/data/assets/kenney/Items/flagBlue2.png
new file mode 100644
index 0000000..d82c11c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Items/flagBlue2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Items/flagBlue_down.png b/procgenAISC/procgen/data/assets/kenney/Items/flagBlue_down.png
new file mode 100644
index 0000000..da6e9d1
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Items/flagBlue_down.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Items/flagGreen1.png b/procgenAISC/procgen/data/assets/kenney/Items/flagGreen1.png
new file mode 100644
index 0000000..b7b4278
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Items/flagGreen1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Items/flagGreen2.png b/procgenAISC/procgen/data/assets/kenney/Items/flagGreen2.png
new file mode 100644
index 0000000..57534e3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Items/flagGreen2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Items/flagGreen_down.png b/procgenAISC/procgen/data/assets/kenney/Items/flagGreen_down.png
new file mode 100644
index 0000000..1b1a1e9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Items/flagGreen_down.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Items/flagRed1.png b/procgenAISC/procgen/data/assets/kenney/Items/flagRed1.png
new file mode 100644
index 0000000..fae407e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Items/flagRed1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Items/flagRed2.png b/procgenAISC/procgen/data/assets/kenney/Items/flagRed2.png
new file mode 100644
index 0000000..4193385
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Items/flagRed2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Items/flagRed_down.png b/procgenAISC/procgen/data/assets/kenney/Items/flagRed_down.png
new file mode 100644
index 0000000..a97a990
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Items/flagRed_down.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Items/flagYellow1.png b/procgenAISC/procgen/data/assets/kenney/Items/flagYellow1.png
new file mode 100644
index 0000000..909099d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Items/flagYellow1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Items/flagYellow2.png b/procgenAISC/procgen/data/assets/kenney/Items/flagYellow2.png
new file mode 100644
index 0000000..c5e1bbd
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Items/flagYellow2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Items/flagYellow_down.png b/procgenAISC/procgen/data/assets/kenney/Items/flagYellow_down.png
new file mode 100644
index 0000000..c2d5fc5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Items/flagYellow_down.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Items/gemBlue.png b/procgenAISC/procgen/data/assets/kenney/Items/gemBlue.png
new file mode 100644
index 0000000..dfd6025
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Items/gemBlue.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Items/gemGreen.png b/procgenAISC/procgen/data/assets/kenney/Items/gemGreen.png
new file mode 100644
index 0000000..6cdc8f0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Items/gemGreen.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Items/gemRed.png b/procgenAISC/procgen/data/assets/kenney/Items/gemRed.png
new file mode 100644
index 0000000..27dcf03
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Items/gemRed.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Items/gemYellow.png b/procgenAISC/procgen/data/assets/kenney/Items/gemYellow.png
new file mode 100644
index 0000000..5a8201a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Items/gemYellow.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Items/keyBlue.png b/procgenAISC/procgen/data/assets/kenney/Items/keyBlue.png
new file mode 100644
index 0000000..b4099ef
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Items/keyBlue.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Items/keyGreen.png b/procgenAISC/procgen/data/assets/kenney/Items/keyGreen.png
new file mode 100644
index 0000000..00d5140
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Items/keyGreen.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Items/keyRed.png b/procgenAISC/procgen/data/assets/kenney/Items/keyRed.png
new file mode 100644
index 0000000..d4c1c59
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Items/keyRed.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Items/keyYellow.png b/procgenAISC/procgen/data/assets/kenney/Items/keyYellow.png
new file mode 100644
index 0000000..bcfd368
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Items/keyYellow.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Items/red_line_diag.png b/procgenAISC/procgen/data/assets/kenney/Items/red_line_diag.png
new file mode 100644
index 0000000..6d554e9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Items/red_line_diag.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Items/star.png b/procgenAISC/procgen/data/assets/kenney/Items/star.png
new file mode 100644
index 0000000..20f5dd1
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Items/star.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Items/yellow_line_diag.png b/procgenAISC/procgen/data/assets/kenney/Items/yellow_line_diag.png
new file mode 100644
index 0000000..619a45d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Items/yellow_line_diag.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Particles/brickBrown.png b/procgenAISC/procgen/data/assets/kenney/Particles/brickBrown.png
new file mode 100644
index 0000000..8372271
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Particles/brickBrown.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Particles/brickGrey.png b/procgenAISC/procgen/data/assets/kenney/Particles/brickGrey.png
new file mode 100644
index 0000000..da491ae
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Particles/brickGrey.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Particles/fireball.png b/procgenAISC/procgen/data/assets/kenney/Particles/fireball.png
new file mode 100644
index 0000000..e61f9eb
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Particles/fireball.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_climb1.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_climb1.png
new file mode 100644
index 0000000..0a4b5af
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_climb1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_climb2.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_climb2.png
new file mode 100644
index 0000000..9160e0f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_climb2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_duck.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_duck.png
new file mode 100644
index 0000000..3eb9a37
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_duck.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_front.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_front.png
new file mode 100644
index 0000000..505cb48
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_front.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_hit.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_hit.png
new file mode 100644
index 0000000..ba7cfdd
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_hit.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_jump.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_jump.png
new file mode 100644
index 0000000..ca63edb
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_jump.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_stand.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_stand.png
new file mode 100644
index 0000000..e064eb2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_stand.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_swim1.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_swim1.png
new file mode 100644
index 0000000..2f8cd22
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_swim1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_swim2.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_swim2.png
new file mode 100644
index 0000000..091ef6b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_swim2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_walk1.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_walk1.png
new file mode 100644
index 0000000..68e277a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_walk1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_walk2.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_walk2.png
new file mode 100644
index 0000000..0effaea
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Beige/alienBeige_walk2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_climb1.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_climb1.png
new file mode 100644
index 0000000..67ee761
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_climb1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_climb2.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_climb2.png
new file mode 100644
index 0000000..6ee5374
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_climb2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_duck.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_duck.png
new file mode 100644
index 0000000..61042dd
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_duck.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_front.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_front.png
new file mode 100644
index 0000000..d5ce6eb
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_front.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_hit.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_hit.png
new file mode 100644
index 0000000..e7350a0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_hit.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_jump.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_jump.png
new file mode 100644
index 0000000..b99fa0e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_jump.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_stand.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_stand.png
new file mode 100644
index 0000000..b6f2d79
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_stand.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_swim1.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_swim1.png
new file mode 100644
index 0000000..786451d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_swim1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_swim2.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_swim2.png
new file mode 100644
index 0000000..2abaecc
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_swim2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_walk1.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_walk1.png
new file mode 100644
index 0000000..e8b5a3f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_walk1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_walk2.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_walk2.png
new file mode 100644
index 0000000..44eae01
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Blue/alienBlue_walk2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_climb1.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_climb1.png
new file mode 100644
index 0000000..df0c1c0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_climb1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_climb2.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_climb2.png
new file mode 100644
index 0000000..ae1b31b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_climb2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_duck.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_duck.png
new file mode 100644
index 0000000..4370e11
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_duck.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_front.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_front.png
new file mode 100644
index 0000000..57a0858
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_front.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_hit.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_hit.png
new file mode 100644
index 0000000..652cc9b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_hit.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_jump.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_jump.png
new file mode 100644
index 0000000..5a74c7a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_jump.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_stand.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_stand.png
new file mode 100644
index 0000000..51fcef9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_stand.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_swim1.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_swim1.png
new file mode 100644
index 0000000..c701ecd
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_swim1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_swim2.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_swim2.png
new file mode 100644
index 0000000..54ddce7
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_swim2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_walk1.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_walk1.png
new file mode 100644
index 0000000..3fb7fbf
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_walk1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_walk2.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_walk2.png
new file mode 100644
index 0000000..464c910
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Green/alienGreen_walk2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_climb1.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_climb1.png
new file mode 100644
index 0000000..77f9a16
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_climb1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_climb2.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_climb2.png
new file mode 100644
index 0000000..08599b0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_climb2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_duck.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_duck.png
new file mode 100644
index 0000000..fce478d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_duck.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_front.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_front.png
new file mode 100644
index 0000000..ae69ba2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_front.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_hit.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_hit.png
new file mode 100644
index 0000000..243b066
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_hit.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_jump.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_jump.png
new file mode 100644
index 0000000..51c12bd
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_jump.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_stand.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_stand.png
new file mode 100644
index 0000000..9ce0f13
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_stand.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_swim1.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_swim1.png
new file mode 100644
index 0000000..603399a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_swim1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_swim2.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_swim2.png
new file mode 100644
index 0000000..58ccdc0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_swim2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_walk1.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_walk1.png
new file mode 100644
index 0000000..fabfc07
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_walk1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_walk2.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_walk2.png
new file mode 100644
index 0000000..9b9f532
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Pink/alienPink_walk2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_climb1.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_climb1.png
new file mode 100644
index 0000000..92c4a73
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_climb1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_climb2.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_climb2.png
new file mode 100644
index 0000000..06a2117
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_climb2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_duck.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_duck.png
new file mode 100644
index 0000000..51b4610
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_duck.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_front.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_front.png
new file mode 100644
index 0000000..991d326
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_front.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_hit.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_hit.png
new file mode 100644
index 0000000..77498d9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_hit.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_jump.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_jump.png
new file mode 100644
index 0000000..e6da869
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_jump.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_stand.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_stand.png
new file mode 100644
index 0000000..d625e03
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_stand.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_swim1.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_swim1.png
new file mode 100644
index 0000000..647387f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_swim1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_swim2.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_swim2.png
new file mode 100644
index 0000000..f7e9a63
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_swim2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_walk1.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_walk1.png
new file mode 100644
index 0000000..b04c5b2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_walk1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_walk2.png b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_walk2.png
new file mode 100644
index 0000000..40510e7
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/128x256/Yellow/alienYellow_walk2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_climb1.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_climb1.png
new file mode 100644
index 0000000..fdd8749
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_climb1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_climb2.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_climb2.png
new file mode 100644
index 0000000..d6cecbb
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_climb2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_duck.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_duck.png
new file mode 100644
index 0000000..0f9110f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_duck.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_front.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_front.png
new file mode 100644
index 0000000..7fa22e7
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_front.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_hit.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_hit.png
new file mode 100644
index 0000000..325bed0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_hit.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_jump.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_jump.png
new file mode 100644
index 0000000..1549151
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_jump.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_stand.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_stand.png
new file mode 100644
index 0000000..0dd3057
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_stand.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_swim1.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_swim1.png
new file mode 100644
index 0000000..6ac4471
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_swim1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_swim2.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_swim2.png
new file mode 100644
index 0000000..e1b6895
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_swim2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_walk1.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_walk1.png
new file mode 100644
index 0000000..a4b6599
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_walk1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_walk2.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_walk2.png
new file mode 100644
index 0000000..b9dc397
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Beige/alienBiege_walk2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_climb1.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_climb1.png
new file mode 100644
index 0000000..415de24
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_climb1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_climb2.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_climb2.png
new file mode 100644
index 0000000..5d7cddf
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_climb2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_duck.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_duck.png
new file mode 100644
index 0000000..8e9ba47
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_duck.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_front.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_front.png
new file mode 100644
index 0000000..aa64b7c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_front.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_hit.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_hit.png
new file mode 100644
index 0000000..437a473
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_hit.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_jump.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_jump.png
new file mode 100644
index 0000000..79f0231
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_jump.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_stand.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_stand.png
new file mode 100644
index 0000000..56fe432
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_stand.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_swim1.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_swim1.png
new file mode 100644
index 0000000..2deaed1
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_swim1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_swim2.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_swim2.png
new file mode 100644
index 0000000..6e238a7
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_swim2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_walk1.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_walk1.png
new file mode 100644
index 0000000..7922b84
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_walk1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_walk2.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_walk2.png
new file mode 100644
index 0000000..48245ae
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Blue/alienBlue_walk2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_climb1.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_climb1.png
new file mode 100644
index 0000000..4d7eda1
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_climb1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_climb2.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_climb2.png
new file mode 100644
index 0000000..de31e05
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_climb2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_duck.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_duck.png
new file mode 100644
index 0000000..85406df
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_duck.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_front.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_front.png
new file mode 100644
index 0000000..d756cb0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_front.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_hit.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_hit.png
new file mode 100644
index 0000000..8e18028
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_hit.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_jump.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_jump.png
new file mode 100644
index 0000000..98d6dfa
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_jump.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_stand.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_stand.png
new file mode 100644
index 0000000..c417521
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_stand.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_swim1.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_swim1.png
new file mode 100644
index 0000000..b5537fc
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_swim1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_swim2.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_swim2.png
new file mode 100644
index 0000000..e30d30f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_swim2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_walk1.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_walk1.png
new file mode 100644
index 0000000..88af1f1
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_walk1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_walk2.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_walk2.png
new file mode 100644
index 0000000..9901346
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Green/alienGreen_walk2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_climb1.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_climb1.png
new file mode 100644
index 0000000..56d2800
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_climb1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_climb2.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_climb2.png
new file mode 100644
index 0000000..c779521
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_climb2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_duck.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_duck.png
new file mode 100644
index 0000000..e90a3e3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_duck.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_front.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_front.png
new file mode 100644
index 0000000..ac564e6
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_front.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_hit.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_hit.png
new file mode 100644
index 0000000..db92b42
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_hit.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_jump.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_jump.png
new file mode 100644
index 0000000..baacec4
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_jump.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_stand.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_stand.png
new file mode 100644
index 0000000..ed2ecec
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_stand.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_swim1.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_swim1.png
new file mode 100644
index 0000000..b962b72
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_swim1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_swim2.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_swim2.png
new file mode 100644
index 0000000..04bcac8
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_swim2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_walk1.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_walk1.png
new file mode 100644
index 0000000..b43e9c1
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_walk1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_walk2.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_walk2.png
new file mode 100644
index 0000000..12af234
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Pink/alienPink_walk2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_climb1.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_climb1.png
new file mode 100644
index 0000000..ddef92c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_climb1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_climb2.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_climb2.png
new file mode 100644
index 0000000..6c80e9c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_climb2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_duck.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_duck.png
new file mode 100644
index 0000000..163d5b4
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_duck.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_front.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_front.png
new file mode 100644
index 0000000..bde5cae
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_front.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_hit.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_hit.png
new file mode 100644
index 0000000..eef7adb
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_hit.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_jump.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_jump.png
new file mode 100644
index 0000000..4ed76ee
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_jump.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_stand.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_stand.png
new file mode 100644
index 0000000..afb5121
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_stand.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_swim1.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_swim1.png
new file mode 100644
index 0000000..e5ff2f3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_swim1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_swim2.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_swim2.png
new file mode 100644
index 0000000..87b9d9e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_swim2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_walk1.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_walk1.png
new file mode 100644
index 0000000..148e846
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_walk1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_walk2.png b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_walk2.png
new file mode 100644
index 0000000..bce03a5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Players/Variable sizes/Yellow/alienYellow_walk2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/bomb.png b/procgenAISC/procgen/data/assets/kenney/Tiles/bomb.png
new file mode 100644
index 0000000..aeab3bd
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/bomb.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/bombWhite.png b/procgenAISC/procgen/data/assets/kenney/Tiles/bombWhite.png
new file mode 100644
index 0000000..fb6e8ea
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/bombWhite.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/boxCoin.png b/procgenAISC/procgen/data/assets/kenney/Tiles/boxCoin.png
new file mode 100644
index 0000000..ab29f32
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/boxCoin.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/boxCoin_boxed.png b/procgenAISC/procgen/data/assets/kenney/Tiles/boxCoin_boxed.png
new file mode 100644
index 0000000..a21b664
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/boxCoin_boxed.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/boxCoin_disabled.png b/procgenAISC/procgen/data/assets/kenney/Tiles/boxCoin_disabled.png
new file mode 100644
index 0000000..3b16f86
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/boxCoin_disabled.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/boxCoin_disabled_boxed.png b/procgenAISC/procgen/data/assets/kenney/Tiles/boxCoin_disabled_boxed.png
new file mode 100644
index 0000000..281760c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/boxCoin_disabled_boxed.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/boxCrate.png b/procgenAISC/procgen/data/assets/kenney/Tiles/boxCrate.png
new file mode 100644
index 0000000..8f5737f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/boxCrate.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/boxCrate_double.png b/procgenAISC/procgen/data/assets/kenney/Tiles/boxCrate_double.png
new file mode 100644
index 0000000..86ed133
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/boxCrate_double.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/boxCrate_single.png b/procgenAISC/procgen/data/assets/kenney/Tiles/boxCrate_single.png
new file mode 100644
index 0000000..c96f660
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/boxCrate_single.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/boxCrate_warning.png b/procgenAISC/procgen/data/assets/kenney/Tiles/boxCrate_warning.png
new file mode 100644
index 0000000..89da896
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/boxCrate_warning.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/boxExplosive.png b/procgenAISC/procgen/data/assets/kenney/Tiles/boxExplosive.png
new file mode 100644
index 0000000..7978210
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/boxExplosive.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/boxExplosive_disabled.png b/procgenAISC/procgen/data/assets/kenney/Tiles/boxExplosive_disabled.png
new file mode 100644
index 0000000..09f6efd
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/boxExplosive_disabled.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/boxExplosive_used.png b/procgenAISC/procgen/data/assets/kenney/Tiles/boxExplosive_used.png
new file mode 100644
index 0000000..5241e89
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/boxExplosive_used.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/boxItem.png b/procgenAISC/procgen/data/assets/kenney/Tiles/boxItem.png
new file mode 100644
index 0000000..6f3317b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/boxItem.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/boxItem_boxed.png b/procgenAISC/procgen/data/assets/kenney/Tiles/boxItem_boxed.png
new file mode 100644
index 0000000..89c924c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/boxItem_boxed.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/boxItem_disabled.png b/procgenAISC/procgen/data/assets/kenney/Tiles/boxItem_disabled.png
new file mode 100644
index 0000000..a40531a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/boxItem_disabled.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/boxItem_disabled_boxed.png b/procgenAISC/procgen/data/assets/kenney/Tiles/boxItem_disabled_boxed.png
new file mode 100644
index 0000000..fe5c7c6
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/boxItem_disabled_boxed.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/brickBrown.png b/procgenAISC/procgen/data/assets/kenney/Tiles/brickBrown.png
new file mode 100644
index 0000000..f919d25
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/brickBrown.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/brickGrey.png b/procgenAISC/procgen/data/assets/kenney/Tiles/brickGrey.png
new file mode 100644
index 0000000..00f38ec
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/brickGrey.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/bridgeA.png b/procgenAISC/procgen/data/assets/kenney/Tiles/bridgeA.png
new file mode 100644
index 0000000..ac2d8ec
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/bridgeA.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/bridgeB.png b/procgenAISC/procgen/data/assets/kenney/Tiles/bridgeB.png
new file mode 100644
index 0000000..71ae128
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/bridgeB.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/bush.png b/procgenAISC/procgen/data/assets/kenney/Tiles/bush.png
new file mode 100644
index 0000000..ee353ba
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/bush.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/cactus.png b/procgenAISC/procgen/data/assets/kenney/Tiles/cactus.png
new file mode 100644
index 0000000..3e06c71
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/cactus.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/chain.png b/procgenAISC/procgen/data/assets/kenney/Tiles/chain.png
new file mode 100644
index 0000000..6323675
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/chain.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/doorClosed_mid.png b/procgenAISC/procgen/data/assets/kenney/Tiles/doorClosed_mid.png
new file mode 100644
index 0000000..2b32291
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/doorClosed_mid.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/doorClosed_top.png b/procgenAISC/procgen/data/assets/kenney/Tiles/doorClosed_top.png
new file mode 100644
index 0000000..9001993
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/doorClosed_top.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/doorOpen_mid.png b/procgenAISC/procgen/data/assets/kenney/Tiles/doorOpen_mid.png
new file mode 100644
index 0000000..3132871
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/doorOpen_mid.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/doorOpen_top.png b/procgenAISC/procgen/data/assets/kenney/Tiles/doorOpen_top.png
new file mode 100644
index 0000000..f5619d5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/doorOpen_top.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/fence.png b/procgenAISC/procgen/data/assets/kenney/Tiles/fence.png
new file mode 100644
index 0000000..b5b5b76
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/fence.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/fenceBroken.png b/procgenAISC/procgen/data/assets/kenney/Tiles/fenceBroken.png
new file mode 100644
index 0000000..b98f682
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/fenceBroken.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/grass.png b/procgenAISC/procgen/data/assets/kenney/Tiles/grass.png
new file mode 100644
index 0000000..132ad54
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/grass.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/ladderMid.png b/procgenAISC/procgen/data/assets/kenney/Tiles/ladderMid.png
new file mode 100644
index 0000000..7ef8720
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/ladderMid.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/ladderTop.png b/procgenAISC/procgen/data/assets/kenney/Tiles/ladderTop.png
new file mode 100644
index 0000000..d363693
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/ladderTop.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/lava.png b/procgenAISC/procgen/data/assets/kenney/Tiles/lava.png
new file mode 100644
index 0000000..c23d440
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/lava.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/lavaTop_high.png b/procgenAISC/procgen/data/assets/kenney/Tiles/lavaTop_high.png
new file mode 100644
index 0000000..bf7a954
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/lavaTop_high.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/lavaTop_low.png b/procgenAISC/procgen/data/assets/kenney/Tiles/lavaTop_low.png
new file mode 100644
index 0000000..a220af4
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/lavaTop_low.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/leverLeft.png b/procgenAISC/procgen/data/assets/kenney/Tiles/leverLeft.png
new file mode 100644
index 0000000..3a57cae
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/leverLeft.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/leverMid.png b/procgenAISC/procgen/data/assets/kenney/Tiles/leverMid.png
new file mode 100644
index 0000000..523d012
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/leverMid.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/leverRight.png b/procgenAISC/procgen/data/assets/kenney/Tiles/leverRight.png
new file mode 100644
index 0000000..a8cb42c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/leverRight.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/lockBlue.png b/procgenAISC/procgen/data/assets/kenney/Tiles/lockBlue.png
new file mode 100644
index 0000000..cc7a159
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/lockBlue.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/lockGreen.png b/procgenAISC/procgen/data/assets/kenney/Tiles/lockGreen.png
new file mode 100644
index 0000000..2a5f8fe
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/lockGreen.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/lockRed.png b/procgenAISC/procgen/data/assets/kenney/Tiles/lockRed.png
new file mode 100644
index 0000000..00ce745
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/lockRed.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/lockYellow.png b/procgenAISC/procgen/data/assets/kenney/Tiles/lockYellow.png
new file mode 100644
index 0000000..7173a53
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/lockYellow.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/mushroomBrown.png b/procgenAISC/procgen/data/assets/kenney/Tiles/mushroomBrown.png
new file mode 100644
index 0000000..9e583a9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/mushroomBrown.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/mushroomRed.png b/procgenAISC/procgen/data/assets/kenney/Tiles/mushroomRed.png
new file mode 100644
index 0000000..ca88eec
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/mushroomRed.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/plantPurple.png b/procgenAISC/procgen/data/assets/kenney/Tiles/plantPurple.png
new file mode 100644
index 0000000..41effce
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/plantPurple.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/rock.png b/procgenAISC/procgen/data/assets/kenney/Tiles/rock.png
new file mode 100644
index 0000000..d8624b1
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/rock.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/sign.png b/procgenAISC/procgen/data/assets/kenney/Tiles/sign.png
new file mode 100644
index 0000000..a9b9610
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/sign.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/signExit.png b/procgenAISC/procgen/data/assets/kenney/Tiles/signExit.png
new file mode 100644
index 0000000..fac42c0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/signExit.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/signLeft.png b/procgenAISC/procgen/data/assets/kenney/Tiles/signLeft.png
new file mode 100644
index 0000000..0d12fff
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/signLeft.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/signRight.png b/procgenAISC/procgen/data/assets/kenney/Tiles/signRight.png
new file mode 100644
index 0000000..334b79e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/signRight.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/snow.png b/procgenAISC/procgen/data/assets/kenney/Tiles/snow.png
new file mode 100644
index 0000000..4ab1536
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/snow.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/spikes.png b/procgenAISC/procgen/data/assets/kenney/Tiles/spikes.png
new file mode 100644
index 0000000..08dc172
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/spikes.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/spring.png b/procgenAISC/procgen/data/assets/kenney/Tiles/spring.png
new file mode 100644
index 0000000..1df151e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/spring.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/sprung.png b/procgenAISC/procgen/data/assets/kenney/Tiles/sprung.png
new file mode 100644
index 0000000..5f2c055
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/sprung.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/switchBlue.png b/procgenAISC/procgen/data/assets/kenney/Tiles/switchBlue.png
new file mode 100644
index 0000000..63aacee
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/switchBlue.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/switchBlue_pressed.png b/procgenAISC/procgen/data/assets/kenney/Tiles/switchBlue_pressed.png
new file mode 100644
index 0000000..6222ebb
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/switchBlue_pressed.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/switchGreen.png b/procgenAISC/procgen/data/assets/kenney/Tiles/switchGreen.png
new file mode 100644
index 0000000..713ca25
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/switchGreen.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/switchGreen_pressed.png b/procgenAISC/procgen/data/assets/kenney/Tiles/switchGreen_pressed.png
new file mode 100644
index 0000000..dcb5aab
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/switchGreen_pressed.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/switchRed.png b/procgenAISC/procgen/data/assets/kenney/Tiles/switchRed.png
new file mode 100644
index 0000000..3d25e67
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/switchRed.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/switchRed_pressed.png b/procgenAISC/procgen/data/assets/kenney/Tiles/switchRed_pressed.png
new file mode 100644
index 0000000..52da8db
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/switchRed_pressed.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/switchYellow.png b/procgenAISC/procgen/data/assets/kenney/Tiles/switchYellow.png
new file mode 100644
index 0000000..48564fd
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/switchYellow.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/switchYellow_pressed.png b/procgenAISC/procgen/data/assets/kenney/Tiles/switchYellow_pressed.png
new file mode 100644
index 0000000..8c53531
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/switchYellow_pressed.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/torch1.png b/procgenAISC/procgen/data/assets/kenney/Tiles/torch1.png
new file mode 100644
index 0000000..7bdfed7
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/torch1.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/torch2.png b/procgenAISC/procgen/data/assets/kenney/Tiles/torch2.png
new file mode 100644
index 0000000..91a4c35
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/torch2.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/torchOff.png b/procgenAISC/procgen/data/assets/kenney/Tiles/torchOff.png
new file mode 100644
index 0000000..a774b80
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/torchOff.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/water.png b/procgenAISC/procgen/data/assets/kenney/Tiles/water.png
new file mode 100644
index 0000000..a36a0bd
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/water.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/waterTop_high.png b/procgenAISC/procgen/data/assets/kenney/Tiles/waterTop_high.png
new file mode 100644
index 0000000..f550da5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/waterTop_high.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/waterTop_low.png b/procgenAISC/procgen/data/assets/kenney/Tiles/waterTop_low.png
new file mode 100644
index 0000000..d64bca1
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/waterTop_low.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/weight.png b/procgenAISC/procgen/data/assets/kenney/Tiles/weight.png
new file mode 100644
index 0000000..0ef2a55
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/weight.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/weightAttached.png b/procgenAISC/procgen/data/assets/kenney/Tiles/weightAttached.png
new file mode 100644
index 0000000..7ceefae
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/weightAttached.png differ
diff --git a/procgenAISC/procgen/data/assets/kenney/Tiles/window.png b/procgenAISC/procgen/data/assets/kenney/Tiles/window.png
new file mode 100644
index 0000000..3315b25
Binary files /dev/null and b/procgenAISC/procgen/data/assets/kenney/Tiles/window.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/ball_soccer1.png b/procgenAISC/procgen/data/assets/misc_assets/ball_soccer1.png
new file mode 100644
index 0000000..069923b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/ball_soccer1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/ball_soccer2.png b/procgenAISC/procgen/data/assets/misc_assets/ball_soccer2.png
new file mode 100644
index 0000000..c5a0337
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/ball_soccer2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/ball_tennis1.png b/procgenAISC/procgen/data/assets/misc_assets/ball_tennis1.png
new file mode 100644
index 0000000..1892e4d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/ball_tennis1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/ball_volley2.png b/procgenAISC/procgen/data/assets/misc_assets/ball_volley2.png
new file mode 100644
index 0000000..8317f9b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/ball_volley2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/blockGreen.png b/procgenAISC/procgen/data/assets/misc_assets/blockGreen.png
new file mode 100644
index 0000000..c8fea68
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/blockGreen.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/blockRed.png b/procgenAISC/procgen/data/assets/misc_assets/blockRed.png
new file mode 100644
index 0000000..0f089f0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/blockRed.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/bomb.png b/procgenAISC/procgen/data/assets/misc_assets/bomb.png
new file mode 100644
index 0000000..059caaa
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/bomb.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/bunny2_jump.png b/procgenAISC/procgen/data/assets/misc_assets/bunny2_jump.png
new file mode 100644
index 0000000..0111234
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/bunny2_jump.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/bunny2_ready.png b/procgenAISC/procgen/data/assets/misc_assets/bunny2_ready.png
new file mode 100644
index 0000000..f18ea8d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/bunny2_ready.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/bunny2_stand.png b/procgenAISC/procgen/data/assets/misc_assets/bunny2_stand.png
new file mode 100644
index 0000000..12447f8
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/bunny2_stand.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/bunny2_walk1.png b/procgenAISC/procgen/data/assets/misc_assets/bunny2_walk1.png
new file mode 100644
index 0000000..1276f6d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/bunny2_walk1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/bunny2_walk2.png b/procgenAISC/procgen/data/assets/misc_assets/bunny2_walk2.png
new file mode 100644
index 0000000..a441afc
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/bunny2_walk2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/cannonBall.png b/procgenAISC/procgen/data/assets/misc_assets/cannonBall.png
new file mode 100644
index 0000000..911f032
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/cannonBall.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/car_black_1.png b/procgenAISC/procgen/data/assets/misc_assets/car_black_1.png
new file mode 100644
index 0000000..82156ee
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/car_black_1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/car_black_2.png b/procgenAISC/procgen/data/assets/misc_assets/car_black_2.png
new file mode 100644
index 0000000..63c8eae
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/car_black_2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/car_black_3.png b/procgenAISC/procgen/data/assets/misc_assets/car_black_3.png
new file mode 100644
index 0000000..321c286
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/car_black_3.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/car_black_4.png b/procgenAISC/procgen/data/assets/misc_assets/car_black_4.png
new file mode 100644
index 0000000..146cca9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/car_black_4.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/car_black_5.png b/procgenAISC/procgen/data/assets/misc_assets/car_black_5.png
new file mode 100644
index 0000000..b33640f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/car_black_5.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/car_blue_1.png b/procgenAISC/procgen/data/assets/misc_assets/car_blue_1.png
new file mode 100644
index 0000000..0dfdcfc
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/car_blue_1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/car_blue_2.png b/procgenAISC/procgen/data/assets/misc_assets/car_blue_2.png
new file mode 100644
index 0000000..90992f6
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/car_blue_2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/car_blue_3.png b/procgenAISC/procgen/data/assets/misc_assets/car_blue_3.png
new file mode 100644
index 0000000..6376395
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/car_blue_3.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/car_blue_4.png b/procgenAISC/procgen/data/assets/misc_assets/car_blue_4.png
new file mode 100644
index 0000000..63227b5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/car_blue_4.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/car_blue_5.png b/procgenAISC/procgen/data/assets/misc_assets/car_blue_5.png
new file mode 100644
index 0000000..b588ea0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/car_blue_5.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/car_green_1.png b/procgenAISC/procgen/data/assets/misc_assets/car_green_1.png
new file mode 100644
index 0000000..84e0d57
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/car_green_1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/car_green_2.png b/procgenAISC/procgen/data/assets/misc_assets/car_green_2.png
new file mode 100644
index 0000000..1becceb
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/car_green_2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/car_green_3.png b/procgenAISC/procgen/data/assets/misc_assets/car_green_3.png
new file mode 100644
index 0000000..bb58103
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/car_green_3.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/car_green_4.png b/procgenAISC/procgen/data/assets/misc_assets/car_green_4.png
new file mode 100644
index 0000000..ddd5ffb
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/car_green_4.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/car_green_5.png b/procgenAISC/procgen/data/assets/misc_assets/car_green_5.png
new file mode 100644
index 0000000..0a195e4
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/car_green_5.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/car_red_1.png b/procgenAISC/procgen/data/assets/misc_assets/car_red_1.png
new file mode 100644
index 0000000..77926ba
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/car_red_1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/car_red_2.png b/procgenAISC/procgen/data/assets/misc_assets/car_red_2.png
new file mode 100644
index 0000000..2355de0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/car_red_2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/car_red_3.png b/procgenAISC/procgen/data/assets/misc_assets/car_red_3.png
new file mode 100644
index 0000000..a97164e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/car_red_3.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/car_red_4.png b/procgenAISC/procgen/data/assets/misc_assets/car_red_4.png
new file mode 100644
index 0000000..4fcf733
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/car_red_4.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/car_red_5.png b/procgenAISC/procgen/data/assets/misc_assets/car_red_5.png
new file mode 100644
index 0000000..71f178d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/car_red_5.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/car_yellow_1.png b/procgenAISC/procgen/data/assets/misc_assets/car_yellow_1.png
new file mode 100644
index 0000000..ce280b3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/car_yellow_1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/car_yellow_2.png b/procgenAISC/procgen/data/assets/misc_assets/car_yellow_2.png
new file mode 100644
index 0000000..14c1991
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/car_yellow_2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/car_yellow_3.png b/procgenAISC/procgen/data/assets/misc_assets/car_yellow_3.png
new file mode 100644
index 0000000..8ef5081
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/car_yellow_3.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/car_yellow_4.png b/procgenAISC/procgen/data/assets/misc_assets/car_yellow_4.png
new file mode 100644
index 0000000..3d3cfdd
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/car_yellow_4.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/car_yellow_5.png b/procgenAISC/procgen/data/assets/misc_assets/car_yellow_5.png
new file mode 100644
index 0000000..8e303ec
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/car_yellow_5.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/carrot.png b/procgenAISC/procgen/data/assets/misc_assets/carrot.png
new file mode 100644
index 0000000..d5a5a2d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/carrot.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/character1.png b/procgenAISC/procgen/data/assets/misc_assets/character1.png
new file mode 100644
index 0000000..e7d7bf1
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/character1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/character10.png b/procgenAISC/procgen/data/assets/misc_assets/character10.png
new file mode 100644
index 0000000..f7dd9b9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/character10.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/character11.png b/procgenAISC/procgen/data/assets/misc_assets/character11.png
new file mode 100644
index 0000000..da738d7
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/character11.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/character12.png b/procgenAISC/procgen/data/assets/misc_assets/character12.png
new file mode 100644
index 0000000..8ef604b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/character12.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/character13.png b/procgenAISC/procgen/data/assets/misc_assets/character13.png
new file mode 100644
index 0000000..5c83689
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/character13.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/character2.png b/procgenAISC/procgen/data/assets/misc_assets/character2.png
new file mode 100644
index 0000000..c1c8c9a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/character2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/character3.png b/procgenAISC/procgen/data/assets/misc_assets/character3.png
new file mode 100644
index 0000000..fec3596
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/character3.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/character4.png b/procgenAISC/procgen/data/assets/misc_assets/character4.png
new file mode 100644
index 0000000..d51601b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/character4.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/character5.png b/procgenAISC/procgen/data/assets/misc_assets/character5.png
new file mode 100644
index 0000000..2e391d7
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/character5.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/character6.png b/procgenAISC/procgen/data/assets/misc_assets/character6.png
new file mode 100644
index 0000000..4e040d6
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/character6.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/character7.png b/procgenAISC/procgen/data/assets/misc_assets/character7.png
new file mode 100644
index 0000000..f34a10f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/character7.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/character8.png b/procgenAISC/procgen/data/assets/misc_assets/character8.png
new file mode 100644
index 0000000..c4033dc
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/character8.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/character9.png b/procgenAISC/procgen/data/assets/misc_assets/character9.png
new file mode 100644
index 0000000..54bed31
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/character9.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/cheese.png b/procgenAISC/procgen/data/assets/misc_assets/cheese.png
new file mode 100644
index 0000000..75c6a39
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/cheese.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/cheese.textClipping b/procgenAISC/procgen/data/assets/misc_assets/cheese.textClipping
new file mode 100644
index 0000000..a6806a2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/cheese.textClipping differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/dirt.png b/procgenAISC/procgen/data/assets/misc_assets/dirt.png
new file mode 100644
index 0000000..a60b43c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/dirt.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/dirt_2.png b/procgenAISC/procgen/data/assets/misc_assets/dirt_2.png
new file mode 100644
index 0000000..5cdec1d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/dirt_2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/doorOpen_mid.png b/procgenAISC/procgen/data/assets/misc_assets/doorOpen_mid.png
new file mode 100644
index 0000000..3132871
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/doorOpen_mid.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/doorOpen_top.png b/procgenAISC/procgen/data/assets/misc_assets/doorOpen_top.png
new file mode 100644
index 0000000..f5619d5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/doorOpen_top.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/elementStone007.png b/procgenAISC/procgen/data/assets/misc_assets/elementStone007.png
new file mode 100644
index 0000000..c023b14
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/elementStone007.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/elementWood044.png b/procgenAISC/procgen/data/assets/misc_assets/elementWood044.png
new file mode 100644
index 0000000..ebd459f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/elementWood044.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyFloating_1.png b/procgenAISC/procgen/data/assets/misc_assets/enemyFloating_1.png
new file mode 100644
index 0000000..eb051c2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyFloating_1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyFloating_1b.png b/procgenAISC/procgen/data/assets/misc_assets/enemyFloating_1b.png
new file mode 100644
index 0000000..6ace0d0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyFloating_1b.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyFloating_2.png b/procgenAISC/procgen/data/assets/misc_assets/enemyFloating_2.png
new file mode 100644
index 0000000..95c1790
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyFloating_2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyFloating_3.png b/procgenAISC/procgen/data/assets/misc_assets/enemyFloating_3.png
new file mode 100644
index 0000000..ef2e9d2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyFloating_3.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyFloating_4.png b/procgenAISC/procgen/data/assets/misc_assets/enemyFloating_4.png
new file mode 100644
index 0000000..59ea433
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyFloating_4.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyFlying_1.png b/procgenAISC/procgen/data/assets/misc_assets/enemyFlying_1.png
new file mode 100644
index 0000000..5ce6cbf
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyFlying_1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyFlying_2.png b/procgenAISC/procgen/data/assets/misc_assets/enemyFlying_2.png
new file mode 100644
index 0000000..9fbfa5d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyFlying_2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyFlying_3.png b/procgenAISC/procgen/data/assets/misc_assets/enemyFlying_3.png
new file mode 100644
index 0000000..1253061
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyFlying_3.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyFlying_4.png b/procgenAISC/procgen/data/assets/misc_assets/enemyFlying_4.png
new file mode 100644
index 0000000..9f1c941
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyFlying_4.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlack1.png b/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlack1.png
new file mode 100644
index 0000000..f152dc7
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlack1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlack2.png b/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlack2.png
new file mode 100644
index 0000000..f4e1666
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlack2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlack3.png b/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlack3.png
new file mode 100644
index 0000000..2ef3c8d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlack3.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlack4.png b/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlack4.png
new file mode 100644
index 0000000..c1a357f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlack4.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlack5.png b/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlack5.png
new file mode 100644
index 0000000..25c8c1c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlack5.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlue1.png b/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlue1.png
new file mode 100644
index 0000000..e2dee30
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlue1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlue2.png b/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlue2.png
new file mode 100644
index 0000000..74ffe35
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlue2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlue3.png b/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlue3.png
new file mode 100644
index 0000000..157abe4
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlue3.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlue4.png b/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlue4.png
new file mode 100644
index 0000000..b87b1a3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlue4.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlue5.png b/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlue5.png
new file mode 100644
index 0000000..618b5e3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyShipBlue5.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyShipGreen1.png b/procgenAISC/procgen/data/assets/misc_assets/enemyShipGreen1.png
new file mode 100644
index 0000000..4f8b7de
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyShipGreen1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyShipGreen2.png b/procgenAISC/procgen/data/assets/misc_assets/enemyShipGreen2.png
new file mode 100644
index 0000000..54463a6
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyShipGreen2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyShipGreen3.png b/procgenAISC/procgen/data/assets/misc_assets/enemyShipGreen3.png
new file mode 100644
index 0000000..6d2af31
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyShipGreen3.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyShipGreen4.png b/procgenAISC/procgen/data/assets/misc_assets/enemyShipGreen4.png
new file mode 100644
index 0000000..6db472c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyShipGreen4.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyShipGreen5.png b/procgenAISC/procgen/data/assets/misc_assets/enemyShipGreen5.png
new file mode 100644
index 0000000..9d1380d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyShipGreen5.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyShipRed1.png b/procgenAISC/procgen/data/assets/misc_assets/enemyShipRed1.png
new file mode 100644
index 0000000..9ba3cec
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyShipRed1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyShipRed2.png b/procgenAISC/procgen/data/assets/misc_assets/enemyShipRed2.png
new file mode 100644
index 0000000..984e992
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyShipRed2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyShipRed3.png b/procgenAISC/procgen/data/assets/misc_assets/enemyShipRed3.png
new file mode 100644
index 0000000..bc539df
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyShipRed3.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyShipRed4.png b/procgenAISC/procgen/data/assets/misc_assets/enemyShipRed4.png
new file mode 100644
index 0000000..e7a7ab2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyShipRed4.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyShipRed5.png b/procgenAISC/procgen/data/assets/misc_assets/enemyShipRed5.png
new file mode 100644
index 0000000..439aee0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyShipRed5.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemySpikey_1.png b/procgenAISC/procgen/data/assets/misc_assets/enemySpikey_1.png
new file mode 100644
index 0000000..3843a7d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemySpikey_1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemySpikey_1b.png b/procgenAISC/procgen/data/assets/misc_assets/enemySpikey_1b.png
new file mode 100644
index 0000000..fc4df90
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemySpikey_1b.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemySpikey_2.png b/procgenAISC/procgen/data/assets/misc_assets/enemySpikey_2.png
new file mode 100644
index 0000000..a9e1301
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemySpikey_2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemySpikey_3.png b/procgenAISC/procgen/data/assets/misc_assets/enemySpikey_3.png
new file mode 100644
index 0000000..7c8d5fd
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemySpikey_3.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemySpikey_4.png b/procgenAISC/procgen/data/assets/misc_assets/enemySpikey_4.png
new file mode 100644
index 0000000..9640a6b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemySpikey_4.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyWalking_1.png b/procgenAISC/procgen/data/assets/misc_assets/enemyWalking_1.png
new file mode 100644
index 0000000..0586b09
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyWalking_1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyWalking_1b.png b/procgenAISC/procgen/data/assets/misc_assets/enemyWalking_1b.png
new file mode 100644
index 0000000..4d3b330
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyWalking_1b.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyWalking_2.png b/procgenAISC/procgen/data/assets/misc_assets/enemyWalking_2.png
new file mode 100644
index 0000000..047d503
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyWalking_2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyWalking_3.png b/procgenAISC/procgen/data/assets/misc_assets/enemyWalking_3.png
new file mode 100644
index 0000000..0991893
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyWalking_3.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/enemyWalking_4.png b/procgenAISC/procgen/data/assets/misc_assets/enemyWalking_4.png
new file mode 100644
index 0000000..ae54731
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/enemyWalking_4.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/explosion1.png b/procgenAISC/procgen/data/assets/misc_assets/explosion1.png
new file mode 100644
index 0000000..7727512
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/explosion1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/explosion2.png b/procgenAISC/procgen/data/assets/misc_assets/explosion2.png
new file mode 100644
index 0000000..93af501
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/explosion2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/explosion3.png b/procgenAISC/procgen/data/assets/misc_assets/explosion3.png
new file mode 100644
index 0000000..264af70
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/explosion3.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/explosion4.png b/procgenAISC/procgen/data/assets/misc_assets/explosion4.png
new file mode 100644
index 0000000..512adc5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/explosion4.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/explosion5.png b/procgenAISC/procgen/data/assets/misc_assets/explosion5.png
new file mode 100644
index 0000000..57efb5a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/explosion5.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/fenceYellow.png b/procgenAISC/procgen/data/assets/misc_assets/fenceYellow.png
new file mode 100644
index 0000000..5359cd2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/fenceYellow.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/fence_single.png b/procgenAISC/procgen/data/assets/misc_assets/fence_single.png
new file mode 100644
index 0000000..f636d40
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/fence_single.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/finish.png b/procgenAISC/procgen/data/assets/misc_assets/finish.png
new file mode 100644
index 0000000..41a019a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/finish.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/finish2.png b/procgenAISC/procgen/data/assets/misc_assets/finish2.png
new file mode 100644
index 0000000..6506c9b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/finish2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/fire1.png b/procgenAISC/procgen/data/assets/misc_assets/fire1.png
new file mode 100644
index 0000000..7fa7f33
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/fire1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/fire_1.png b/procgenAISC/procgen/data/assets/misc_assets/fire_1.png
new file mode 100644
index 0000000..9ba0764
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/fire_1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/fire_2.png b/procgenAISC/procgen/data/assets/misc_assets/fire_2.png
new file mode 100644
index 0000000..521aa10
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/fire_2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/fire_3.png b/procgenAISC/procgen/data/assets/misc_assets/fire_3.png
new file mode 100644
index 0000000..5386ae8
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/fire_3.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/fire_4.png b/procgenAISC/procgen/data/assets/misc_assets/fire_4.png
new file mode 100644
index 0000000..3838c5d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/fire_4.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/fire_5.png b/procgenAISC/procgen/data/assets/misc_assets/fire_5.png
new file mode 100644
index 0000000..9342e89
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/fire_5.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/fire_6.png b/procgenAISC/procgen/data/assets/misc_assets/fire_6.png
new file mode 100644
index 0000000..5a10983
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/fire_6.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/fireball.png b/procgenAISC/procgen/data/assets/misc_assets/fireball.png
new file mode 100644
index 0000000..037b035
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/fireball.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/fishTile_072.png b/procgenAISC/procgen/data/assets/misc_assets/fishTile_072.png
new file mode 100644
index 0000000..a301513
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/fishTile_072.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/fishTile_074.png b/procgenAISC/procgen/data/assets/misc_assets/fishTile_074.png
new file mode 100644
index 0000000..ec21afa
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/fishTile_074.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/fishTile_076.png b/procgenAISC/procgen/data/assets/misc_assets/fishTile_076.png
new file mode 100644
index 0000000..9881615
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/fishTile_076.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/fishTile_078.png b/procgenAISC/procgen/data/assets/misc_assets/fishTile_078.png
new file mode 100644
index 0000000..6883ad3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/fishTile_078.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/fishTile_080.png b/procgenAISC/procgen/data/assets/misc_assets/fishTile_080.png
new file mode 100644
index 0000000..95772fb
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/fishTile_080.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/food1.png b/procgenAISC/procgen/data/assets/misc_assets/food1.png
new file mode 100644
index 0000000..63fb653
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/food1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/food2.png b/procgenAISC/procgen/data/assets/misc_assets/food2.png
new file mode 100644
index 0000000..a3ce44f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/food2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/food3.png b/procgenAISC/procgen/data/assets/misc_assets/food3.png
new file mode 100644
index 0000000..eee1b58
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/food3.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/food4.png b/procgenAISC/procgen/data/assets/misc_assets/food4.png
new file mode 100644
index 0000000..8ebb90f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/food4.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/food5.png b/procgenAISC/procgen/data/assets/misc_assets/food5.png
new file mode 100644
index 0000000..fd729fd
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/food5.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/food6.png b/procgenAISC/procgen/data/assets/misc_assets/food6.png
new file mode 100644
index 0000000..1a09fd8
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/food6.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/frog1.png b/procgenAISC/procgen/data/assets/misc_assets/frog1.png
new file mode 100644
index 0000000..9c181ab
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/frog1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/frog2.png b/procgenAISC/procgen/data/assets/misc_assets/frog2.png
new file mode 100644
index 0000000..aba43a3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/frog2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/frog3.png b/procgenAISC/procgen/data/assets/misc_assets/frog3.png
new file mode 100644
index 0000000..81e32a5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/frog3.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/frog4.png b/procgenAISC/procgen/data/assets/misc_assets/frog4.png
new file mode 100644
index 0000000..dca1d14
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/frog4.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/frog5.png b/procgenAISC/procgen/data/assets/misc_assets/frog5.png
new file mode 100644
index 0000000..07b2d97
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/frog5.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/frog6.png b/procgenAISC/procgen/data/assets/misc_assets/frog6.png
new file mode 100644
index 0000000..58a4fb1
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/frog6.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/frog7.png b/procgenAISC/procgen/data/assets/misc_assets/frog7.png
new file mode 100644
index 0000000..b2300a3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/frog7.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/fruit1.png b/procgenAISC/procgen/data/assets/misc_assets/fruit1.png
new file mode 100644
index 0000000..90569d3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/fruit1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/fruit2.png b/procgenAISC/procgen/data/assets/misc_assets/fruit2.png
new file mode 100644
index 0000000..452d52b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/fruit2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/fruit3.png b/procgenAISC/procgen/data/assets/misc_assets/fruit3.png
new file mode 100644
index 0000000..7698ae0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/fruit3.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/fruit4.png b/procgenAISC/procgen/data/assets/misc_assets/fruit4.png
new file mode 100644
index 0000000..e3be326
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/fruit4.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/fruit5.png b/procgenAISC/procgen/data/assets/misc_assets/fruit5.png
new file mode 100644
index 0000000..c6e9f61
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/fruit5.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/fruit6.png b/procgenAISC/procgen/data/assets/misc_assets/fruit6.png
new file mode 100644
index 0000000..bc13c58
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/fruit6.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/gemBlue.png b/procgenAISC/procgen/data/assets/misc_assets/gemBlue.png
new file mode 100644
index 0000000..f6ee7cc
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/gemBlue.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/gemYellow.png b/procgenAISC/procgen/data/assets/misc_assets/gemYellow.png
new file mode 100644
index 0000000..5e79cc5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/gemYellow.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/genericItem_color_001.png b/procgenAISC/procgen/data/assets/misc_assets/genericItem_color_001.png
new file mode 100644
index 0000000..9f7443d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/genericItem_color_001.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/genericItem_color_002.png b/procgenAISC/procgen/data/assets/misc_assets/genericItem_color_002.png
new file mode 100644
index 0000000..84954ab
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/genericItem_color_002.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/genericItem_color_003.png b/procgenAISC/procgen/data/assets/misc_assets/genericItem_color_003.png
new file mode 100644
index 0000000..c2dd923
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/genericItem_color_003.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/genericItem_color_004.png b/procgenAISC/procgen/data/assets/misc_assets/genericItem_color_004.png
new file mode 100644
index 0000000..8a55028
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/genericItem_color_004.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/genericItem_color_005.png b/procgenAISC/procgen/data/assets/misc_assets/genericItem_color_005.png
new file mode 100644
index 0000000..9a5604e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/genericItem_color_005.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/genericItem_color_006.png b/procgenAISC/procgen/data/assets/misc_assets/genericItem_color_006.png
new file mode 100644
index 0000000..7c99258
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/genericItem_color_006.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/groundA.png b/procgenAISC/procgen/data/assets/misc_assets/groundA.png
new file mode 100644
index 0000000..f6458f0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/groundA.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/groundB.png b/procgenAISC/procgen/data/assets/misc_assets/groundB.png
new file mode 100644
index 0000000..d595bdc
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/groundB.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/groundC.png b/procgenAISC/procgen/data/assets/misc_assets/groundC.png
new file mode 100644
index 0000000..b635b6f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/groundC.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/iconCircle_white.png b/procgenAISC/procgen/data/assets/misc_assets/iconCircle_white.png
new file mode 100644
index 0000000..c317295
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/iconCircle_white.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/keyBlue.png b/procgenAISC/procgen/data/assets/misc_assets/keyBlue.png
new file mode 100644
index 0000000..093ec81
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/keyBlue.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/keyGreen.png b/procgenAISC/procgen/data/assets/misc_assets/keyGreen.png
new file mode 100644
index 0000000..9858b07
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/keyGreen.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/keyRed.png b/procgenAISC/procgen/data/assets/misc_assets/keyRed.png
new file mode 100644
index 0000000..6d3abd4
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/keyRed.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/keyRed2.png b/procgenAISC/procgen/data/assets/misc_assets/keyRed2.png
new file mode 100644
index 0000000..c8d2abb
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/keyRed2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/ladder_small.png b/procgenAISC/procgen/data/assets/misc_assets/ladder_small.png
new file mode 100644
index 0000000..a41d680
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/ladder_small.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/laserBlue02.png b/procgenAISC/procgen/data/assets/misc_assets/laserBlue02.png
new file mode 100644
index 0000000..f6be5f9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/laserBlue02.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/laserBlue09.png b/procgenAISC/procgen/data/assets/misc_assets/laserBlue09.png
new file mode 100644
index 0000000..55c3074
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/laserBlue09.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/laserGreen14.png b/procgenAISC/procgen/data/assets/misc_assets/laserGreen14.png
new file mode 100644
index 0000000..740ed39
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/laserGreen14.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/laserRed11.png b/procgenAISC/procgen/data/assets/misc_assets/laserRed11.png
new file mode 100644
index 0000000..e689bf8
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/laserRed11.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/lockRed2.png b/procgenAISC/procgen/data/assets/misc_assets/lockRed2.png
new file mode 100644
index 0000000..857901a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/lockRed2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/lock_blue.png b/procgenAISC/procgen/data/assets/misc_assets/lock_blue.png
new file mode 100644
index 0000000..72d3f40
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/lock_blue.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/lock_green.png b/procgenAISC/procgen/data/assets/misc_assets/lock_green.png
new file mode 100644
index 0000000..ea2182f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/lock_green.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/lock_red.png b/procgenAISC/procgen/data/assets/misc_assets/lock_red.png
new file mode 100644
index 0000000..b5faca0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/lock_red.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/manBlue_silencer.png b/procgenAISC/procgen/data/assets/misc_assets/manBlue_silencer.png
new file mode 100644
index 0000000..31baa6c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/manBlue_silencer.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/meteorBrown_big1.png b/procgenAISC/procgen/data/assets/misc_assets/meteorBrown_big1.png
new file mode 100644
index 0000000..60671d6
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/meteorBrown_big1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/meteorBrown_big2.png b/procgenAISC/procgen/data/assets/misc_assets/meteorBrown_big2.png
new file mode 100644
index 0000000..69a1eca
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/meteorBrown_big2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/meteorBrown_big3.png b/procgenAISC/procgen/data/assets/misc_assets/meteorBrown_big3.png
new file mode 100644
index 0000000..6cf2873
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/meteorBrown_big3.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/meteorBrown_big4.png b/procgenAISC/procgen/data/assets/misc_assets/meteorBrown_big4.png
new file mode 100644
index 0000000..c57f5cb
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/meteorBrown_big4.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/meteorGrey_big1.png b/procgenAISC/procgen/data/assets/misc_assets/meteorGrey_big1.png
new file mode 100644
index 0000000..9e02a6e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/meteorGrey_big1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/meteorGrey_big2.png b/procgenAISC/procgen/data/assets/misc_assets/meteorGrey_big2.png
new file mode 100644
index 0000000..86cb03b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/meteorGrey_big2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/meteorGrey_big3.png b/procgenAISC/procgen/data/assets/misc_assets/meteorGrey_big3.png
new file mode 100644
index 0000000..234af44
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/meteorGrey_big3.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/meteorGrey_big4.png b/procgenAISC/procgen/data/assets/misc_assets/meteorGrey_big4.png
new file mode 100644
index 0000000..4ef66f6
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/meteorGrey_big4.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/panel_wood.png b/procgenAISC/procgen/data/assets/misc_assets/panel_wood.png
new file mode 100644
index 0000000..0ce6495
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/panel_wood.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/playerShip1_blue.png b/procgenAISC/procgen/data/assets/misc_assets/playerShip1_blue.png
new file mode 100644
index 0000000..63b9c40
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/playerShip1_blue.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/playerShip1_green.png b/procgenAISC/procgen/data/assets/misc_assets/playerShip1_green.png
new file mode 100644
index 0000000..a8f9e15
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/playerShip1_green.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/playerShip1_orange.png b/procgenAISC/procgen/data/assets/misc_assets/playerShip1_orange.png
new file mode 100644
index 0000000..92d6b40
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/playerShip1_orange.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/playerShip1_red.png b/procgenAISC/procgen/data/assets/misc_assets/playerShip1_red.png
new file mode 100644
index 0000000..e32ea38
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/playerShip1_red.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/playerShip2_blue.png b/procgenAISC/procgen/data/assets/misc_assets/playerShip2_blue.png
new file mode 100644
index 0000000..3f0f500
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/playerShip2_blue.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/playerShip2_green.png b/procgenAISC/procgen/data/assets/misc_assets/playerShip2_green.png
new file mode 100644
index 0000000..8abb4ea
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/playerShip2_green.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/playerShip2_orange.png b/procgenAISC/procgen/data/assets/misc_assets/playerShip2_orange.png
new file mode 100644
index 0000000..fcad7f2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/playerShip2_orange.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/playerShip2_red.png b/procgenAISC/procgen/data/assets/misc_assets/playerShip2_red.png
new file mode 100644
index 0000000..c9b858a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/playerShip2_red.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/playerShip3_blue.png b/procgenAISC/procgen/data/assets/misc_assets/playerShip3_blue.png
new file mode 100644
index 0000000..45ccc22
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/playerShip3_blue.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/playerShip3_green.png b/procgenAISC/procgen/data/assets/misc_assets/playerShip3_green.png
new file mode 100644
index 0000000..c845010
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/playerShip3_green.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/playerShip3_orange.png b/procgenAISC/procgen/data/assets/misc_assets/playerShip3_orange.png
new file mode 100644
index 0000000..1c3884e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/playerShip3_orange.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/playerShip3_red.png b/procgenAISC/procgen/data/assets/misc_assets/playerShip3_red.png
new file mode 100644
index 0000000..e03fbab
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/playerShip3_red.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/powerupRed_star.png b/procgenAISC/procgen/data/assets/misc_assets/powerupRed_star.png
new file mode 100644
index 0000000..743bacc
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/powerupRed_star.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/present1.png b/procgenAISC/procgen/data/assets/misc_assets/present1.png
new file mode 100644
index 0000000..cbf40c7
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/present1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/present2.png b/procgenAISC/procgen/data/assets/misc_assets/present2.png
new file mode 100644
index 0000000..066649d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/present2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/present3.png b/procgenAISC/procgen/data/assets/misc_assets/present3.png
new file mode 100644
index 0000000..712af8d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/present3.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/roadTile6.png b/procgenAISC/procgen/data/assets/misc_assets/roadTile6.png
new file mode 100644
index 0000000..0221439
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/roadTile6.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/roadTile6b.png b/procgenAISC/procgen/data/assets/misc_assets/roadTile6b.png
new file mode 100644
index 0000000..115e550
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/roadTile6b.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/robot_3Dblue.png b/procgenAISC/procgen/data/assets/misc_assets/robot_3Dblue.png
new file mode 100644
index 0000000..e821580
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/robot_3Dblue.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/robot_greenDrive1.png b/procgenAISC/procgen/data/assets/misc_assets/robot_greenDrive1.png
new file mode 100644
index 0000000..10f3f6b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/robot_greenDrive1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/saw.png b/procgenAISC/procgen/data/assets/misc_assets/saw.png
new file mode 100644
index 0000000..4494ec7
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/saw.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/shield2.png b/procgenAISC/procgen/data/assets/misc_assets/shield2.png
new file mode 100644
index 0000000..8488022
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/shield2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/ship_1.png b/procgenAISC/procgen/data/assets/misc_assets/ship_1.png
new file mode 100644
index 0000000..0e46641
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/ship_1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/ship_2.png b/procgenAISC/procgen/data/assets/misc_assets/ship_2.png
new file mode 100644
index 0000000..8dda358
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/ship_2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/ship_3.png b/procgenAISC/procgen/data/assets/misc_assets/ship_3.png
new file mode 100644
index 0000000..6944f09
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/ship_3.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/ship_4.png b/procgenAISC/procgen/data/assets/misc_assets/ship_4.png
new file mode 100644
index 0000000..69575a8
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/ship_4.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/ship_5.png b/procgenAISC/procgen/data/assets/misc_assets/ship_5.png
new file mode 100644
index 0000000..71cea39
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/ship_5.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/ship_6.png b/procgenAISC/procgen/data/assets/misc_assets/ship_6.png
new file mode 100644
index 0000000..284cc69
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/ship_6.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceAstronauts_008.png b/procgenAISC/procgen/data/assets/misc_assets/spaceAstronauts_008.png
new file mode 100644
index 0000000..e0d23de
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceAstronauts_008.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceEffect1.png b/procgenAISC/procgen/data/assets/misc_assets/spaceEffect1.png
new file mode 100644
index 0000000..e7aa163
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceEffect1.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceEffect2.png b/procgenAISC/procgen/data/assets/misc_assets/spaceEffect2.png
new file mode 100644
index 0000000..79d844d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceEffect2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceEffect3.png b/procgenAISC/procgen/data/assets/misc_assets/spaceEffect3.png
new file mode 100644
index 0000000..bfb11f4
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceEffect3.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceEffect4.png b/procgenAISC/procgen/data/assets/misc_assets/spaceEffect4.png
new file mode 100644
index 0000000..498f058
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceEffect4.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceEffect5.png b/procgenAISC/procgen/data/assets/misc_assets/spaceEffect5.png
new file mode 100644
index 0000000..f3507a6
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceEffect5.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceEffect6.png b/procgenAISC/procgen/data/assets/misc_assets/spaceEffect6.png
new file mode 100644
index 0000000..2e29157
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceEffect6.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceEffect7.png b/procgenAISC/procgen/data/assets/misc_assets/spaceEffect7.png
new file mode 100644
index 0000000..18394d5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceEffect7.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceEffect8.png b/procgenAISC/procgen/data/assets/misc_assets/spaceEffect8.png
new file mode 100644
index 0000000..88dbe2a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceEffect8.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceEffect9.png b/procgenAISC/procgen/data/assets/misc_assets/spaceEffect9.png
new file mode 100644
index 0000000..a7df8ba
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceEffect9.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceMeteors_001.png b/procgenAISC/procgen/data/assets/misc_assets/spaceMeteors_001.png
new file mode 100644
index 0000000..be2cfba
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceMeteors_001.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceMeteors_002.png b/procgenAISC/procgen/data/assets/misc_assets/spaceMeteors_002.png
new file mode 100644
index 0000000..16af3ed
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceMeteors_002.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceMeteors_003.png b/procgenAISC/procgen/data/assets/misc_assets/spaceMeteors_003.png
new file mode 100644
index 0000000..90b3027
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceMeteors_003.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceMeteors_004.png b/procgenAISC/procgen/data/assets/misc_assets/spaceMeteors_004.png
new file mode 100644
index 0000000..2566449
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceMeteors_004.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceRockets_001.png b/procgenAISC/procgen/data/assets/misc_assets/spaceRockets_001.png
new file mode 100644
index 0000000..6a432da
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceRockets_001.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceRockets_002.png b/procgenAISC/procgen/data/assets/misc_assets/spaceRockets_002.png
new file mode 100644
index 0000000..6449e85
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceRockets_002.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceRockets_003.png b/procgenAISC/procgen/data/assets/misc_assets/spaceRockets_003.png
new file mode 100644
index 0000000..33aba2d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceRockets_003.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceRockets_004.png b/procgenAISC/procgen/data/assets/misc_assets/spaceRockets_004.png
new file mode 100644
index 0000000..730aa6a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceRockets_004.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceShips_001.png b/procgenAISC/procgen/data/assets/misc_assets/spaceShips_001.png
new file mode 100644
index 0000000..d7a4f02
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceShips_001.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceShips_002.png b/procgenAISC/procgen/data/assets/misc_assets/spaceShips_002.png
new file mode 100644
index 0000000..75809c6
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceShips_002.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceShips_003.png b/procgenAISC/procgen/data/assets/misc_assets/spaceShips_003.png
new file mode 100644
index 0000000..e68518f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceShips_003.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceShips_004.png b/procgenAISC/procgen/data/assets/misc_assets/spaceShips_004.png
new file mode 100644
index 0000000..160378f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceShips_004.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceShips_005.png b/procgenAISC/procgen/data/assets/misc_assets/spaceShips_005.png
new file mode 100644
index 0000000..07f156a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceShips_005.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceShips_006.png b/procgenAISC/procgen/data/assets/misc_assets/spaceShips_006.png
new file mode 100644
index 0000000..2c2ef97
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceShips_006.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceShips_007.png b/procgenAISC/procgen/data/assets/misc_assets/spaceShips_007.png
new file mode 100644
index 0000000..61d9608
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceShips_007.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceShips_008.png b/procgenAISC/procgen/data/assets/misc_assets/spaceShips_008.png
new file mode 100644
index 0000000..e7e3dc3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceShips_008.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceShips_009.png b/procgenAISC/procgen/data/assets/misc_assets/spaceShips_009.png
new file mode 100644
index 0000000..6c57a52
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceShips_009.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceStation_018.png b/procgenAISC/procgen/data/assets/misc_assets/spaceStation_018.png
new file mode 100644
index 0000000..374ce16
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceStation_018.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spaceStation_019.png b/procgenAISC/procgen/data/assets/misc_assets/spaceStation_019.png
new file mode 100644
index 0000000..58d923b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spaceStation_019.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/spikeMan_stand.png b/procgenAISC/procgen/data/assets/misc_assets/spikeMan_stand.png
new file mode 100644
index 0000000..0be527e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/spikeMan_stand.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/tank_bigRed.png b/procgenAISC/procgen/data/assets/misc_assets/tank_bigRed.png
new file mode 100644
index 0000000..fac4137
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/tank_bigRed.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/tank_blue.png b/procgenAISC/procgen/data/assets/misc_assets/tank_blue.png
new file mode 100644
index 0000000..685aa8b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/tank_blue.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/tank_dark.png b/procgenAISC/procgen/data/assets/misc_assets/tank_dark.png
new file mode 100644
index 0000000..202b092
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/tank_dark.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/tank_darkLarge.png b/procgenAISC/procgen/data/assets/misc_assets/tank_darkLarge.png
new file mode 100644
index 0000000..e776978
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/tank_darkLarge.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/tank_green.png b/procgenAISC/procgen/data/assets/misc_assets/tank_green.png
new file mode 100644
index 0000000..7be97cb
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/tank_green.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/tank_huge.png b/procgenAISC/procgen/data/assets/misc_assets/tank_huge.png
new file mode 100644
index 0000000..7fe7f86
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/tank_huge.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/tank_red.png b/procgenAISC/procgen/data/assets/misc_assets/tank_red.png
new file mode 100644
index 0000000..431cb88
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/tank_red.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/tank_sand.png b/procgenAISC/procgen/data/assets/misc_assets/tank_sand.png
new file mode 100644
index 0000000..5d37aea
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/tank_sand.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/target_red2.png b/procgenAISC/procgen/data/assets/misc_assets/target_red2.png
new file mode 100644
index 0000000..328c241
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/target_red2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/terrainTile6.png b/procgenAISC/procgen/data/assets/misc_assets/terrainTile6.png
new file mode 100644
index 0000000..d992233
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/terrainTile6.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/tileStone_slope.png b/procgenAISC/procgen/data/assets/misc_assets/tileStone_slope.png
new file mode 100644
index 0000000..917da4b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/tileStone_slope.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/tileStone_slope2.png b/procgenAISC/procgen/data/assets/misc_assets/tileStone_slope2.png
new file mode 100644
index 0000000..59393ba
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/tileStone_slope2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/tile_316.png b/procgenAISC/procgen/data/assets/misc_assets/tile_316.png
new file mode 100644
index 0000000..dcaf0e3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/tile_316.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/tile_318.png b/procgenAISC/procgen/data/assets/misc_assets/tile_318.png
new file mode 100644
index 0000000..61466f7
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/tile_318.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/tile_bricksGrey.png b/procgenAISC/procgen/data/assets/misc_assets/tile_bricksGrey.png
new file mode 100644
index 0000000..a0b054d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/tile_bricksGrey.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/tile_bricksGrown.png b/procgenAISC/procgen/data/assets/misc_assets/tile_bricksGrown.png
new file mode 100644
index 0000000..34a9d19
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/tile_bricksGrown.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/tile_bricksRed.png b/procgenAISC/procgen/data/assets/misc_assets/tile_bricksRed.png
new file mode 100644
index 0000000..b5cce3f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/tile_bricksRed.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/towerDefense_tile203.png b/procgenAISC/procgen/data/assets/misc_assets/towerDefense_tile203.png
new file mode 100644
index 0000000..4736810
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/towerDefense_tile203.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/towerDefense_tile270.png b/procgenAISC/procgen/data/assets/misc_assets/towerDefense_tile270.png
new file mode 100644
index 0000000..229a2ef
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/towerDefense_tile270.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/towerDefense_tile295.png b/procgenAISC/procgen/data/assets/misc_assets/towerDefense_tile295.png
new file mode 100644
index 0000000..38e8471
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/towerDefense_tile295.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/towerDefense_tile296.png b/procgenAISC/procgen/data/assets/misc_assets/towerDefense_tile296.png
new file mode 100644
index 0000000..d5489d3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/towerDefense_tile296.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/towerDefense_tile297.png b/procgenAISC/procgen/data/assets/misc_assets/towerDefense_tile297.png
new file mode 100644
index 0000000..ff5b1ee
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/towerDefense_tile297.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/towerDefense_tile298.png b/procgenAISC/procgen/data/assets/misc_assets/towerDefense_tile298.png
new file mode 100644
index 0000000..f3b0b3b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/towerDefense_tile298.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/ufoGreen.png b/procgenAISC/procgen/data/assets/misc_assets/ufoGreen.png
new file mode 100644
index 0000000..4a26785
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/ufoGreen.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/ufoGreen2.png b/procgenAISC/procgen/data/assets/misc_assets/ufoGreen2.png
new file mode 100644
index 0000000..e667927
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/ufoGreen2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/ufoRed.png b/procgenAISC/procgen/data/assets/misc_assets/ufoRed.png
new file mode 100644
index 0000000..ea39f85
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/ufoRed.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/ufoRed2.png b/procgenAISC/procgen/data/assets/misc_assets/ufoRed2.png
new file mode 100644
index 0000000..1439d47
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/ufoRed2.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/window.png b/procgenAISC/procgen/data/assets/misc_assets/window.png
new file mode 100644
index 0000000..3315b25
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/window.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/yellowCrystal.png b/procgenAISC/procgen/data/assets/misc_assets/yellowCrystal.png
new file mode 100644
index 0000000..0c3d771
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/yellowCrystal.png differ
diff --git a/procgenAISC/procgen/data/assets/misc_assets/zombie2_silencer.png b/procgenAISC/procgen/data/assets/misc_assets/zombie2_silencer.png
new file mode 100644
index 0000000..209096e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/misc_assets/zombie2_silencer.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/airadventurelevel1.png b/procgenAISC/procgen/data/assets/platform_backgrounds/airadventurelevel1.png
new file mode 100644
index 0000000..c00a851
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/airadventurelevel1.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/airadventurelevel2.png b/procgenAISC/procgen/data/assets/platform_backgrounds/airadventurelevel2.png
new file mode 100644
index 0000000..e8fbb37
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/airadventurelevel2.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/airadventurelevel3.png b/procgenAISC/procgen/data/assets/platform_backgrounds/airadventurelevel3.png
new file mode 100644
index 0000000..6b218aa
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/airadventurelevel3.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/airadventurelevel4.png b/procgenAISC/procgen/data/assets/platform_backgrounds/airadventurelevel4.png
new file mode 100644
index 0000000..0e0aaca
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/airadventurelevel4.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/alien_bg.png b/procgenAISC/procgen/data/assets/platform_backgrounds/alien_bg.png
new file mode 100644
index 0000000..10da825
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/alien_bg.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/another_world_bg.png b/procgenAISC/procgen/data/assets/platform_backgrounds/another_world_bg.png
new file mode 100644
index 0000000..d7bfe8f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/another_world_bg.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/back_cave.png b/procgenAISC/procgen/data/assets/platform_backgrounds/back_cave.png
new file mode 100644
index 0000000..7133a63
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/back_cave.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/battleback1.png b/procgenAISC/procgen/data/assets/platform_backgrounds/battleback1.png
new file mode 100644
index 0000000..26f2498
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/battleback1.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/battleback10.png b/procgenAISC/procgen/data/assets/platform_backgrounds/battleback10.png
new file mode 100644
index 0000000..301d545
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/battleback10.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/battleback2.png b/procgenAISC/procgen/data/assets/platform_backgrounds/battleback2.png
new file mode 100644
index 0000000..170a4e9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/battleback2.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/battleback3.png b/procgenAISC/procgen/data/assets/platform_backgrounds/battleback3.png
new file mode 100644
index 0000000..11fb6c1
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/battleback3.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/battleback4.png b/procgenAISC/procgen/data/assets/platform_backgrounds/battleback4.png
new file mode 100644
index 0000000..a48058b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/battleback4.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/battleback5.png b/procgenAISC/procgen/data/assets/platform_backgrounds/battleback5.png
new file mode 100644
index 0000000..902b9c2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/battleback5.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/battleback6.png b/procgenAISC/procgen/data/assets/platform_backgrounds/battleback6.png
new file mode 100644
index 0000000..d371701
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/battleback6.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/battleback7.png b/procgenAISC/procgen/data/assets/platform_backgrounds/battleback7.png
new file mode 100644
index 0000000..a2ec503
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/battleback7.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/battleback8.png b/procgenAISC/procgen/data/assets/platform_backgrounds/battleback8.png
new file mode 100644
index 0000000..106e8c2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/battleback8.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/battleback9.png b/procgenAISC/procgen/data/assets/platform_backgrounds/battleback9.png
new file mode 100644
index 0000000..92d38aa
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/battleback9.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/blue_desert.png b/procgenAISC/procgen/data/assets/platform_backgrounds/blue_desert.png
new file mode 100644
index 0000000..7e8e078
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/blue_desert.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/blue_grass.png b/procgenAISC/procgen/data/assets/platform_backgrounds/blue_grass.png
new file mode 100644
index 0000000..cf470c9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/blue_grass.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/blue_land.png b/procgenAISC/procgen/data/assets/platform_backgrounds/blue_land.png
new file mode 100644
index 0000000..5f33d67
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/blue_land.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/blue_shroom.png b/procgenAISC/procgen/data/assets/platform_backgrounds/blue_shroom.png
new file mode 100644
index 0000000..932291e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/blue_shroom.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/cave_background.png b/procgenAISC/procgen/data/assets/platform_backgrounds/cave_background.png
new file mode 100644
index 0000000..2103ebf
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/cave_background.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/caverns.png b/procgenAISC/procgen/data/assets/platform_backgrounds/caverns.png
new file mode 100644
index 0000000..24756de
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/caverns.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/colored_desert.png b/procgenAISC/procgen/data/assets/platform_backgrounds/colored_desert.png
new file mode 100644
index 0000000..af050cd
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/colored_desert.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/colored_grass.png b/procgenAISC/procgen/data/assets/platform_backgrounds/colored_grass.png
new file mode 100644
index 0000000..8469d4a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/colored_grass.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/colored_land.png b/procgenAISC/procgen/data/assets/platform_backgrounds/colored_land.png
new file mode 100644
index 0000000..a6ffcd3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/colored_land.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/colored_shroom.png b/procgenAISC/procgen/data/assets/platform_backgrounds/colored_shroom.png
new file mode 100644
index 0000000..38d1458
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/colored_shroom.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/cyberpunk_bg.png b/procgenAISC/procgen/data/assets/platform_backgrounds/cyberpunk_bg.png
new file mode 100644
index 0000000..611aeb1
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/cyberpunk_bg.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/landscape1.png b/procgenAISC/procgen/data/assets/platform_backgrounds/landscape1.png
new file mode 100644
index 0000000..a52ad14
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/landscape1.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/landscape2.png b/procgenAISC/procgen/data/assets/platform_backgrounds/landscape2.png
new file mode 100644
index 0000000..df59886
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/landscape2.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/landscape3.png b/procgenAISC/procgen/data/assets/platform_backgrounds/landscape3.png
new file mode 100644
index 0000000..714f515
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/landscape3.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/landscape4.png b/procgenAISC/procgen/data/assets/platform_backgrounds/landscape4.png
new file mode 100644
index 0000000..df981ff
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/landscape4.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/living_tissue_bg.png b/procgenAISC/procgen/data/assets/platform_backgrounds/living_tissue_bg.png
new file mode 100644
index 0000000..87d0973
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/living_tissue_bg.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/parallax_forest.png b/procgenAISC/procgen/data/assets/platform_backgrounds/parallax_forest.png
new file mode 100644
index 0000000..181448f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/parallax_forest.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/scifi2_bg.png b/procgenAISC/procgen/data/assets/platform_backgrounds/scifi2_bg.png
new file mode 100644
index 0000000..6bc06c9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/scifi2_bg.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/scifi_bg.png b/procgenAISC/procgen/data/assets/platform_backgrounds/scifi_bg.png
new file mode 100644
index 0000000..0edd6f8
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/scifi_bg.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds/sunrise.png b/procgenAISC/procgen/data/assets/platform_backgrounds/sunrise.png
new file mode 100644
index 0000000..e4243ca
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds/sunrise.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds_2/beach1.png b/procgenAISC/procgen/data/assets/platform_backgrounds_2/beach1.png
new file mode 100644
index 0000000..288f0e8
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds_2/beach1.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds_2/beach2.png b/procgenAISC/procgen/data/assets/platform_backgrounds_2/beach2.png
new file mode 100644
index 0000000..3506f9f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds_2/beach2.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds_2/beach3.png b/procgenAISC/procgen/data/assets/platform_backgrounds_2/beach3.png
new file mode 100644
index 0000000..e66b621
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds_2/beach3.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds_2/beach4.png b/procgenAISC/procgen/data/assets/platform_backgrounds_2/beach4.png
new file mode 100644
index 0000000..ab3971c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds_2/beach4.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds_2/candy1.png b/procgenAISC/procgen/data/assets/platform_backgrounds_2/candy1.png
new file mode 100644
index 0000000..45a7e16
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds_2/candy1.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds_2/candy2.png b/procgenAISC/procgen/data/assets/platform_backgrounds_2/candy2.png
new file mode 100644
index 0000000..2d8591f
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds_2/candy2.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds_2/candy3.png b/procgenAISC/procgen/data/assets/platform_backgrounds_2/candy3.png
new file mode 100644
index 0000000..0005ad8
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds_2/candy3.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds_2/candy4.png b/procgenAISC/procgen/data/assets/platform_backgrounds_2/candy4.png
new file mode 100644
index 0000000..1878485
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds_2/candy4.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds_2/fantasy1.png b/procgenAISC/procgen/data/assets/platform_backgrounds_2/fantasy1.png
new file mode 100644
index 0000000..e2cc143
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds_2/fantasy1.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds_2/fantasy2.png b/procgenAISC/procgen/data/assets/platform_backgrounds_2/fantasy2.png
new file mode 100644
index 0000000..2079b69
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds_2/fantasy2.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds_2/fantasy3.png b/procgenAISC/procgen/data/assets/platform_backgrounds_2/fantasy3.png
new file mode 100644
index 0000000..e22aaf7
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds_2/fantasy3.png differ
diff --git a/procgenAISC/procgen/data/assets/platform_backgrounds_2/fantasy4.png b/procgenAISC/procgen/data/assets/platform_backgrounds_2/fantasy4.png
new file mode 100644
index 0000000..fae6cfc
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platform_backgrounds_2/fantasy4.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/blueCrystal.png b/procgenAISC/procgen/data/assets/platformer/blueCrystal.png
new file mode 100644
index 0000000..0e52a1e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/blueCrystal.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/enemySwimming_1.png b/procgenAISC/procgen/data/assets/platformer/enemySwimming_1.png
new file mode 100644
index 0000000..608b35d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/enemySwimming_1.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/enemySwimming_2.png b/procgenAISC/procgen/data/assets/platformer/enemySwimming_2.png
new file mode 100644
index 0000000..2c5afc9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/enemySwimming_2.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/enemySwimming_3.png b/procgenAISC/procgen/data/assets/platformer/enemySwimming_3.png
new file mode 100644
index 0000000..30eef39
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/enemySwimming_3.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/enemySwimming_4.png b/procgenAISC/procgen/data/assets/platformer/enemySwimming_4.png
new file mode 100644
index 0000000..2b89c6d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/enemySwimming_4.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/fireball.png b/procgenAISC/procgen/data/assets/platformer/fireball.png
new file mode 100644
index 0000000..e53077c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/fireball.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/greenCrystal.png b/procgenAISC/procgen/data/assets/platformer/greenCrystal.png
new file mode 100644
index 0000000..2e85d59
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/greenCrystal.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerBlue_dead.png b/procgenAISC/procgen/data/assets/platformer/playerBlue_dead.png
new file mode 100644
index 0000000..33cca3a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerBlue_dead.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerBlue_duck.png b/procgenAISC/procgen/data/assets/platformer/playerBlue_duck.png
new file mode 100644
index 0000000..8c0b2a8
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerBlue_duck.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerBlue_fall.png b/procgenAISC/procgen/data/assets/platformer/playerBlue_fall.png
new file mode 100644
index 0000000..201905d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerBlue_fall.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerBlue_hit.png b/procgenAISC/procgen/data/assets/platformer/playerBlue_hit.png
new file mode 100644
index 0000000..c4c1096
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerBlue_hit.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerBlue_roll.png b/procgenAISC/procgen/data/assets/platformer/playerBlue_roll.png
new file mode 100644
index 0000000..dc61dec
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerBlue_roll.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerBlue_stand.png b/procgenAISC/procgen/data/assets/platformer/playerBlue_stand.png
new file mode 100644
index 0000000..7ec5818
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerBlue_stand.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerBlue_swim1.png b/procgenAISC/procgen/data/assets/platformer/playerBlue_swim1.png
new file mode 100644
index 0000000..29e6ae3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerBlue_swim1.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerBlue_swim2.png b/procgenAISC/procgen/data/assets/platformer/playerBlue_swim2.png
new file mode 100644
index 0000000..22267f1
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerBlue_swim2.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerBlue_switch1.png b/procgenAISC/procgen/data/assets/platformer/playerBlue_switch1.png
new file mode 100644
index 0000000..3e6f851
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerBlue_switch1.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerBlue_switch2.png b/procgenAISC/procgen/data/assets/platformer/playerBlue_switch2.png
new file mode 100644
index 0000000..3fb063c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerBlue_switch2.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerBlue_up1.png b/procgenAISC/procgen/data/assets/platformer/playerBlue_up1.png
new file mode 100644
index 0000000..4c0948c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerBlue_up1.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerBlue_up2.png b/procgenAISC/procgen/data/assets/platformer/playerBlue_up2.png
new file mode 100644
index 0000000..5d00c76
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerBlue_up2.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerBlue_up3.png b/procgenAISC/procgen/data/assets/platformer/playerBlue_up3.png
new file mode 100644
index 0000000..ca469f3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerBlue_up3.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerBlue_walk1.png b/procgenAISC/procgen/data/assets/platformer/playerBlue_walk1.png
new file mode 100644
index 0000000..6564a3e
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerBlue_walk1.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerBlue_walk2.png b/procgenAISC/procgen/data/assets/platformer/playerBlue_walk2.png
new file mode 100644
index 0000000..131f912
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerBlue_walk2.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerBlue_walk3.png b/procgenAISC/procgen/data/assets/platformer/playerBlue_walk3.png
new file mode 100644
index 0000000..f0757f4
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerBlue_walk3.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerBlue_walk4.png b/procgenAISC/procgen/data/assets/platformer/playerBlue_walk4.png
new file mode 100644
index 0000000..2176a39
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerBlue_walk4.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerBlue_walk5.png b/procgenAISC/procgen/data/assets/platformer/playerBlue_walk5.png
new file mode 100644
index 0000000..0455137
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerBlue_walk5.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGreen_dead.png b/procgenAISC/procgen/data/assets/platformer/playerGreen_dead.png
new file mode 100644
index 0000000..8f8a393
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGreen_dead.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGreen_duck.png b/procgenAISC/procgen/data/assets/platformer/playerGreen_duck.png
new file mode 100644
index 0000000..11c2824
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGreen_duck.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGreen_fall.png b/procgenAISC/procgen/data/assets/platformer/playerGreen_fall.png
new file mode 100644
index 0000000..61e7483
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGreen_fall.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGreen_hit.png b/procgenAISC/procgen/data/assets/platformer/playerGreen_hit.png
new file mode 100644
index 0000000..48cbcca
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGreen_hit.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGreen_roll.png b/procgenAISC/procgen/data/assets/platformer/playerGreen_roll.png
new file mode 100644
index 0000000..3650dc3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGreen_roll.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGreen_stand.png b/procgenAISC/procgen/data/assets/platformer/playerGreen_stand.png
new file mode 100644
index 0000000..abfd689
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGreen_stand.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGreen_swim1.png b/procgenAISC/procgen/data/assets/platformer/playerGreen_swim1.png
new file mode 100644
index 0000000..73c3acf
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGreen_swim1.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGreen_swim2.png b/procgenAISC/procgen/data/assets/platformer/playerGreen_swim2.png
new file mode 100644
index 0000000..475b471
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGreen_swim2.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGreen_switch1.png b/procgenAISC/procgen/data/assets/platformer/playerGreen_switch1.png
new file mode 100644
index 0000000..38509b1
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGreen_switch1.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGreen_switch2.png b/procgenAISC/procgen/data/assets/platformer/playerGreen_switch2.png
new file mode 100644
index 0000000..9c21165
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGreen_switch2.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGreen_up1.png b/procgenAISC/procgen/data/assets/platformer/playerGreen_up1.png
new file mode 100644
index 0000000..1a43b2b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGreen_up1.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGreen_up2.png b/procgenAISC/procgen/data/assets/platformer/playerGreen_up2.png
new file mode 100644
index 0000000..f78a992
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGreen_up2.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGreen_up3.png b/procgenAISC/procgen/data/assets/platformer/playerGreen_up3.png
new file mode 100644
index 0000000..7196866
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGreen_up3.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGreen_walk1.png b/procgenAISC/procgen/data/assets/platformer/playerGreen_walk1.png
new file mode 100644
index 0000000..8ed1898
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGreen_walk1.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGreen_walk2.png b/procgenAISC/procgen/data/assets/platformer/playerGreen_walk2.png
new file mode 100644
index 0000000..f3f0732
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGreen_walk2.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGreen_walk3.png b/procgenAISC/procgen/data/assets/platformer/playerGreen_walk3.png
new file mode 100644
index 0000000..6733538
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGreen_walk3.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGreen_walk4.png b/procgenAISC/procgen/data/assets/platformer/playerGreen_walk4.png
new file mode 100644
index 0000000..6281c23
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGreen_walk4.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGreen_walk5.png b/procgenAISC/procgen/data/assets/platformer/playerGreen_walk5.png
new file mode 100644
index 0000000..0305fd4
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGreen_walk5.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGrey_dead.png b/procgenAISC/procgen/data/assets/platformer/playerGrey_dead.png
new file mode 100644
index 0000000..26b6a7b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGrey_dead.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGrey_duck.png b/procgenAISC/procgen/data/assets/platformer/playerGrey_duck.png
new file mode 100644
index 0000000..fc90d25
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGrey_duck.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGrey_fall.png b/procgenAISC/procgen/data/assets/platformer/playerGrey_fall.png
new file mode 100644
index 0000000..a222594
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGrey_fall.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGrey_hit.png b/procgenAISC/procgen/data/assets/platformer/playerGrey_hit.png
new file mode 100644
index 0000000..9803400
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGrey_hit.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGrey_roll.png b/procgenAISC/procgen/data/assets/platformer/playerGrey_roll.png
new file mode 100644
index 0000000..f77139d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGrey_roll.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGrey_stand.png b/procgenAISC/procgen/data/assets/platformer/playerGrey_stand.png
new file mode 100644
index 0000000..ab30cc5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGrey_stand.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGrey_swim1.png b/procgenAISC/procgen/data/assets/platformer/playerGrey_swim1.png
new file mode 100644
index 0000000..3c5ee22
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGrey_swim1.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGrey_swim2.png b/procgenAISC/procgen/data/assets/platformer/playerGrey_swim2.png
new file mode 100644
index 0000000..cd9148d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGrey_swim2.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGrey_switch1.png b/procgenAISC/procgen/data/assets/platformer/playerGrey_switch1.png
new file mode 100644
index 0000000..aa3be5a
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGrey_switch1.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGrey_switch2.png b/procgenAISC/procgen/data/assets/platformer/playerGrey_switch2.png
new file mode 100644
index 0000000..8ad4d2d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGrey_switch2.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGrey_up1.png b/procgenAISC/procgen/data/assets/platformer/playerGrey_up1.png
new file mode 100644
index 0000000..2c057ce
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGrey_up1.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGrey_up2.png b/procgenAISC/procgen/data/assets/platformer/playerGrey_up2.png
new file mode 100644
index 0000000..c428cf0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGrey_up2.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGrey_up3.png b/procgenAISC/procgen/data/assets/platformer/playerGrey_up3.png
new file mode 100644
index 0000000..b78ecb9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGrey_up3.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGrey_walk1.png b/procgenAISC/procgen/data/assets/platformer/playerGrey_walk1.png
new file mode 100644
index 0000000..ceff9d9
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGrey_walk1.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGrey_walk2.png b/procgenAISC/procgen/data/assets/platformer/playerGrey_walk2.png
new file mode 100644
index 0000000..0c90641
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGrey_walk2.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGrey_walk3.png b/procgenAISC/procgen/data/assets/platformer/playerGrey_walk3.png
new file mode 100644
index 0000000..aec43ca
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGrey_walk3.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGrey_walk4.png b/procgenAISC/procgen/data/assets/platformer/playerGrey_walk4.png
new file mode 100644
index 0000000..eb63919
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGrey_walk4.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerGrey_walk5.png b/procgenAISC/procgen/data/assets/platformer/playerGrey_walk5.png
new file mode 100644
index 0000000..d3669b4
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerGrey_walk5.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerRed_dead.png b/procgenAISC/procgen/data/assets/platformer/playerRed_dead.png
new file mode 100644
index 0000000..4a87e25
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerRed_dead.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerRed_duck.png b/procgenAISC/procgen/data/assets/platformer/playerRed_duck.png
new file mode 100644
index 0000000..e6e6a7d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerRed_duck.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerRed_fall.png b/procgenAISC/procgen/data/assets/platformer/playerRed_fall.png
new file mode 100644
index 0000000..185e3f0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerRed_fall.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerRed_hit.png b/procgenAISC/procgen/data/assets/platformer/playerRed_hit.png
new file mode 100644
index 0000000..eea3a06
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerRed_hit.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerRed_roll.png b/procgenAISC/procgen/data/assets/platformer/playerRed_roll.png
new file mode 100644
index 0000000..108c982
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerRed_roll.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerRed_stand.png b/procgenAISC/procgen/data/assets/platformer/playerRed_stand.png
new file mode 100644
index 0000000..9ea41d6
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerRed_stand.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerRed_swim1.png b/procgenAISC/procgen/data/assets/platformer/playerRed_swim1.png
new file mode 100644
index 0000000..e075c90
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerRed_swim1.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerRed_swim2.png b/procgenAISC/procgen/data/assets/platformer/playerRed_swim2.png
new file mode 100644
index 0000000..95f00a5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerRed_swim2.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerRed_switch1.png b/procgenAISC/procgen/data/assets/platformer/playerRed_switch1.png
new file mode 100644
index 0000000..b3f5d80
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerRed_switch1.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerRed_switch2.png b/procgenAISC/procgen/data/assets/platformer/playerRed_switch2.png
new file mode 100644
index 0000000..91c2489
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerRed_switch2.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerRed_up1.png b/procgenAISC/procgen/data/assets/platformer/playerRed_up1.png
new file mode 100644
index 0000000..769d876
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerRed_up1.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerRed_up2.png b/procgenAISC/procgen/data/assets/platformer/playerRed_up2.png
new file mode 100644
index 0000000..6d9f618
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerRed_up2.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerRed_up3.png b/procgenAISC/procgen/data/assets/platformer/playerRed_up3.png
new file mode 100644
index 0000000..b273e64
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerRed_up3.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerRed_walk1.png b/procgenAISC/procgen/data/assets/platformer/playerRed_walk1.png
new file mode 100644
index 0000000..40db3cb
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerRed_walk1.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerRed_walk2.png b/procgenAISC/procgen/data/assets/platformer/playerRed_walk2.png
new file mode 100644
index 0000000..9b55ea3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerRed_walk2.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerRed_walk3.png b/procgenAISC/procgen/data/assets/platformer/playerRed_walk3.png
new file mode 100644
index 0000000..8bda058
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerRed_walk3.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerRed_walk4.png b/procgenAISC/procgen/data/assets/platformer/playerRed_walk4.png
new file mode 100644
index 0000000..ea08ce3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerRed_walk4.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/playerRed_walk5.png b/procgenAISC/procgen/data/assets/platformer/playerRed_walk5.png
new file mode 100644
index 0000000..1566553
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/playerRed_walk5.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/redCrystal.png b/procgenAISC/procgen/data/assets/platformer/redCrystal.png
new file mode 100644
index 0000000..2b69095
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/redCrystal.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/shroom1.png b/procgenAISC/procgen/data/assets/platformer/shroom1.png
new file mode 100644
index 0000000..706f04c
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/shroom1.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/shroom2.png b/procgenAISC/procgen/data/assets/platformer/shroom2.png
new file mode 100644
index 0000000..e0f627d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/shroom2.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/shroom3.png b/procgenAISC/procgen/data/assets/platformer/shroom3.png
new file mode 100644
index 0000000..1dd6549
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/shroom3.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/shroom4.png b/procgenAISC/procgen/data/assets/platformer/shroom4.png
new file mode 100644
index 0000000..2f1c689
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/shroom4.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/shroom5.png b/procgenAISC/procgen/data/assets/platformer/shroom5.png
new file mode 100644
index 0000000..36e6eba
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/shroom5.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/shroom6.png b/procgenAISC/procgen/data/assets/platformer/shroom6.png
new file mode 100644
index 0000000..0fe4214
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/shroom6.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/tileBlue_05.png b/procgenAISC/procgen/data/assets/platformer/tileBlue_05.png
new file mode 100644
index 0000000..afdffe4
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/tileBlue_05.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/tileBlue_08.png b/procgenAISC/procgen/data/assets/platformer/tileBlue_08.png
new file mode 100644
index 0000000..2328186
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/tileBlue_08.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/tileBrown_06.png b/procgenAISC/procgen/data/assets/platformer/tileBrown_06.png
new file mode 100644
index 0000000..c15b6b5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/tileBrown_06.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/tileBrown_09.png b/procgenAISC/procgen/data/assets/platformer/tileBrown_09.png
new file mode 100644
index 0000000..26eb179
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/tileBrown_09.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/tileGreen_05.png b/procgenAISC/procgen/data/assets/platformer/tileGreen_05.png
new file mode 100644
index 0000000..8ef52da
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/tileGreen_05.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/tileGreen_08.png b/procgenAISC/procgen/data/assets/platformer/tileGreen_08.png
new file mode 100644
index 0000000..36b4cd0
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/tileGreen_08.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/tileYellow_06.png b/procgenAISC/procgen/data/assets/platformer/tileYellow_06.png
new file mode 100644
index 0000000..fdc95a3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/tileYellow_06.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/tileYellow_09.png b/procgenAISC/procgen/data/assets/platformer/tileYellow_09.png
new file mode 100644
index 0000000..e24e265
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/tileYellow_09.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/yellowCrystal.png b/procgenAISC/procgen/data/assets/platformer/yellowCrystal.png
new file mode 100644
index 0000000..93d9391
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/yellowCrystal.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/zombie_idle.png b/procgenAISC/procgen/data/assets/platformer/zombie_idle.png
new file mode 100644
index 0000000..6fb46aa
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/zombie_idle.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/zombie_jump.png b/procgenAISC/procgen/data/assets/platformer/zombie_jump.png
new file mode 100644
index 0000000..5d930c2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/zombie_jump.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/zombie_walk1.png b/procgenAISC/procgen/data/assets/platformer/zombie_walk1.png
new file mode 100644
index 0000000..dcb6ec3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/zombie_walk1.png differ
diff --git a/procgenAISC/procgen/data/assets/platformer/zombie_walk2.png b/procgenAISC/procgen/data/assets/platformer/zombie_walk2.png
new file mode 100644
index 0000000..2a11698
Binary files /dev/null and b/procgenAISC/procgen/data/assets/platformer/zombie_walk2.png differ
diff --git a/procgenAISC/procgen/data/assets/space_backgrounds/Background-1.png b/procgenAISC/procgen/data/assets/space_backgrounds/Background-1.png
new file mode 100644
index 0000000..b013427
Binary files /dev/null and b/procgenAISC/procgen/data/assets/space_backgrounds/Background-1.png differ
diff --git a/procgenAISC/procgen/data/assets/space_backgrounds/Background-2.png b/procgenAISC/procgen/data/assets/space_backgrounds/Background-2.png
new file mode 100644
index 0000000..9d593e1
Binary files /dev/null and b/procgenAISC/procgen/data/assets/space_backgrounds/Background-2.png differ
diff --git a/procgenAISC/procgen/data/assets/space_backgrounds/Background-3.png b/procgenAISC/procgen/data/assets/space_backgrounds/Background-3.png
new file mode 100644
index 0000000..2999bca
Binary files /dev/null and b/procgenAISC/procgen/data/assets/space_backgrounds/Background-3.png differ
diff --git a/procgenAISC/procgen/data/assets/space_backgrounds/Background-4.png b/procgenAISC/procgen/data/assets/space_backgrounds/Background-4.png
new file mode 100644
index 0000000..75734bc
Binary files /dev/null and b/procgenAISC/procgen/data/assets/space_backgrounds/Background-4.png differ
diff --git a/procgenAISC/procgen/data/assets/space_backgrounds/deep_sky_01.png b/procgenAISC/procgen/data/assets/space_backgrounds/deep_sky_01.png
new file mode 100644
index 0000000..57b3806
Binary files /dev/null and b/procgenAISC/procgen/data/assets/space_backgrounds/deep_sky_01.png differ
diff --git a/procgenAISC/procgen/data/assets/space_backgrounds/deep_space_01.png b/procgenAISC/procgen/data/assets/space_backgrounds/deep_space_01.png
new file mode 100644
index 0000000..f6615b4
Binary files /dev/null and b/procgenAISC/procgen/data/assets/space_backgrounds/deep_space_01.png differ
diff --git a/procgenAISC/procgen/data/assets/space_backgrounds/eye_nebula_01.png b/procgenAISC/procgen/data/assets/space_backgrounds/eye_nebula_01.png
new file mode 100644
index 0000000..c57dc44
Binary files /dev/null and b/procgenAISC/procgen/data/assets/space_backgrounds/eye_nebula_01.png differ
diff --git a/procgenAISC/procgen/data/assets/space_backgrounds/ez_space_lite_01.png b/procgenAISC/procgen/data/assets/space_backgrounds/ez_space_lite_01.png
new file mode 100644
index 0000000..fc1b378
Binary files /dev/null and b/procgenAISC/procgen/data/assets/space_backgrounds/ez_space_lite_01.png differ
diff --git a/procgenAISC/procgen/data/assets/space_backgrounds/meyespace_v1_01.png b/procgenAISC/procgen/data/assets/space_backgrounds/meyespace_v1_01.png
new file mode 100644
index 0000000..d3b1622
Binary files /dev/null and b/procgenAISC/procgen/data/assets/space_backgrounds/meyespace_v1_01.png differ
diff --git a/procgenAISC/procgen/data/assets/space_backgrounds/milky_way_01.png b/procgenAISC/procgen/data/assets/space_backgrounds/milky_way_01.png
new file mode 100644
index 0000000..21c2490
Binary files /dev/null and b/procgenAISC/procgen/data/assets/space_backgrounds/milky_way_01.png differ
diff --git a/procgenAISC/procgen/data/assets/space_backgrounds/parallax-space-backgound.png b/procgenAISC/procgen/data/assets/space_backgrounds/parallax-space-backgound.png
new file mode 100644
index 0000000..08afea5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/space_backgrounds/parallax-space-backgound.png differ
diff --git a/procgenAISC/procgen/data/assets/space_backgrounds/space_nebula_01.png b/procgenAISC/procgen/data/assets/space_backgrounds/space_nebula_01.png
new file mode 100644
index 0000000..643e251
Binary files /dev/null and b/procgenAISC/procgen/data/assets/space_backgrounds/space_nebula_01.png differ
diff --git a/procgenAISC/procgen/data/assets/space_backgrounds/spacegen_01.png b/procgenAISC/procgen/data/assets/space_backgrounds/spacegen_01.png
new file mode 100644
index 0000000..5ea6f0d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/space_backgrounds/spacegen_01.png differ
diff --git a/procgenAISC/procgen/data/assets/topdown_backgrounds/backgrounddetailed1.png b/procgenAISC/procgen/data/assets/topdown_backgrounds/backgrounddetailed1.png
new file mode 100644
index 0000000..e30a2d6
Binary files /dev/null and b/procgenAISC/procgen/data/assets/topdown_backgrounds/backgrounddetailed1.png differ
diff --git a/procgenAISC/procgen/data/assets/topdown_backgrounds/backgrounddetailed2.png b/procgenAISC/procgen/data/assets/topdown_backgrounds/backgrounddetailed2.png
new file mode 100644
index 0000000..37168bb
Binary files /dev/null and b/procgenAISC/procgen/data/assets/topdown_backgrounds/backgrounddetailed2.png differ
diff --git a/procgenAISC/procgen/data/assets/topdown_backgrounds/backgrounddetailed3.png b/procgenAISC/procgen/data/assets/topdown_backgrounds/backgrounddetailed3.png
new file mode 100644
index 0000000..05b20a3
Binary files /dev/null and b/procgenAISC/procgen/data/assets/topdown_backgrounds/backgrounddetailed3.png differ
diff --git a/procgenAISC/procgen/data/assets/topdown_backgrounds/backgrounddetailed4.png b/procgenAISC/procgen/data/assets/topdown_backgrounds/backgrounddetailed4.png
new file mode 100644
index 0000000..c96565b
Binary files /dev/null and b/procgenAISC/procgen/data/assets/topdown_backgrounds/backgrounddetailed4.png differ
diff --git a/procgenAISC/procgen/data/assets/topdown_backgrounds/backgrounddetailed5.png b/procgenAISC/procgen/data/assets/topdown_backgrounds/backgrounddetailed5.png
new file mode 100644
index 0000000..5ed440d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/topdown_backgrounds/backgrounddetailed5.png differ
diff --git a/procgenAISC/procgen/data/assets/topdown_backgrounds/backgrounddetailed6.png b/procgenAISC/procgen/data/assets/topdown_backgrounds/backgrounddetailed6.png
new file mode 100644
index 0000000..742a457
Binary files /dev/null and b/procgenAISC/procgen/data/assets/topdown_backgrounds/backgrounddetailed6.png differ
diff --git a/procgenAISC/procgen/data/assets/topdown_backgrounds/backgrounddetailed7.png b/procgenAISC/procgen/data/assets/topdown_backgrounds/backgrounddetailed7.png
new file mode 100644
index 0000000..5bc7075
Binary files /dev/null and b/procgenAISC/procgen/data/assets/topdown_backgrounds/backgrounddetailed7.png differ
diff --git a/procgenAISC/procgen/data/assets/topdown_backgrounds/backgrounddetailed8.png b/procgenAISC/procgen/data/assets/topdown_backgrounds/backgrounddetailed8.png
new file mode 100644
index 0000000..55758b8
Binary files /dev/null and b/procgenAISC/procgen/data/assets/topdown_backgrounds/backgrounddetailed8.png differ
diff --git a/procgenAISC/procgen/data/assets/topdown_backgrounds/floortiles.png b/procgenAISC/procgen/data/assets/topdown_backgrounds/floortiles.png
new file mode 100644
index 0000000..27991ea
Binary files /dev/null and b/procgenAISC/procgen/data/assets/topdown_backgrounds/floortiles.png differ
diff --git a/procgenAISC/procgen/data/assets/water_backgrounds/underwater1.png b/procgenAISC/procgen/data/assets/water_backgrounds/underwater1.png
new file mode 100644
index 0000000..21a372d
Binary files /dev/null and b/procgenAISC/procgen/data/assets/water_backgrounds/underwater1.png differ
diff --git a/procgenAISC/procgen/data/assets/water_backgrounds/underwater2.png b/procgenAISC/procgen/data/assets/water_backgrounds/underwater2.png
new file mode 100644
index 0000000..d63f6b2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/water_backgrounds/underwater2.png differ
diff --git a/procgenAISC/procgen/data/assets/water_backgrounds/underwater3.png b/procgenAISC/procgen/data/assets/water_backgrounds/underwater3.png
new file mode 100644
index 0000000..a218fa2
Binary files /dev/null and b/procgenAISC/procgen/data/assets/water_backgrounds/underwater3.png differ
diff --git a/procgenAISC/procgen/data/assets/water_backgrounds/water1.png b/procgenAISC/procgen/data/assets/water_backgrounds/water1.png
new file mode 100644
index 0000000..d403e63
Binary files /dev/null and b/procgenAISC/procgen/data/assets/water_backgrounds/water1.png differ
diff --git a/procgenAISC/procgen/data/assets/water_backgrounds/water2.png b/procgenAISC/procgen/data/assets/water_backgrounds/water2.png
new file mode 100644
index 0000000..b359db6
Binary files /dev/null and b/procgenAISC/procgen/data/assets/water_backgrounds/water2.png differ
diff --git a/procgenAISC/procgen/data/assets/water_backgrounds/water3.png b/procgenAISC/procgen/data/assets/water_backgrounds/water3.png
new file mode 100644
index 0000000..31eebb5
Binary files /dev/null and b/procgenAISC/procgen/data/assets/water_backgrounds/water3.png differ
diff --git a/procgenAISC/procgen/data/assets/water_backgrounds/water4.png b/procgenAISC/procgen/data/assets/water_backgrounds/water4.png
new file mode 100644
index 0000000..e3ab004
Binary files /dev/null and b/procgenAISC/procgen/data/assets/water_backgrounds/water4.png differ
diff --git a/procgenAISC/procgen/env.py b/procgenAISC/procgen/env.py
new file mode 100644
index 0000000..c3ff62b
--- /dev/null
+++ b/procgenAISC/procgen/env.py
@@ -0,0 +1,302 @@
+import os
+import random
+from typing import Sequence, Optional, List
+
+import gym3
+from gym3.libenv import CEnv
+import numpy as np
+from .build import build
+
+try:
+    from imagecorruptions import corrupt
+except ImportError:
+    pass
+
+SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
+
+MAX_STATE_SIZE = 2 ** 20
+
+ENV_NAMES = [
+    "bigfish",
+    "bossfight",
+    "caveflyer",
+    "chaser",
+    "climber",
+    "coinrun",
+    "coinrun_mod_wall",
+    "coinrun_aisc",
+    "dodgeball",
+    "fruitbot",
+    "heist",
+    "heist_aisc_many_chests",
+    "heist_aisc_many_keys",
+    "jumper",
+    "leaper",
+    "maze",
+    "maze_fixed_size",
+    "maze_aisc",
+    "maze_yellowline",
+    "maze_redline_yellowgem",
+    "maze_yellowstar_redgem",
+    "miner",
+    "ninja",
+    "plunder",
+    "starpilot",
+]
+
+EXPLORATION_LEVEL_SEEDS = {
+    "coinrun": 1949448038,
+    "coinrun_mod_wall": 1949448038,
+    "coinrun_aisc": 1949448038,
+    "caveflyer": 1259048185,
+    "leaper": 1318677581,
+    "jumper": 1434825276,
+    "maze": 158988835,
+    "maze_fixed_size": 158988835,
+    "maze_aisc": 158988835,
+    "maze_yellowline": 158988835,
+    "maze_redline_yellowgem":158988835,
+    "maze_yellowstar_redgem":158988835,
+    "heist": 876640971,
+    "heist_aisc_many_chests": 876640971,
+    "heist_aisc_many_keys": 876640971,
+    "climber": 1561126160,
+    "ninja": 1123500215,
+}
+
+# should match DistributionMode in game.h, except for 'exploration' which is handled by Python
+DISTRIBUTION_MODE_DICT = {
+    "easy": 0,
+    "hard": 1,
+    "extreme": 2,
+    "memory": 10,
+    "exploration": 20,
+}
+
+
+def create_random_seed():
+    rand_seed = random.SystemRandom().randint(0, 2 ** 31 - 1)
+    try:
+        # force MPI processes to definitely choose different random seeds
+        from mpi4py import MPI
+
+        rand_seed = rand_seed - (rand_seed % MPI.COMM_WORLD.size) + MPI.COMM_WORLD.rank
+    except ModuleNotFoundError:
+        pass
+    return rand_seed
+
+
+class BaseProcgenEnv(CEnv):
+    """
+    Base procedurally generated environment
+    """
+
+    def __init__(
+        self,
+        num,
+        env_name,
+        options,  # ranrom_percent and other extra env options can go through here
+        debug=False,
+        rand_seed=None,
+        num_levels=0,
+        start_level=0,
+        use_sequential_levels=False,
+        debug_mode=0,
+        resource_root=None,
+        num_threads=4,
+        render_mode=None,
+    ):
+        if resource_root is None:
+            resource_root = os.path.join(SCRIPT_DIR, "data", "assets") + os.sep
+            assert os.path.exists(resource_root)
+
+        lib_dir = os.path.join(SCRIPT_DIR, "data", "prebuilt")
+        if os.path.exists(lib_dir):
+            assert any([os.path.exists(os.path.join(lib_dir, name)) for name in ["libenv.so", "libenv.dylib", "env.dll"]]), "package is installed, but the prebuilt environment library is missing"
+            assert not debug, "debug has no effect for pre-compiled library"
+        else:
+            # only compile if we don't find a pre-built binary
+            lib_dir = build(debug=debug)
+        
+        self.combos = self.get_combos()
+
+        if render_mode is None:
+            render_human = False
+        elif render_mode == "rgb_array":
+            render_human = True
+        else:
+            raise Exception(f"invalid render mode {render_mode}")
+
+        if rand_seed is None:
+            rand_seed = create_random_seed()
+
+        options.update(
+            {
+                "env_name": env_name,
+                "num_levels": num_levels,
+                "start_level": start_level,
+                "num_actions": len(self.combos),
+                "use_sequential_levels": bool(use_sequential_levels),
+                "debug_mode": debug_mode,
+                "rand_seed": rand_seed,
+                "num_threads": num_threads,
+                "render_human": render_human,
+                # these will only be used the first time an environment is created in a process
+                "resource_root": resource_root,
+            }
+        )
+
+        self.options = options
+
+        super().__init__(
+            lib_dir=lib_dir,
+            num=num,
+            options=options,
+            c_func_defs=[
+                "int get_state(libenv_env *, int, char *, int);",
+                "void set_state(libenv_env *, int, char *, int);",
+            ],
+        )
+        # don't use the dict space for actions
+        self.ac_space = self.ac_space["action"]
+
+    def get_state(self):
+        length = MAX_STATE_SIZE
+        buf = self._ffi.new(f"char[{length}]")
+        result = []
+        for env_idx in range(self.num):
+            n = self.call_c_func("get_state", env_idx, buf, length)
+            result.append(bytes(self._ffi.buffer(buf, n)))
+        return result
+
+    def set_state(self, states):
+        assert len(states) == self.num
+        for env_idx in range(self.num):
+            state = states[env_idx]
+            self.call_c_func("set_state", env_idx, state, len(state))
+
+    def get_combos(self):
+        return [
+            ("LEFT", "DOWN"),
+            ("LEFT",),
+            ("LEFT", "UP"),
+            ("DOWN",),
+            (),
+            ("UP",),
+            ("RIGHT", "DOWN"),
+            ("RIGHT",),
+            ("RIGHT", "UP"),
+            ("D",),
+            ("A",),
+            ("W",),
+            ("S",),
+            ("Q",),
+            ("E",),
+        ]
+
+    def keys_to_act(self, keys_list: Sequence[Sequence[str]]) -> List[Optional[np.ndarray]]:
+        """
+        Convert list of keys being pressed to actions, used in interactive mode
+        """
+        result = []
+        for keys in keys_list:
+            action = None
+            max_len = -1
+            for i, combo in enumerate(self.get_combos()):
+                pressed = True
+                for key in combo:
+                    if key not in keys:
+                        pressed = False
+
+                if pressed and (max_len < len(combo)):
+                    action = i
+                    max_len = len(combo)
+
+            if action is not None:
+                action = np.array([action])
+            result.append(action)
+        return result
+
+    def act(self, ac):
+        # tensorflow may return int64 actions (https://github.com/openai/gym/blob/master/gym/spaces/discrete.py#L13)
+        # so always cast actions to int32
+        return super().act({"action": ac.astype(np.int32)})
+
+
+class ProcgenGym3Env(BaseProcgenEnv):
+    """
+    gym3 interface for Procgen
+    """
+    def __init__(
+        self,
+        num,
+        env_name,
+        center_agent=True,
+        use_backgrounds=True,
+        use_monochrome_assets=False,
+        restrict_themes=False,
+        use_generated_assets=False,
+        paint_vel_info=False,
+        distribution_mode="hard",
+        random_percent=0,
+        key_penalty=0,
+        step_penalty=0,
+        rand_region=0,
+        corruption_type=None,
+        corruption_severity=1,
+        continue_after_coin=False,
+        **kwargs,
+    ):
+        self.corruption_type = corruption_type
+        self.corruption_severity = corruption_severity
+        assert (
+            distribution_mode in DISTRIBUTION_MODE_DICT
+        ), f'"{distribution_mode}" is not a valid distribution mode.'
+
+        if distribution_mode == "exploration":
+            assert (
+                env_name in EXPLORATION_LEVEL_SEEDS
+            ), f"{env_name} does not support exploration mode"
+
+            distribution_mode = DISTRIBUTION_MODE_DICT["hard"]
+            assert "num_levels" not in kwargs, "exploration mode overrides num_levels"
+            kwargs["num_levels"] = 1
+            assert "start_level" not in kwargs, "exploration mode overrides start_level"
+            kwargs["start_level"] = EXPLORATION_LEVEL_SEEDS[env_name]
+        else:
+            distribution_mode = DISTRIBUTION_MODE_DICT[distribution_mode]
+
+        options = {
+                "center_agent": bool(center_agent),
+                "use_generated_assets": bool(use_generated_assets),
+                "use_monochrome_assets": bool(use_monochrome_assets),
+                "restrict_themes": bool(restrict_themes),
+                "use_backgrounds": bool(use_backgrounds),
+                "paint_vel_info": bool(paint_vel_info),
+                "distribution_mode": distribution_mode,
+                "random_percent": int(random_percent),
+                "key_penalty": int(key_penalty),
+                "step_penalty": int(step_penalty),
+                "rand_region": int(rand_region),
+                "continue_after_coin": bool(continue_after_coin),
+            }
+        super().__init__(num, env_name, options, **kwargs)
+    
+    def observe(self):
+        """override!"""
+        obs = super().observe()
+        if self.corruption_type is not None:
+            rgb = obs[1]["rgb"]
+            rgb = [corrupt(img, severity=self.corruption_severity, corruption_name=self.corruption_type) for img in rgb]
+            rgb = np.array(rgb)
+            obs[1]["rgb"] = rgb
+        return obs
+
+
+
+
+def ProcgenEnv(num_envs, env_name, **kwargs):
+    """
+    Baselines VecEnv interface for Procgen
+    """
+    return gym3.ToBaselinesVecEnv(ProcgenGym3Env(num=num_envs, env_name=env_name, **kwargs))
diff --git a/procgenAISC/procgen/env_test.py b/procgenAISC/procgen/env_test.py
new file mode 100644
index 0000000..a409958
--- /dev/null
+++ b/procgenAISC/procgen/env_test.py
@@ -0,0 +1,69 @@
+import numpy as np
+import pytest
+from .env import ENV_NAMES
+from procgen import ProcgenGym3Env
+
+
+@pytest.mark.parametrize("env_name", ["coinrun", "starpilot"])
+def test_seeding(env_name):
+    num_envs = 1
+
+    def make_env(level_num):
+        venv = ProcgenGym3Env(
+            num=num_envs, env_name=env_name, num_levels=1, start_level=level_num
+        )
+        return venv
+
+    env1 = make_env(0)
+    env2 = make_env(0)
+    env3 = make_env(1)
+
+    env1.act(np.zeros(num_envs))
+    env2.act(np.zeros(num_envs))
+    env3.act(np.zeros(num_envs))
+
+    _, obs1, _ = env1.observe()
+    _, obs2, _ = env2.observe()
+    _, obs3, _ = env3.observe()
+
+    assert np.array_equal(obs1["rgb"], obs2["rgb"])
+    assert not np.array_equal(obs1["rgb"], obs3["rgb"])
+
+
+@pytest.mark.parametrize("env_name", ["coinrun", "starpilot"])
+def test_determinism(env_name):
+    def collect_observations():
+        rng = np.random.RandomState(0)
+        env = ProcgenGym3Env(num=2, env_name=env_name, rand_seed=23)
+        _, obs, _ = env.observe()
+        obses = [obs["rgb"]]
+        for _ in range(128):
+            env.act(
+                rng.randint(
+                    low=0, high=env.ac_space.eltype.n, size=(env.num,), dtype=np.int32
+                )
+            )
+            _, obs, _ = env.observe()
+            obses.append(obs["rgb"])
+        return np.array(obses)
+
+    obs1 = collect_observations()
+    obs2 = collect_observations()
+    assert np.array_equal(obs1, obs2)
+
+
+@pytest.mark.parametrize("env_name", ENV_NAMES)
+@pytest.mark.parametrize("num_envs", [1, 2, 16])
+def test_multi_speed(env_name, num_envs, benchmark):
+    env = ProcgenGym3Env(num=num_envs, env_name=env_name)
+
+    actions = np.zeros([env.num])
+
+    def rollout(max_steps):
+        step_count = 0
+        while step_count < max_steps:
+            env.act(actions)
+            env.observe()
+            step_count += 1
+
+    benchmark(lambda: rollout(1000))
\ No newline at end of file
diff --git a/procgenAISC/procgen/examples/__init__.py b/procgenAISC/procgen/examples/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/procgenAISC/procgen/examples/random_agent_gym.py b/procgenAISC/procgen/examples/random_agent_gym.py
new file mode 100644
index 0000000..dc4bd03
--- /dev/null
+++ b/procgenAISC/procgen/examples/random_agent_gym.py
@@ -0,0 +1,14 @@
+"""
+Example random agent script using the gym API to demonstrate that procgen works
+"""
+
+import gym
+env = gym.make('procgen:procgen-coinrun-v0')
+obs = env.reset()
+step = 0
+while True:
+    obs, rew, done, info = env.step(env.action_space.sample())
+    print(f"step {step} reward {rew} done {done}")
+    step += 1
+    if done:
+        break
\ No newline at end of file
diff --git a/procgenAISC/procgen/examples/random_agent_gym3.py b/procgenAISC/procgen/examples/random_agent_gym3.py
new file mode 100644
index 0000000..cecf779
--- /dev/null
+++ b/procgenAISC/procgen/examples/random_agent_gym3.py
@@ -0,0 +1,15 @@
+"""
+Example random agent script using the gym3 API to demonstrate that procgen works
+"""
+
+from gym3 import types_np
+from procgen import ProcgenGym3Env
+env = ProcgenGym3Env(num=1, env_name="coinrun")
+step = 0
+while True:
+    env.act(types_np.sample(env.ac_space, bshape=(env.num,)))
+    rew, obs, first = env.observe()
+    print(f"step {step} reward {rew} first {first}")
+    if step > 0 and first:
+        break
+    step += 1
diff --git a/procgenAISC/procgen/gym_registration.py b/procgenAISC/procgen/gym_registration.py
new file mode 100644
index 0000000..3447b6b
--- /dev/null
+++ b/procgenAISC/procgen/gym_registration.py
@@ -0,0 +1,35 @@
+from gym.envs.registration import register
+from gym3 import ToGymEnv, ViewerWrapper, ExtractDictObWrapper
+from .env import ENV_NAMES, ProcgenGym3Env
+
+
+def make_env(render_mode=None, render=False, **kwargs):
+    # the render option is kept here for backwards compatibility
+    # users should use `render_mode="human"` or `render_mode="rgb_array"`
+    if render:
+        render_mode = "human"
+
+    use_viewer_wrapper = False
+    kwargs["render_mode"] = render_mode
+    if render_mode == "human":
+        # procgen does not directly support rendering a window
+        # instead it's handled by gym3's ViewerWrapper
+        # procgen only supports a render_mode of "rgb_array"
+        use_viewer_wrapper = True
+        kwargs["render_mode"] = "rgb_array"
+
+    env = ProcgenGym3Env(num=1, num_threads=0, **kwargs)
+    env = ExtractDictObWrapper(env, key="rgb")
+    if use_viewer_wrapper:
+        env = ViewerWrapper(env, tps=15, info_key="rgb")
+    gym_env = ToGymEnv(env)
+    return gym_env
+
+
+def register_environments():
+    for env_name in ENV_NAMES:
+        register(
+            id=f'procgen-{env_name}-v0',
+            entry_point='procgen.gym_registration:make_env',
+            kwargs={"env_name": env_name},
+        )
\ No newline at end of file
diff --git a/procgenAISC/procgen/interactive.py b/procgenAISC/procgen/interactive.py
new file mode 100644
index 0000000..fd9c7f7
--- /dev/null
+++ b/procgenAISC/procgen/interactive.py
@@ -0,0 +1,171 @@
+#!/usr/bin/env python
+import argparse
+
+from procgen import ProcgenGym3Env
+from .env import ENV_NAMES
+from gym3 import Interactive, VideoRecorderWrapper, unwrap
+
+class ProcgenInteractive(Interactive):
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
+        self._saved_state = None
+
+    def _update(self, dt, keys_clicked, keys_pressed):
+        if "LEFT_SHIFT" in keys_pressed and "F1" in keys_clicked:
+            print("save state")
+            self._saved_state = unwrap(self._env).get_state()
+        elif "F1" in keys_clicked:
+            print("load state")
+            if self._saved_state is not None:
+                unwrap(self._env).set_state(self._saved_state)
+        super()._update(dt, keys_clicked, keys_pressed)
+
+
+def make_interactive(vision, record_dir, **kwargs):
+    info_key = None
+    ob_key = None
+    if vision == "human":
+        info_key = "rgb"
+        kwargs["render_mode"] = "rgb_array"
+    else:
+        ob_key = "rgb"
+
+    env = ProcgenGym3Env(num=1, **kwargs)
+    if record_dir is not None:
+        env = VideoRecorderWrapper(
+            env=env, directory=record_dir, ob_key=ob_key, info_key=info_key
+        )
+    h, w, _ = env.ob_space["rgb"].shape
+    return ProcgenInteractive(
+        env,
+        ob_key=ob_key,
+        info_key=info_key,
+        width=w * 12,
+        height=h * 12,
+    )
+
+
+def main():
+    default_str = "(default: %(default)s)"
+    parser = argparse.ArgumentParser(
+        description="Interactive version of Procgen allowing you to play the games"
+    )
+    parser.add_argument(
+        "--vision",
+        default="human",
+        choices=["agent", "human"],
+        help="level of fidelity of observation " + default_str,
+    )
+    parser.add_argument("--record-dir", help="directory to record movies to")
+    parser.add_argument(
+        "--distribution-mode",
+        default="hard",
+        help="which distribution mode to use for the level generation " + default_str,
+    )
+    parser.add_argument(
+        "--env-name",
+        default="heist_aisc_many_chests",
+        help="name of game to create " + default_str,
+        choices=ENV_NAMES + ["coinrun_old"],
+    )
+    parser.add_argument(
+        "--level-seed", type=int, help="select an individual level to use"
+    )
+
+    advanced_group = parser.add_argument_group("advanced optional switch arguments")
+    advanced_group.add_argument(
+        "--rand-region",
+        default=0,
+        type=int,
+        help="Size of area to randomize cheese location over",
+    )
+    advanced_group.add_argument(
+        "--random-percent",
+        default=0,
+        type=int,
+        help="How often to randomize the level construction",
+    )
+    advanced_group.add_argument(
+        "--key-penalty",
+        default=0,
+        type=int,
+        help="Penalty for picking up keys (divided by 10)",
+    )
+    advanced_group.add_argument(
+        "--step-penalty",
+        default=0,
+        type=int,
+        help="Time penalty per step (divided by 1000)",
+    )
+    advanced_group.add_argument(
+        "--continue-after-coin",
+        action="store_true",
+        help="If true, don't end the level when coin is collected",
+    )
+    advanced_group.add_argument(
+        "--paint-vel-info",
+        action="store_true",
+        default=False,
+        help="paint player velocity info in the top left corner",
+    )
+    advanced_group.add_argument(
+        "--use-generated-assets",
+        action="store_true",
+        default=False,
+        help="use randomly generated assets in place of human designed assets",
+    )
+    advanced_group.add_argument(
+        "--uncenter-agent",
+        action="store_true",
+        default=False,
+        help="display the full level for games that center the observation to the agent",
+    )
+    advanced_group.add_argument(
+        "--disable-backgrounds",
+        action="store_true",
+        default=False,
+        help="disable human designed backgrounds",
+    )
+    advanced_group.add_argument(
+        "--restrict-themes",
+        action="store_true",
+        default=False,
+        help="restricts games that use multiple themes to use a single theme",
+    )
+    advanced_group.add_argument(
+        "--use-monochrome-assets",
+        action="store_true",
+        default=False,
+        help="use monochromatic rectangles instead of human designed assets",
+    )
+
+    args = parser.parse_args()
+
+    kwargs = {
+        "paint_vel_info": args.paint_vel_info,
+        "use_generated_assets": args.use_generated_assets,
+        "center_agent": not args.uncenter_agent,
+        "use_backgrounds": not args.disable_backgrounds,
+        "restrict_themes": args.restrict_themes,
+        "use_monochrome_assets": args.use_monochrome_assets,
+        "random_percent": args.random_percent,
+        "rand_region": args.rand_region,
+        "key_penalty": args.key_penalty,
+        "step_penalty": args.step_penalty,
+        "continue_after_coin": args.continue_after_coin,
+    }
+    
+    if args.env_name != "coinrun_old":
+        kwargs["distribution_mode"] = args.distribution_mode
+    if args.level_seed is not None:
+        kwargs["start_level"] = args.level_seed
+        kwargs["num_levels"] = 1
+    ia = make_interactive(
+        args.vision, record_dir=args.record_dir, env_name=args.env_name, **kwargs
+    )
+    
+    ia.run()
+
+
+if __name__ == "__main__":
+    main()
diff --git a/procgenAISC/procgen/src/_clang-format b/procgenAISC/procgen/src/_clang-format
new file mode 100644
index 0000000..235c4f4
--- /dev/null
+++ b/procgenAISC/procgen/src/_clang-format
@@ -0,0 +1,6 @@
+BasedOnStyle: LLVM
+IndentWidth: 4
+TabWidth: 4
+SortIncludes: false
+AllowShortFunctionsOnASingleLine: InlineOnly
+ColumnLimit: 0
\ No newline at end of file
diff --git a/procgenAISC/procgen/src/assetgen.cpp b/procgenAISC/procgen/src/assetgen.cpp
new file mode 100644
index 0000000..8028c7f
--- /dev/null
+++ b/procgenAISC/procgen/src/assetgen.cpp
@@ -0,0 +1,195 @@
+#include "assetgen.h"
+
+struct ColorGen {
+    RandGen *rand_gen;
+    float rgb_start[3];
+    float rgb_len[3];
+    int rgb_choice[3];
+    float p_rect;
+
+    void roll() {
+        for (int i = 0; i < 3; i++) {
+            rgb_len[i] = rand_gen->rand01();
+        }
+
+        for (int i = 0; i < 3; i++) {
+            rgb_start[i] = rand_gen->rand01() * (1 - rgb_len[i]);
+        }
+
+        p_rect = rand_gen->rand01();
+    }
+
+    QColor rand_color() {
+        for (int i = 0; i < 3; i++) {
+            rgb_choice[i] = int(255 * (rand_gen->rand01() * rgb_len[i] + rgb_start[i]));
+        }
+
+        return QColor(rgb_choice[0], rgb_choice[1], rgb_choice[2]);
+    }
+};
+
+AssetGen::AssetGen(RandGen *rg) {
+    rand_gen = rg;
+}
+
+QRectF AssetGen::choose_sub_rect(QRectF rect, float min_dim, float max_dim) {
+    int w = rect.width();
+    int h = rect.height();
+
+    int smaller = (w > h) ? h : w;
+
+    float del_dim = max_dim - min_dim;
+
+    float rdx = (rand_gen->rand01() * del_dim + min_dim) * smaller;
+    float rdy = (rand_gen->rand01() * del_dim + min_dim) * smaller;
+    float rx_off = rand_gen->rand01() * (w - rdx);
+    float ry_off = rand_gen->rand01() * (h - rdy);
+
+    QRectF dst3 = QRectF(rx_off + rect.x(), ry_off + rect.y(), rdx, rdy);
+
+    return dst3;
+}
+
+std::vector<QRectF> AssetGen::split_rect(QRectF rect, int num_splits, bool is_horizontal) {
+    std::vector<QRectF> split_rects;
+
+    float x = rect.x();
+    float y = rect.y();
+    float w = rect.width();
+    float h = rect.height();
+
+    float dw = w / num_splits;
+    float dh = h / num_splits;
+
+    for (int i = 0; i < num_splits; i++) {
+        if (is_horizontal) {
+            split_rects.push_back(QRectF(x + i * dw, y, dw, h));
+        } else {
+            split_rects.push_back(QRectF(x, y + i * dh, w, dh));
+        }
+    }
+
+    return split_rects;
+}
+
+void AssetGen::paint_shape(QPainter &p, QRectF main_rect, ColorGen *cgen) {
+    int k = rand_gen->randn(10);
+    int num_splits = (k * k) / 50 + 1;
+    std::vector<QRectF> split_rects = split_rect(main_rect, num_splits, rand_gen->randbool());
+
+    bool use_rect = rand_gen->randbool();
+    bool regen_colors = rand_gen->randbool();
+
+    QColor c1 = cgen->rand_color();
+    QColor c2 = cgen->rand_color();
+
+    for (QRectF rect : split_rects) {
+        if (regen_colors) {
+            c1 = cgen->rand_color();
+            c2 = cgen->rand_color();
+        }
+
+        if (use_rect) {
+            p.fillRect(rect, c1);
+        } else {
+            QBrush brush(c1);
+            QPen pen(c2);
+            p.setBrush(brush);
+            p.setPen(pen);
+            p.drawEllipse(rect);
+        }
+    }
+}
+
+void AssetGen::paint_rect_resource(QPainter &p, QRectF rect, int num_recurse, int blotch_scale) {
+    ColorGen cgen;
+    cgen.rand_gen = rand_gen;
+    cgen.roll();
+
+    QColor bgcolor = cgen.rand_color();
+
+    p.fillRect(rect, bgcolor);
+
+    float scale = .3 + .7 * rand_gen->rand01();
+
+    float max_rand_dim = .5 * scale;
+    float min_rand_dim = .05 * scale;
+    int num_blotches = rand_gen->randint(blotch_scale, 2 * blotch_scale);
+    float p_recurse = rand_gen->rand01() * .75;
+
+    for (int j = 0; j < num_blotches; j++) {
+        QRectF dst3 = choose_sub_rect(rect, min_rand_dim, max_rand_dim);
+
+        if ((num_recurse > 0) && (rand_gen->rand01() < p_recurse)) {
+            paint_rect_resource(p, dst3, num_recurse - 1, 10);
+        } else {
+            paint_shape(p, dst3, &cgen);
+        }
+    }
+
+    bgcolor.setAlpha(200);
+    p.fillRect(rect, bgcolor);
+}
+
+QRectF AssetGen::create_bar(QRectF rect, bool is_horizontal) {
+    float k1 = (.45 + rand_gen->rand01() * .4);
+    float k2 = (.45 + rand_gen->rand01() * .4);
+    float w = rect.width() * k1 * k1;
+    float h = rect.height() * k2 * k2;
+    float pct = rand_gen->rand01();
+    QRectF crect;
+
+    if (is_horizontal == 0) {
+        crect = QRectF(0, (rect.height() - h) * pct, rect.width(), h);
+    } else {
+        crect = QRectF((rect.height() - w) * pct, 0, w, rect.height());
+    }
+
+    return crect;
+}
+
+void AssetGen::paint_shape_resource(QPainter &p, QRectF rect) {
+    ColorGen cgen;
+    cgen.rand_gen = rand_gen;
+    cgen.roll();
+
+    bool horizontal_first = rand_gen->randbool();
+    int nbar1 = rand_gen->randn(3) / 2 + 1;
+    int nbar2 = rand_gen->randn(3) / 2 + 1;
+
+    p.save();
+
+    p.setCompositionMode(QPainter::CompositionMode_Source);
+    p.fillRect(rect, QColor(0, 0, 0, 0));
+
+    for (int i = 0; i < nbar1; i++) {
+        QRectF c1 = create_bar(rect, horizontal_first);
+        paint_shape(p, c1, &cgen);
+    }
+
+    for (int i = 0; i < nbar2; i++) {
+        QRectF c2 = create_bar(rect, !horizontal_first);
+        paint_shape(p, c2, &cgen);
+    }
+
+    int num_blotches = rand_gen->randint(1, 5);
+
+    for (int j = 0; j < num_blotches; j++) {
+        QRectF dst = choose_sub_rect(rect, 0.1f, 0.6f);
+
+        paint_shape(p, dst, &cgen);
+    }
+
+    p.restore();
+}
+
+void AssetGen::generate_resource(std::shared_ptr<QImage> img, int num_recurse, int blotch_scale, bool is_rect) {
+    QPainter p(img.get());
+    QRectF rect = QRectF(0, 0, img->width(), img->height());
+
+    if (is_rect) {
+        paint_rect_resource(p, rect, num_recurse, blotch_scale);
+    } else {
+        paint_shape_resource(p, rect);
+    }
+}
\ No newline at end of file
diff --git a/procgenAISC/procgen/src/assetgen.h b/procgenAISC/procgen/src/assetgen.h
new file mode 100644
index 0000000..7ebeab4
--- /dev/null
+++ b/procgenAISC/procgen/src/assetgen.h
@@ -0,0 +1,33 @@
+#pragma once
+
+/*
+
+Generate assets procedurally
+
+*/
+
+#include "randgen.h"
+#include <QColor>
+#include <QImage>
+#include <QRectF>
+#include <QtGui/QPainter>
+#include <memory>
+
+struct ColorGen;
+
+class AssetGen {
+
+  public:
+    AssetGen(RandGen *rg);
+    void generate_resource(std::shared_ptr<QImage> img, int num_recurse = 1, int blotch_scale = 50, bool is_rect = true);
+
+  private:
+    RandGen *rand_gen;
+
+    std::vector<QRectF> split_rect(QRectF rect, int num_splits, bool is_horizontal);
+    QRectF choose_sub_rect(QRectF rect, float min_dim, float max_dim);
+    QRectF create_bar(QRectF rect, bool is_horizontal);
+    void paint_shape(QPainter &p, QRectF rect, ColorGen *cgen);
+    void paint_rect_resource(QPainter &p, QRectF rect, int num_recurse, int blotch_scale);
+    void paint_shape_resource(QPainter &p, QRectF rect);
+};
\ No newline at end of file
diff --git a/procgenAISC/procgen/src/basic-abstract-game.cpp b/procgenAISC/procgen/src/basic-abstract-game.cpp
new file mode 100644
index 0000000..bc9453a
--- /dev/null
+++ b/procgenAISC/procgen/src/basic-abstract-game.cpp
@@ -0,0 +1,1288 @@
+#include "basic-abstract-game.h"
+#include "resources.h"
+#include "assetgen.h"
+#include "qt-utils.h"
+
+const float MAXVTHETA = 15 * PI / 180;
+const float MIXRATEROT = 0.5f;
+
+// A small constant buffer for handling collision detction and object pushing
+const float POS_EPS = -0.001f;
+
+// When the grid isn't integer aligned, consecutive blocks render with small gaps between them
+// This hack closes the gaps
+const float RENDER_EPS = 0.02f;
+
+// objects with type lower than this threshold will be rendered with procgen assets
+// objects with type higher than this threshold will be rendered with colored grid squares
+const int USE_ASSET_THRESHOLD = 100;
+const int MAX_ASSETS = USE_ASSET_THRESHOLD;
+const int MAX_IMAGE_THEMES = 20;
+
+BasicAbstractGame::BasicAbstractGame(std::string name)
+    : Game(name) {
+    char_dim = 5;
+
+    main_width = 0;
+    main_height = 0;
+
+    visibility = 16;
+    min_visibility = 0;
+
+    mixrate = 0.5;
+    maxspeed = 0.5;
+
+    // only used by a few games
+    max_jump = maxspeed;
+
+    default_action = 4;
+    last_move_action = 7;
+    bg_tile_ratio = 0;
+
+    main_bg_images_ptr = 0;
+
+    out_of_bounds_object = INVALID_OBJ;
+    has_useful_vel_info = true;
+}
+
+BasicAbstractGame::~BasicAbstractGame() {
+    if (main_bg_images_ptr != nullptr && use_procgen_background) {
+        delete main_bg_images_ptr;
+    }
+}
+
+void BasicAbstractGame::game_init() {
+    if (!options.use_generated_assets) {
+        load_background_images();
+    }
+
+    if (main_bg_images_ptr == nullptr) {
+        main_bg_images_ptr = new std::vector<std::shared_ptr<QImage>>();
+        use_procgen_background = true;
+        auto main_bg_image = std::make_shared<QImage>(500, 500, QImage::Format_RGB32);
+        main_bg_images_ptr->push_back(main_bg_image);
+    } else {
+        use_procgen_background = false;
+    }
+
+    basic_assets.clear();
+    basic_reflections.clear();
+    asset_aspect_ratios.clear();
+    asset_num_themes.clear();
+
+    basic_assets.resize(USE_ASSET_THRESHOLD * MAX_IMAGE_THEMES, nullptr);
+    basic_reflections.resize(USE_ASSET_THRESHOLD * MAX_IMAGE_THEMES, nullptr);
+    asset_aspect_ratios.resize(USE_ASSET_THRESHOLD * MAX_IMAGE_THEMES, 0);
+    asset_num_themes.resize(USE_ASSET_THRESHOLD, 0);
+}
+
+void BasicAbstractGame::initialize_asset_if_necessary(int img_idx) {
+    if (basic_assets.at(img_idx) != nullptr)
+        return;
+
+    int type = img_idx % MAX_ASSETS;
+    int theme = img_idx / MAX_ASSETS;
+
+    theme = mask_theme_if_necessary(theme, type);
+
+    std::shared_ptr<QImage> asset_ptr = nullptr;
+    float aspect_ratio;
+    int num_themes;
+    std::vector<std::string> names;
+
+    if (!options.use_generated_assets) {
+        asset_for_type(type, names);
+
+        if (names.size() == 0) {
+            reserved_asset_for_type(type, names);
+        }
+    }
+
+    if (names.size() == 0) {
+        AssetGen pgen(&asset_rand_gen);
+        asset_rand_gen.seed(fixed_asset_seed + type);
+
+        std::shared_ptr<QImage> small_image(new QImage(64, 64, QImage::Format_ARGB32));
+        asset_ptr = small_image;
+        pgen.generate_resource(asset_ptr, 0, 5, use_block_asset(type));
+
+        num_themes = 1;
+        aspect_ratio = 1.0;
+    } else {
+        asset_ptr = get_asset_ptr(names[theme]);
+        num_themes = (int)(names.size());
+        aspect_ratio = asset_ptr->width() * 1.0 / asset_ptr->height();
+    }
+
+    basic_assets[img_idx] = asset_ptr;
+    asset_aspect_ratios[img_idx] = aspect_ratio;
+    asset_num_themes[type] = num_themes;
+
+    std::shared_ptr<QImage> reflection_ptr(new QImage(asset_ptr->mirrored(true, false)));
+    basic_reflections[img_idx] = reflection_ptr;
+}
+
+void BasicAbstractGame::fill_elem(int x, int y, int dx, int dy, char elem) {
+    for (int j = 0; j < dx; j++) {
+        for (int k = 0; k < dy; k++) {
+            grid.set(x + j, y + k, elem);
+        }
+    }
+}
+
+float BasicAbstractGame::get_distance(const std::shared_ptr<Entity> &p0, const std::shared_ptr<Entity> &p1) {
+    float p0_x = p0->x;
+    float p0_y = p0->y;
+    float p1_x = p1->x;
+    float p1_y = p1->y;
+
+    float dx = p0_x - p1_x;
+    float dy = p0_y - p1_y;
+
+    return sqrt(dx * dx + dy * dy);
+}
+
+void BasicAbstractGame::check_grid_collisions(const std::shared_ptr<Entity> &ent) {
+    float ax = ent->x;
+    float ay = ent->y;
+    float arx = ent->rx;
+    float ary = ent->ry;
+
+    int min_x = int(ax - (arx + POS_EPS));
+    int max_x = int(ax + (arx + POS_EPS));
+    int min_y = int(ay - (ary + POS_EPS));
+    int max_y = int(ay + (ary + POS_EPS));
+
+    for (int x = min_x; x <= max_x; x++) {
+        for (int y = min_y; y <= max_y; y++) {
+            int grid_type = get_obj_from_floats(x, y);
+
+            if (grid_type != SPACE) {
+                handle_grid_collision(ent, grid_type, x, y);
+            }
+        }
+    }
+}
+
+int BasicAbstractGame::get_obj_from_floats(float i, float j) {
+    if (i < 0)
+        return out_of_bounds_object;
+    if (j < 0)
+        return out_of_bounds_object;
+
+    return get_obj(floor(i), floor(j));
+}
+
+int BasicAbstractGame::get_agent_index() {
+    return int(agent->y) * main_width + int(agent->x);
+}
+
+int BasicAbstractGame::get_obj(int x, int y) {
+    if (!grid.contains(x, y)) {
+        return out_of_bounds_object;
+    }
+    return grid.get(x, y);
+}
+
+int BasicAbstractGame::to_grid_idx(int x, int y) {
+    if (!grid.contains(x, y)) {
+        return INVALID_IDX;
+    }
+    return grid.to_index(x, y);
+}
+
+void BasicAbstractGame::to_grid_xy(int idx, int *x, int *y) {
+    return grid.to_xy(idx, x, y);
+}
+
+int BasicAbstractGame::get_obj(int idx) {
+    if (!grid.contains_index(idx)) {
+        return out_of_bounds_object;
+    }
+    return grid.get_index(idx);
+}
+
+std::vector<int> BasicAbstractGame::get_cells_with_type(int type) {
+    std::vector<int> cells;
+
+    for (int i = 0; i < grid_size; i++) {
+        if (grid.get_index(i) == type) {
+            cells.push_back(i);
+        }
+    }
+
+    return cells;
+}
+
+void BasicAbstractGame::set_obj(int idx, int elem) {
+    grid.set_index(idx, elem);
+}
+
+void BasicAbstractGame::set_obj(int x, int y, int elem) {
+    grid.set(x, y, elem);
+}
+
+std::shared_ptr<Entity> BasicAbstractGame::spawn_child(const std::shared_ptr<Entity> &src, int type, float obj_r, bool match_vel) {
+    float vx = match_vel ? src->vx : 0;
+    float vy = match_vel ? src->vy : 0;
+    auto child = std::make_shared<Entity>(src->x, src->y, vx, vy, obj_r, type);
+    entities.push_back(child);
+    return child;
+}
+
+float BasicAbstractGame::get_theta(const std::shared_ptr<Entity> &src, const std::shared_ptr<Entity> &target) {
+    float dx = target->x - src->x;
+    float dy = target->y - src->y;
+
+    return atan2(dy, dx);
+}
+
+bool BasicAbstractGame::push_obj(const std::shared_ptr<Entity> &src, const std::shared_ptr<Entity> &target, bool is_horizontal, int depth) {
+    float rsum = is_horizontal ? (src->rx + target->rx) : (src->ry + target->ry);
+    float delx = target->x - src->x;
+    float dely = target->y - src->y;
+    float t_vx = 0;
+    float t_vy = 0;
+
+    if (is_horizontal) {
+        t_vx = src->x + sign(delx) * rsum - target->x;
+    } else {
+        t_vy = src->y + sign(dely) * rsum - target->y;
+    }
+
+    bool block = false;
+
+    // Rare numerical conditions (dependent on POS_EPS) could cause infinite loops.
+    // For now we break quit after a small depth.
+    if (depth < 5) {
+        block = sub_step(target, t_vx, t_vy, depth + 1);
+    }
+
+    if (is_horizontal) {
+        target->vx = 0;
+    } else {
+        target->vy = 0;
+    }
+
+    return block;
+}
+
+bool BasicAbstractGame::sub_step(const std::shared_ptr<Entity> &obj, float _vx, float _vy, int depth) {
+    if (obj->will_erase)
+        return false;
+
+    float ny = obj->y + _vy;
+    float nx = obj->x + _vx;
+
+    float margin = 0.98f;
+
+    bool is_horizontal = _vx != 0;
+
+    bool block = false;
+    bool reflect = false;
+
+    for (int i = 0; i < 2; i++) {
+        for (int j = 0; j < 2; j++) {
+            int type2 = get_obj_from_floats(nx + obj->rx * margin * (2 * i - 1), ny + obj->ry * margin * (2 * j - 1));
+            block = block || is_blocked(obj, type2, is_horizontal);
+            reflect = reflect || will_reflect(obj->type, type2);
+        }
+    }
+
+    if (reflect) {
+        if (is_horizontal) {
+            float delta;
+
+            if (_vx < 0) {
+                delta = ceil(nx - obj->rx) - (nx - obj->rx);
+            } else {
+                delta = floor(nx + obj->rx) - (nx + obj->rx);
+            }
+
+            obj->vx = -1 * obj->vx;
+            nx = nx + 2 * delta;
+        } else {
+            float delta;
+
+            if (_vy < 0) {
+                delta = ceil(ny - obj->ry) - (ny - obj->ry);
+            } else {
+                delta = floor(ny + obj->ry) - (ny + obj->ry);
+            }
+
+            obj->vy = -1 * obj->vy;
+            ny = ny + 2 * delta;
+        }
+    } else if (block) {
+        if (is_horizontal) {
+            if (grid_step) {
+                nx = obj->x;
+            } else {
+                nx = _vx > 0 ? (floor(nx + obj->rx) - obj->rx) : (ceil(nx - obj->rx) + obj->rx);
+            }
+        } else {
+            if (grid_step) {
+                ny = obj->y;
+            } else {
+                ny = _vy > 0 ? (floor(ny + obj->ry) - obj->ry) : (ceil(ny - obj->ry) + obj->ry);
+            }
+        }
+    }
+
+    obj->x = nx;
+    obj->y = ny;
+
+    bool block2 = false;
+
+    for (int i = (int)(entities.size()) - 1; i >= 0; i--) {
+        auto m = entities[i];
+
+        if (m == obj || m->will_erase) {
+            continue;
+        }
+
+        bool curr_block = false;
+
+        if (has_collision(obj, m, POS_EPS)) {
+            if (is_blocked_ents(obj, m, is_horizontal)) {
+                curr_block = true;
+            } else if (will_reflect(obj->type, m->type)) {
+                if (is_horizontal) {
+                    float delx = m->x - obj->x;
+                    float rsum = m->rx + obj->rx;
+                    obj->x += _vx > 0 ? -2 * (rsum - delx) : 2 * (rsum + delx);
+                    obj->vx = -1 * obj->vx;
+                } else {
+                    float dely = m->y - obj->y;
+                    float rsum = m->ry + obj->ry;
+                    obj->y += _vy > 0 ? -2 * (rsum - dely) : 2 * (rsum + dely);
+                    obj->vy = -1 * obj->vy;
+                }
+            }
+
+            if (curr_block) {
+                push_obj(m, obj, is_horizontal, depth);
+            }
+        }
+
+        block2 = block2 || curr_block;
+    }
+
+    return block || block2;
+}
+
+/*
+  Can be overridden to specify world dimensions different than the default on level generation.
+*/
+void BasicAbstractGame::choose_world_dim() {
+}
+
+/*
+  The agent collided with this obj. This check is always performed.
+*/
+void BasicAbstractGame::handle_agent_collision(const std::shared_ptr<Entity> &obj) {
+}
+
+/*
+  The obj collided with an object in the grid at (i, j) with the given type.
+  Right now obj is always the agent.
+*/
+void BasicAbstractGame::handle_grid_collision(const std::shared_ptr<Entity> &obj, int type, int i, int j) {
+}
+
+/*
+  The object src collided with an object target.
+  This check is performed if src->collides_with_entities is set and src->collision_margin is used for the
+  collision test.
+*/
+void BasicAbstractGame::handle_collision(const std::shared_ptr<Entity> &src, const std::shared_ptr<Entity> &target) {
+}
+
+/*
+  Determines whether assets of this type will be generated as blocks, covering the full canvas.
+*/
+bool BasicAbstractGame::use_block_asset(int type) {
+    return false;
+}
+
+// 0 means don't tile, positive value means tile horizontally, negative value means tile vertically
+float BasicAbstractGame::get_tile_aspect_ratio(const std::shared_ptr<Entity> &type) {
+    return 0;
+}
+
+void BasicAbstractGame::asset_for_type(int type, std::vector<std::string> &names) {
+}
+
+void BasicAbstractGame::reserved_asset_for_type(int type, std::vector<std::string> &names) {
+    if (type == EXPLOSION) {
+        names.push_back("misc_assets/explosion1.png");
+    } else if (type == EXPLOSION2) {
+        names.push_back("misc_assets/explosion2.png");
+    } else if (type == EXPLOSION3) {
+        names.push_back("misc_assets/explosion3.png");
+    } else if (type == EXPLOSION4) {
+        names.push_back("misc_assets/explosion4.png");
+    } else if (type == EXPLOSION5) {
+        names.push_back("misc_assets/explosion5.png");
+    } else if (type == TRAIL) {
+        names.push_back("misc_assets/iconCircle_white.png");
+    }
+}
+
+void BasicAbstractGame::load_background_images() {
+}
+
+/*
+  Use this image index for objects of the given type
+*/
+int BasicAbstractGame::image_for_type(int type) {
+    return abs(type);
+}
+
+int BasicAbstractGame::theme_for_grid_obj(int type) {
+    return 0;
+}
+
+bool BasicAbstractGame::should_preserve_type_themes(int type) {
+    return false;
+}
+
+int BasicAbstractGame::mask_theme_if_necessary(int theme, int type) {
+    if (options.restrict_themes && !should_preserve_type_themes(type)) return 0;
+    return theme;
+}
+
+QColor BasicAbstractGame::color_for_type(int type, int theme) {
+    QColor color;
+
+    if (options.use_monochrome_assets) {
+        theme = mask_theme_if_necessary(theme, type);
+
+        int k = 4;
+        int kcubed = k * k * k;
+        int chunk = 256 / k;
+        fassert(type < kcubed);
+
+        int p1 = 29;
+        int p2 = 19;
+        // kcubed, p1, and p2 should be relatively prime
+        // there will be no type collisons for a fixed theme
+        // there will be no theme collisions for a fixed type
+        // unique (type, theme) pairs might collide, but this is unlikely to be very relevant
+        int new_type = (p1 * (type + 1)) % kcubed;
+        new_type = (new_type + p2 * theme) % kcubed;
+
+        color = QColor(chunk * (new_type / (k * k) + 1) - 1, chunk * ((new_type / k) % k + 1) - 1, chunk * (new_type % k + 1) - 1);
+    } else {
+        fassert(false);
+    }
+
+    return color;
+}
+/*
+  Determines whether objects of type target block objects of type src.
+*/
+bool BasicAbstractGame::is_blocked(const std::shared_ptr<Entity> &src, int target, bool is_horizontal) {
+    if (target == WALL_OBJ)
+        return true;
+    if (target == out_of_bounds_object)
+        return true;
+
+    return false;
+}
+
+bool BasicAbstractGame::is_blocked_ents(const std::shared_ptr<Entity> &src, const std::shared_ptr<Entity> &target, bool is_horizontal) {
+    return is_blocked(src, target->type, is_horizontal);
+}
+
+bool BasicAbstractGame::will_reflect(int src, int target) {
+    return false;
+}
+
+float BasicAbstractGame::get_agent_acceleration_scale() {
+    return 1.0;
+}
+
+/*
+  Create an object of given type and radius contained within the specified box.
+  check_collisions (true by default) determines whether the object must not collide with existing objects.
+*/
+
+std::shared_ptr<Entity> BasicAbstractGame::spawn_entity_rxy(float rx, float ry, int type, float x, float y, float w, float h, bool check_collisions) {
+    std::shared_ptr<Entity> ent(new Entity(0, 0, 0, 0, rx, ry, type));
+
+    reposition(ent, x, y, w, h, check_collisions);
+
+    entities.push_back(ent);
+
+    return ent;
+}
+
+bool BasicAbstractGame::agent_has_collision() {
+    for (auto ent : entities) {
+        if (has_agent_collision(ent)) {
+            return true;
+        }
+    }
+
+    return false;
+}
+
+void BasicAbstractGame::reposition_agent() {
+    int count = 0;
+
+    do {
+        agent->x = rand_gen.rand01() * (main_width - 2 * agent->rx) + agent->rx;
+        agent->y = rand_gen.rand01() * (main_height - 2 * agent->ry) + agent->ry;
+        count++;
+    } while (agent_has_collision() && (count < 100));
+}
+
+void BasicAbstractGame::reposition(const std::shared_ptr<Entity> &ent, float x, float y, float w, float h, bool check_collisions) {
+    float rx = ent->rx;
+    float ry = ent->ry;
+
+    ent->x = rand_pos(rx, x, x + w);
+    ent->y = rand_pos(ry, y, y + h);
+
+    int count = 0;
+
+    while ((has_agent_collision(ent) || (check_collisions && has_any_collision(ent))) && (count < 100)) {
+        ent->x = rand_pos(rx, x, x + w);
+        ent->y = rand_pos(ry, y, y + h);
+        count++;
+    }
+
+    if (count == 100) {
+        printf("WARNING: excessive randomization attempts. Game num, type, rx, ry, w, h: %d %d %f_%f %d %d \n", game_n, ent->type, rx, ry, main_width, main_height);
+        printf("Agent: %f %f\n", agent->x, agent->y);
+    }
+}
+
+std::shared_ptr<Entity> BasicAbstractGame::spawn_entity(float r, int type, float x, float y, float w, float h, bool check_collisions) {
+    return spawn_entity_rxy(r, r, type, x, y, w, h, check_collisions);
+}
+
+std::shared_ptr<Entity> BasicAbstractGame::add_entity(float x, float y, float vx, float vy, float r, int type) {
+    std::shared_ptr<Entity> ent(new Entity(x, y, vx, vy, r, r, type));
+    entities.push_back(ent);
+    return ent;
+}
+
+std::shared_ptr<Entity> BasicAbstractGame::add_entity_rxy(float x, float y, float vx, float vy, float rx, float ry, int type) {
+    std::shared_ptr<Entity> ent(new Entity(x, y, vx, vy, rx, ry, type));
+    entities.push_back(ent);
+    return ent;
+}
+
+std::shared_ptr<Entity> BasicAbstractGame::spawn_entity_at_idx(int idx, float r, int type) {
+    float x = (idx % main_width) + .5;
+    float y = (idx / main_width) + .5;
+
+    auto ent = add_entity(x, y, 0, 0, r, type);
+
+    return ent;
+}
+
+void BasicAbstractGame::spawn_entities(int num_entities, float r, int type, float x, float y, float w, float h) {
+    for (int i = 0; i < num_entities; i++) {
+        spawn_entity(r, type, x, y, w, h);
+    }
+}
+
+void BasicAbstractGame::basic_step_object(const std::shared_ptr<Entity> &obj) {
+    if (obj->will_erase)
+        return;
+
+    int num_sub_steps;
+
+    if (grid_step) {
+        num_sub_steps = 1;
+    } else {
+        num_sub_steps = int(4 * sqrt(obj->vx * obj->vx + obj->vy * obj->vy));
+        if (num_sub_steps < 4)
+            num_sub_steps = 4;
+    }
+
+    float pct = 1.0 / num_sub_steps;
+
+    float cmp = fabs(obj->vx) - fabs(obj->vy);
+
+    /*
+     Resolve ties randomly -- important for randomized movement through tight corridors in orbeater.
+     In order to ensure that enemies choose randomly between horizontal/vertical forks in a path,
+     this collision detection shouldn't favor one direction over another.
+    */
+    bool step_x_first = cmp == 0 ? step_rand_int % 2 == 0 : (cmp > 0);
+
+    // edge case -- needed for player movement through tight corridors (e.g. Pacman)
+    if (obj->type == PLAYER) {
+        if (action_vx != 0)
+            step_x_first = true;
+        if (action_vy != 0)
+            step_x_first = false;
+    }
+
+    float vx_pct = 0;
+    float vy_pct = 0;
+
+    for (int s = 0; s < num_sub_steps; s++) {
+        bool block_x = false;
+        bool block_y = false;
+
+        if (step_x_first) {
+            block_x = sub_step(obj, obj->vx * pct, 0, 0);
+            block_y = sub_step(obj, 0, obj->vy * pct, 0);
+        } else {
+            block_y = sub_step(obj, 0, obj->vy * pct, 0);
+            block_x = sub_step(obj, obj->vx * pct, 0, 0);
+        }
+
+        if (!block_x)
+            vx_pct += 1;
+        if (!block_y)
+            vy_pct += 1;
+
+        if (block_x && block_y) {
+            break;
+        }
+    }
+
+    vx_pct = vx_pct / num_sub_steps;
+    vy_pct = vy_pct / num_sub_steps;
+
+    obj->vx *= vx_pct;
+    obj->vy *= vy_pct;
+}
+
+void BasicAbstractGame::set_action_xy(int move_act) {
+    action_vx = move_act / 3 - 1;
+    action_vy = move_act % 3 - 1;
+    action_vrot = 0;
+}
+
+void BasicAbstractGame::choose_center(float &cx, float &cy) {
+    cx = agent->x;
+    cy = agent->y;
+}
+
+void BasicAbstractGame::update_agent_velocity() {
+    float v_scale = get_agent_acceleration_scale();
+
+    agent->vx = (1 - mixrate) * agent->vx;
+    agent->vy = (1 - mixrate) * agent->vy;
+
+    agent->vx += mixrate * maxspeed * action_vx * v_scale;
+    agent->vy += mixrate * maxspeed * action_vy * v_scale;
+
+    decay_agent_velocity();
+}
+
+void BasicAbstractGame::decay_agent_velocity() {
+    agent->vx = .9 * agent->vx;
+    agent->vy = .9 * agent->vy;
+}
+
+void BasicAbstractGame::game_step() {
+    step_rand_int = rand_gen.randint(0, 1000000);
+    move_action = action % 9;
+    special_action = 0;
+
+    if (action >= 9) {
+        special_action = action - 8;
+        move_action = 4; // stand still when taking a special action
+    }
+
+    if (move_action != 4) {
+        last_move_action = move_action;
+    }
+
+    // set reasonable defaults
+    action_vrot = 0;
+    action_vx = 0;
+    action_vy = 0;
+
+    set_action_xy(move_action);
+
+    if (grid_step) {
+        agent->vx = action_vx;
+        agent->vy = action_vy;
+    } else {
+        update_agent_velocity();
+
+        agent->vrot = MIXRATEROT * agent->vrot;
+        agent->vrot += MIXRATEROT * MAXVTHETA * action_vrot;
+    }
+
+    step_entities(entities);
+
+    for (int i = (int)(entities.size()) - 1; i >= 0; i--) {
+        auto ent = entities[i];
+
+        if (has_agent_collision(ent)) {
+            handle_agent_collision(ent);
+        }
+
+        if (ent->collides_with_entities) {
+            for (int j = (int)(entities.size()) - 1; j >= 0; j--) {
+                if (i == j)
+                    continue;
+                auto ent2 = entities[j];
+
+                if (has_collision(ent, ent2, ent->collision_margin) && !ent->will_erase && !ent2->will_erase) {
+                    handle_collision(ent, ent2);
+                }
+            }
+        }
+
+        if (ent->smart_step) {
+            check_grid_collisions(ent);
+        }
+    }
+
+    erase_if_needed();
+
+    step_data.done = step_data.done || is_out_of_bounds(agent);
+}
+
+void BasicAbstractGame::erase_if_needed() {
+    for (int i = (int)(entities.size()) - 1; i >= 0; i--) {
+        auto e = entities[i];
+
+        if (e->will_erase || (e->auto_erase && is_out_of_bounds(e))) {
+            entities.erase(entities.begin() + i);
+        }
+    }
+}
+
+void BasicAbstractGame::game_reset() {
+    choose_world_dim();
+    fassert(main_width > 0 && main_height > 0);
+
+    bg_pct_x = rand_gen.rand01();
+
+    grid_size = main_width * main_height;
+    grid.resize(main_width, main_height);
+
+    background_index = rand_gen.randn((int)(main_bg_images_ptr->size()));
+
+    AssetGen bggen(&rand_gen);
+
+    if (use_procgen_background) {
+        bggen.generate_resource(main_bg_images_ptr->at(background_index));
+    }
+
+    entities.clear();
+
+    float ax, ay;
+    float a_r = 0.4f;
+
+    if (random_agent_start) {
+        ax = rand_gen.rand01() * (main_width - 2 * a_r) + a_r;
+        ay = rand_gen.rand01() * (main_height - 2 * a_r) + a_r;
+    } else {
+        ax = a_r;
+        ay = a_r;
+    }
+
+    auto _agent = std::make_shared<Entity>(ax, ay, 0, 0, a_r, PLAYER);
+    agent = _agent;
+    agent->smart_step = true;
+    agent->render_z = 1;
+    entities.push_back(agent);
+
+    erase_if_needed();
+
+    fill_elem(0, 0, main_width, main_height, SPACE);
+}
+
+QRectF BasicAbstractGame::get_screen_rect(float x, float y, float dx, float dy, float render_eps) {
+    return QRectF((x - render_eps) * unit - x_off, (view_dim - y - render_eps) * unit + y_off, (dx + 2 * render_eps) * unit, (dy + 2 * render_eps) * unit);
+}
+
+QRectF BasicAbstractGame::get_abs_rect(float x, float y, float dx, float dy) {
+    return QRectF(x * unit, y * unit, dx * unit, dy * unit);
+}
+
+QRectF BasicAbstractGame::get_adjusted_image_rect(int type, const QRectF &rect) {
+    return rect;
+}
+
+QRectF BasicAbstractGame::get_object_rect(const std::shared_ptr<Entity> &obj) {
+    if (obj->use_abs_coords) {
+        return get_abs_rect(view_dim * (obj->x - obj->rx), view_dim * (obj->y + obj->ry), 2 * view_dim * obj->rx, 2 * view_dim * obj->ry);
+    }
+
+    return get_screen_rect(obj->x - obj->rx, obj->y + obj->ry, 2 * obj->rx, 2 * obj->ry);
+}
+
+void BasicAbstractGame::prepare_for_drawing(float rect_height) {
+    center_x = main_width * .5;
+    center_y = main_height * .5;
+
+    if (options.center_agent) {
+        choose_center(center_x, center_y);
+    } else {
+        visibility = main_width > main_height ? main_width : main_height;
+        if (visibility < min_visibility)
+            visibility = min_visibility;
+    }
+
+    float raw_unit = 64 / visibility;
+    unit = raw_unit * (rect_height / 64.0);
+
+    view_dim = 64.0 / raw_unit;
+
+    x_off = unit * (center_x - view_dim / 2);
+    y_off = unit * (center_y - view_dim / 2);
+}
+
+void BasicAbstractGame::tile_image(QPainter &p, QImage *image, const QRectF &rect, float tile_ratio) {
+    if (tile_ratio != 0) {
+        if (tile_ratio < 0) {
+            tile_ratio = -1 * tile_ratio;
+            int num_tiles = int(rect.height() / (rect.width() * tile_ratio));
+            if (num_tiles < 1)
+                num_tiles = 1;
+            float tile_height = rect.height() / num_tiles;
+            float tile_width = rect.width();
+
+            for (int i = 0; i < num_tiles; i++) {
+                QRectF tile_rect = QRectF(rect.x(), rect.y() + tile_height * i, tile_width, tile_height);
+                p.drawImage(tile_rect, *image);
+            }
+        } else {
+            int num_tiles = int(rect.width() / (rect.height() * tile_ratio));
+            if (num_tiles < 1)
+                num_tiles = 1;
+            float tile_width = rect.width() / num_tiles;
+            float tile_height = rect.height();
+
+            for (int i = 0; i < num_tiles; i++) {
+                QRectF tile_rect = QRectF(rect.x() + tile_width * i, rect.y(), tile_width, tile_height);
+                p.drawImage(tile_rect, *image);
+            }
+        }
+    } else {
+        p.drawImage(rect, *image);
+    }
+}
+
+QImage *BasicAbstractGame::lookup_asset(int img_idx, bool is_reflected) {
+    initialize_asset_if_necessary(img_idx);
+    auto assets = is_reflected ? &basic_reflections : &basic_assets;
+    return assets->at(img_idx).get();
+}
+
+void BasicAbstractGame::draw_image(QPainter &p, QRectF &base_rect, float rotation, bool is_reflected, int base_type, int theme, float alpha, float tile_ratio) {
+    int img_type = image_for_type(base_type);
+
+    if (img_type < 0) {
+        return;
+    }
+
+    if (options.use_monochrome_assets || img_type >= USE_ASSET_THRESHOLD) {
+        draw_grid_obj(p, base_rect, img_type, theme);
+    } else {
+        int img_idx = img_type + theme * MAX_ASSETS;
+        fassert(theme < MAX_IMAGE_THEMES);
+
+        QRectF adjusted_rect = get_adjusted_image_rect(img_type, base_rect);
+
+        auto asset_ptr = lookup_asset(img_idx, is_reflected);
+
+        if (alpha != 1) {
+            p.save();
+            p.setOpacity(alpha);
+        }
+
+        if (rotation == 0) {
+            tile_image(p, asset_ptr, adjusted_rect, tile_ratio);
+        } else {
+            p.save();
+            p.translate(adjusted_rect.x() + adjusted_rect.width() / 2, adjusted_rect.y() + adjusted_rect.height() / 2);
+            p.rotate(rotation * 180 / PI);
+            p.drawImage(QRectF(-adjusted_rect.width() / 2, -adjusted_rect.height() / 2, adjusted_rect.width(), adjusted_rect.height()), *asset_ptr);
+            p.restore();
+        }
+
+        if (alpha != 1) {
+            p.restore();
+        }
+    }
+}
+
+void BasicAbstractGame::draw_grid_obj(QPainter &p, const QRectF &rect, int type, int theme) {
+    if (type == SPACE)
+        return;
+    p.fillRect(rect, color_for_type(type, theme));
+}
+
+void BasicAbstractGame::draw_foreground(QPainter &p, const QRect &rect) {
+    prepare_for_drawing(rect.height());
+
+    draw_entities(p, entities, -1);
+
+    int low_x, high_x, low_y, high_y;
+
+    if (options.center_agent) {
+        float margin = (visibility / 2.0 + 1);
+        low_x = center_x - margin;
+        high_x = center_x + margin;
+        low_y = center_y - margin;
+        high_y = center_y + margin;
+    } else {
+        low_x = 0;
+        high_x = main_width - 1;
+        low_y = 0;
+        high_y = main_height - 1;
+    }
+
+    for (int x = low_x; x <= high_x; x++) {
+        for (int y = low_y; y <= high_y; y++) {
+            int type = get_obj(x, y);
+
+            if (type == INVALID_OBJ) {
+                continue;
+            }
+
+            int theme = theme_for_grid_obj(type);
+
+            QRectF r2 = get_screen_rect(x, y + 1, 1, 1, RENDER_EPS);
+
+            draw_image(p, r2, 0, false, type, theme, 1.0, 0.0);
+        }
+    }
+
+    draw_entities(p, entities, 0);
+    draw_entities(p, entities, 1);
+
+    if (has_useful_vel_info && (options.paint_vel_info)) {
+        float infodim = rect.height() * .2;
+        QRectF dst2 = QRectF(0, 0, infodim, infodim);
+        int s1 = to_shade(.5 * agent->vx / maxspeed + .5);
+        int s2 = to_shade(.5 * agent->vy / max_jump + .5);
+        p.fillRect(dst2, QColor(s1, s1, s1));
+
+        QRectF dst3 = QRectF(infodim, 0, infodim, infodim);
+        p.fillRect(dst3, QColor(s2, s2, s2));
+    }
+}
+
+void BasicAbstractGame::set_pen_brush_color(QPainter &p, QColor color, int thickness) {
+    QBrush brush(color);
+    QPen pen(color, thickness);
+    p.setBrush(brush);
+    p.setPen(pen);
+}
+
+void BasicAbstractGame::draw_background(QPainter &p, const QRect &rect) {
+    p.fillRect(rect, QColor(0, 0, 0));
+
+    prepare_for_drawing(rect.height());
+
+    if (!options.use_backgrounds) {
+        return;
+    }
+
+    QRectF main_rect = get_screen_rect(0, main_height, main_width, main_height);
+
+    std::shared_ptr<QImage> background_image = main_bg_images_ptr->at(background_index);
+
+    if (bg_tile_ratio < 0) {
+        tile_image(p, background_image.get(), main_rect, bg_tile_ratio);
+    } else {
+        float bgw = background_image->width();
+        float bgh = background_image->height();
+        float bg_ar = bgw / bgh;
+
+        float world_ar = main_width * 1.0 / main_height;
+
+        float extra_w = bg_ar - world_ar;
+        float offset_x = bg_pct_x * extra_w;
+
+        QRectF bg_rect = adjust_rect(main_rect, QRectF(-offset_x, 0, bg_ar / world_ar, 1));
+        p.drawImage(bg_rect, *background_image);
+    }
+}
+
+void BasicAbstractGame::game_draw(QPainter &p, const QRect &rect) {
+    draw_background(p, rect);
+    draw_foreground(p, rect);
+}
+
+void BasicAbstractGame::match_aspect_ratio(const std::shared_ptr<Entity> &ent, bool match_width) {
+    int img_idx = ent->image_type + ent->image_theme * MAX_ASSETS;
+    initialize_asset_if_necessary(img_idx);
+
+    if (match_width) {
+        ent->ry = ent->rx / asset_aspect_ratios[img_idx];
+    } else {
+        ent->rx = ent->ry * asset_aspect_ratios[img_idx];
+    }
+}
+
+void BasicAbstractGame::fit_aspect_ratio(const std::shared_ptr<Entity> &ent) {
+    int img_idx = ent->image_type + ent->image_theme * MAX_ASSETS;
+    initialize_asset_if_necessary(img_idx);
+
+    float ar = asset_aspect_ratios[img_idx];
+
+    if (ar > 1) {
+        ent->ry = ent->rx / ar;
+    } else {
+        ent->rx = ent->ry * ar;
+    }
+}
+
+void BasicAbstractGame::choose_random_theme(const std::shared_ptr<Entity> &ent) {
+    initialize_asset_if_necessary(ent->image_type);
+    ent->image_theme = rand_gen.randn(asset_num_themes[ent->image_type]);
+}
+
+void BasicAbstractGame::choose_step_random_theme(const std::shared_ptr<Entity> &ent) {
+    initialize_asset_if_necessary(ent->image_type);
+    ent->image_theme = step_rand_int % asset_num_themes[ent->image_type];
+}
+
+bool BasicAbstractGame::should_draw_entity(const std::shared_ptr<Entity> &entity) {
+    return true;
+}
+
+void BasicAbstractGame::draw_entity(QPainter &p, const std::shared_ptr<Entity> &ent) {
+    if (should_draw_entity(ent)) {
+        QRectF r1 = get_object_rect(ent);
+        float tile_ratio = get_tile_aspect_ratio(ent);
+        draw_image(p, r1, ent->rotation, ent->is_reflected, ent->image_type, ent->image_theme, ent->alpha, tile_ratio);
+    }
+}
+
+void BasicAbstractGame::draw_entities(QPainter &p, const std::vector<std::shared_ptr<Entity>> &to_draw, int render_z) {
+    for (const auto &m : to_draw) {
+        if (m->render_z == render_z) {
+            draw_entity(p, m);
+        }
+    }
+}
+
+bool BasicAbstractGame::is_out_of_bounds(const std::shared_ptr<Entity> &e1) {
+    float x = e1->x;
+    float y = e1->y;
+    float rx = e1->rx;
+    float ry = e1->ry;
+
+    if (x + rx < 0)
+        return true;
+    if (y + ry < 0)
+        return true;
+    if (x - rx > main_width)
+        return true;
+    if (y - ry > main_height)
+        return true;
+
+    return false;
+}
+
+void BasicAbstractGame::step_entities(const std::vector<std::shared_ptr<Entity>> &given) {
+    int entities_count = (int)(given.size());
+
+    for (int i = entities_count - 1; i >= 0; i--) {
+        auto ent = given.at(i);
+
+        if (ent->smart_step) {
+            basic_step_object(ent);
+        }
+
+        ent->step();
+    }
+}
+
+float BasicAbstractGame::rand_pos(float r, float min, float max) {
+    fassert(min <= max);
+
+    if (max - min <= 2 * r)
+        return (max + min) / 2;
+    float range = max - min;
+    fassert(range >= 2 * r);
+    return (range - 2 * r) * rand_gen.rand01() + r + min;
+}
+
+float BasicAbstractGame::rand_pos(float r, float max) {
+    return rand_pos(r, 0, max);
+}
+
+bool BasicAbstractGame::has_any_collision(const std::shared_ptr<Entity> &e1, float margin) {
+    for (int i = (int)(entities.size()) - 1; i >= 0; i--) {
+        auto ent = entities.at(i);
+
+        if (!ent->avoids_collisions && has_collision(e1, ent, margin)) {
+            return true;
+        }
+    }
+
+    return false;
+}
+
+bool BasicAbstractGame::has_agent_collision(const std::shared_ptr<Entity> &e1) {
+    if (e1->type == PLAYER)
+        return false;
+
+    return has_collision(e1, agent, e1->collision_margin);
+}
+
+int BasicAbstractGame::find_entity_index(int type) {
+    int index = -1;
+
+    for (size_t i = 0; i < entities.size(); i++) {
+        if (entities[i]->type == type) {
+            index = i;
+        }
+    }
+
+    return index;
+}
+
+bool BasicAbstractGame::has_collision(const std::shared_ptr<Entity> &e1, const std::shared_ptr<Entity> &e2, float margin) {
+    float threshold_x = (e1->rx + e2->rx) + margin;
+    float threshold_y = (e1->ry + e2->ry) + margin;
+
+    return (fabs(e1->x - e2->x) < threshold_x) && (fabs(e1->y - e2->y) < threshold_y);
+}
+
+void BasicAbstractGame::write_entities(WriteBuffer *b, std::vector<std::shared_ptr<Entity>> &ents) {
+    b->write_int(ents.size());
+
+    for (size_t i = 0; i < ents.size(); i++) {
+        ents[i]->serialize(b);
+    }
+}
+
+void BasicAbstractGame::read_entities(ReadBuffer *b, std::vector<std::shared_ptr<Entity>> &ents) {
+    ents.resize(b->read_int());
+    for (size_t i = 0; i < ents.size(); i++) {
+        auto e = std::make_shared<Entity>();
+        e->deserialize(b);
+        ents[i] = e;
+    }
+}
+
+void BasicAbstractGame::serialize(WriteBuffer *b) {
+    Game::serialize(b);
+
+    b->write_int(grid_size);
+
+    write_entities(b, entities);
+
+    fassert(!options.use_generated_assets);
+    // these will be cleared and re-generated instead of being saved
+//     std::vector<std::shared_ptr<QImage>> basic_assets;
+//     std::vector<std::shared_ptr<QImage>> basic_reflections;
+//     std::vector<std::shared_ptr<QImage>> *main_bg_images_ptr;
+
+    // std::vector<float> asset_aspect_ratios;
+    // std::vector<int> asset_num_themes;
+
+    b->write_int(use_procgen_background);
+    b->write_int(background_index);
+    b->write_float(bg_tile_ratio);
+    b->write_float(bg_pct_x);
+
+    b->write_float(char_dim);
+    b->write_int(last_move_action);
+    b->write_int(move_action);
+    b->write_int(special_action);
+    b->write_float(mixrate);
+    b->write_float(maxspeed);
+    b->write_float(max_jump);
+
+    b->write_float(action_vx);
+    b->write_float(action_vy);
+    b->write_float(action_vrot);
+
+    b->write_float(center_x);
+    b->write_float(center_y);
+
+    b->write_int(random_agent_start);
+    b->write_int(has_useful_vel_info);
+    b->write_int(step_rand_int);
+
+    asset_rand_gen.serialize(b);
+
+    b->write_int(main_width);
+    b->write_int(main_height);
+    b->write_int(out_of_bounds_object);
+
+    b->write_float(unit);
+    b->write_float(view_dim);
+    b->write_float(x_off);
+    b->write_float(y_off);
+    b->write_float(visibility);
+    b->write_float(min_visibility);
+
+    grid.serialize(b);
+}
+
+void BasicAbstractGame::deserialize(ReadBuffer *b) {
+    Game::deserialize(b);
+
+    grid_size = b->read_int();
+
+    read_entities(b, entities);
+
+    int agent_idx = find_entity_index(PLAYER);
+    fassert(agent_idx >= 0);
+    agent = entities[agent_idx];
+
+    // we don't want to serialize a bunch of QImages
+    // for now we only support games that don't require storing these assets
+    fassert(!options.use_generated_assets);
+
+    // when restoring state (to the same game type) with generated assets disabled, these data structures contain cached
+    // asset data, and missing data will be filled in the same way in all environments
+//     std::vector<std::shared_ptr<QImage>> basic_assets;
+//     std::vector<std::shared_ptr<QImage>> basic_reflections;
+    // main_bg_images_ptr is set in game_init for all supported games, so it should always be the same
+//     std::vector<std::shared_ptr<QImage>> *main_bg_images_ptr;
+
+    // std::vector<float> asset_aspect_ratios;
+    // std::vector<int> asset_num_themes;
+
+    use_procgen_background = b->read_int();
+    background_index = b->read_int();
+    bg_tile_ratio = b->read_float();
+    bg_pct_x = b->read_float();
+
+    char_dim = b->read_float();
+    last_move_action = b->read_int();
+    move_action = b->read_int();
+    special_action = b->read_int();
+    mixrate = b->read_float();
+    maxspeed = b->read_float();
+    max_jump = b->read_float();
+
+    action_vx = b->read_float();
+    action_vy = b->read_float();
+    action_vrot = b->read_float();
+
+    center_x = b->read_float();
+    center_y = b->read_float();
+
+    random_agent_start = b->read_int();
+    has_useful_vel_info = b->read_int();
+    step_rand_int = b->read_int();
+
+    asset_rand_gen.deserialize(b);
+
+    main_width = b->read_int();
+    main_height = b->read_int();
+    out_of_bounds_object = b->read_int();
+
+    unit = b->read_float();
+    view_dim = b->read_float();
+    x_off = b->read_float();
+    y_off = b->read_float();
+    visibility = b->read_float();
+    min_visibility = b->read_float();
+
+    grid.deserialize(b);
+}
diff --git a/procgenAISC/procgen/src/basic-abstract-game.h b/procgenAISC/procgen/src/basic-abstract-game.h
new file mode 100644
index 0000000..e374e9e
--- /dev/null
+++ b/procgenAISC/procgen/src/basic-abstract-game.h
@@ -0,0 +1,174 @@
+#pragma once
+
+/*
+
+Base game class used by all currently existing games
+
+*/
+
+#include <string>
+#include <set>
+#include <queue>
+#include "game.h"
+#include "grid.h"
+#include "cpp-utils.h"
+
+class BasicAbstractGame : public Game {
+  public:
+    int grid_size = 0;
+
+    BasicAbstractGame(std::string name);
+    ~BasicAbstractGame();
+
+    // Game methods
+    void game_step() override;
+    void game_reset() override;
+    void game_draw(QPainter &p, const QRect &rect) override;
+    void game_init() override;
+    void serialize(WriteBuffer *b) override;
+    void deserialize(ReadBuffer *b) override;
+
+    void write_entities(WriteBuffer *b, std::vector<std::shared_ptr<Entity>> &ents);
+    void read_entities(ReadBuffer *b, std::vector<std::shared_ptr<Entity>> &ents);
+
+    virtual bool is_blocked(const std::shared_ptr<Entity> &src, int target, bool is_horizontal);
+    virtual bool is_blocked_ents(const std::shared_ptr<Entity> &src, const std::shared_ptr<Entity> &target, bool is_horizontal);
+    virtual bool will_reflect(int src, int target);
+    virtual void handle_agent_collision(const std::shared_ptr<Entity> &obj);
+    virtual void handle_grid_collision(const std::shared_ptr<Entity> &obj, int type, int i, int j);
+    virtual void handle_collision(const std::shared_ptr<Entity> &src, const std::shared_ptr<Entity> &target);
+    virtual float get_agent_acceleration_scale();
+    virtual bool use_block_asset(int type);
+    virtual float get_tile_aspect_ratio(const std::shared_ptr<Entity> &type);
+    virtual void asset_for_type(int type, std::vector<std::string> &names);
+    virtual void load_background_images();
+    virtual int image_for_type(int grid_obj);
+    virtual int theme_for_grid_obj(int type);
+    virtual bool should_preserve_type_themes(int type);
+    virtual QColor color_for_type(int type, int theme);
+    virtual void draw_grid_obj(QPainter &p, const QRectF &rect, int type, int theme);
+    virtual void choose_world_dim();
+    virtual bool should_draw_entity(const std::shared_ptr<Entity> &entity);
+    virtual void set_action_xy(int move_action);
+    virtual void choose_center(float &cx, float &cy);
+    virtual void update_agent_velocity();
+    virtual QRectF get_adjusted_image_rect(int type, const QRectF &rect);
+
+    void reserved_asset_for_type(int type, std::vector<std::string> &names);
+    void choose_step_random_theme(const std::shared_ptr<Entity> &ent);
+    bool use_procgen_asset(int type);
+    void decay_agent_velocity();
+    void tile_image(QPainter &p, std::shared_ptr<QImage> image, QRectF &rect, float tile_ratio);
+    void set_pen_brush_color(QPainter &p, QColor color, int thickness = 1);
+    void basic_step_object(const std::shared_ptr<Entity> &obj);
+    std::shared_ptr<Entity> spawn_entity_rxy(float rx, float ry, int type, float x, float y, float w, float h, bool check_collisions = true);
+    std::shared_ptr<Entity> spawn_entity(float r, int type, float x, float y, float w, float h, bool check_collisions = true);
+    std::shared_ptr<Entity> spawn_entity_at_idx(int idx, float r, int type);
+    std::shared_ptr<Entity> add_entity(float x, float y, float vx, float vy, float r, int type);
+    std::shared_ptr<Entity> add_entity_rxy(float x, float y, float vx, float vy, float rx, float ry, int type);
+    std::shared_ptr<Entity> spawn_child(const std::shared_ptr<Entity> &src, int type, float obj_r, bool match_vel = false);
+    void spawn_entities(int num_objects, float r, int type, float x, float y, float w, float h);
+    void reposition(const std::shared_ptr<Entity> &ent, float x, float y, float w, float h, bool check_collisions);
+    int get_obj(int i, int j);
+    int get_obj(int idx);
+    void set_obj(int i, int j, int obj);
+    void set_obj(int idx, int elem);
+    int to_grid_idx(int x, int y);
+    void to_grid_xy(int idx, int *x, int *y);
+    void fill_elem(int x, int y, int dx, int dy, char elem);
+    int get_obj_from_floats(float i, float j);
+    int get_agent_index();
+    std::vector<int> get_cells_with_type(int type);
+
+    void check_grid_collisions(const std::shared_ptr<Entity> &src);
+    float get_distance(const std::shared_ptr<Entity> &p0, const std::shared_ptr<Entity> &p1);
+    void match_aspect_ratio(const std::shared_ptr<Entity> &ent, bool match_width = true);
+    void fit_aspect_ratio(const std::shared_ptr<Entity> &ent);
+    void choose_random_theme(const std::shared_ptr<Entity> &ent);
+    int mask_theme_if_necessary(int theme, int type);
+    void tile_image(QPainter &p, QImage *image, const QRectF &rect, float tile_ratio);
+
+    float rand_pos(float r, float max);
+    float rand_pos(float r, float min, float max);
+    bool has_any_collision(const std::shared_ptr<Entity> &e1, float margin = 0);
+    bool has_agent_collision(const std::shared_ptr<Entity> &e1);
+    bool has_collision(const std::shared_ptr<Entity> &e1, const std::shared_ptr<Entity> &e2, float margin = 0);
+    bool is_out_of_bounds(const std::shared_ptr<Entity> &e1);
+    bool push_obj(const std::shared_ptr<Entity> &src, const std::shared_ptr<Entity> &target, bool is_horizontal, int depth);
+    float get_theta(const std::shared_ptr<Entity> &src, const std::shared_ptr<Entity> &target);
+    int find_entity_index(int type);
+
+    QRectF get_screen_rect(float x, float y, float dx, float dy, float render_eps = 0);
+    QRectF get_abs_rect(float x, float y, float dx, float dy);
+    QRectF get_object_rect(const std::shared_ptr<Entity> &obj);
+
+    void draw_foreground(QPainter &p, const QRect &rect);
+
+    void step_entities(const std::vector<std::shared_ptr<Entity>> &given);
+
+    void erase_if_needed();
+
+    bool agent_has_collision();
+    void reposition_agent();
+
+  protected:
+    std::shared_ptr<Entity> agent;
+    std::vector<std::shared_ptr<Entity>> entities;
+    std::vector<std::shared_ptr<QImage>> basic_assets;
+    std::vector<std::shared_ptr<QImage>> basic_reflections;
+    std::vector<std::shared_ptr<QImage>> *main_bg_images_ptr;
+
+    std::vector<float> asset_aspect_ratios;
+    std::vector<int> asset_num_themes;
+    
+    bool use_procgen_background = false;
+    int background_index = 0;
+    float bg_tile_ratio = 0.0f;
+    float bg_pct_x = 0.0f;
+
+    float char_dim = 0.0f;
+    int last_move_action = 0;
+    int move_action = 0;
+    int special_action = 0;
+    float mixrate = 0.0f;
+    float maxspeed = 0.0f;
+    float max_jump = 0.0f;
+
+    float action_vx = 0.0f;
+    float action_vy = 0.0f;
+    float action_vrot = 0.0f;
+
+    float center_x = 0.0f;
+    float center_y = 0.0f;
+
+    bool random_agent_start = true;
+    bool has_useful_vel_info = false;
+    int step_rand_int = 0;
+
+    RandGen asset_rand_gen;
+
+    int main_width = 0;
+    int main_height = 0;
+    int out_of_bounds_object = 0;
+
+    float unit = 0.0f;
+    float view_dim = 0.0f;
+    float x_off = 0.0f;
+    float y_off = 0.0f;
+    float visibility = 0.0f;
+    float min_visibility = 0.0f;
+
+  private:
+    Grid<int> grid;
+
+    QImage *lookup_asset(int img_idx, bool is_reflected = false);
+    void initialize_asset_if_necessary(int img_idx);
+    void prepare_for_drawing(float rect_height);
+    void draw_background(QPainter &p, const QRect &rect);
+    void draw_entity(QPainter &p, const std::shared_ptr<Entity> &to_draw);
+    void draw_entities(QPainter &p, const std::vector<std::shared_ptr<Entity>> &to_draw, int render_z = 0);
+    void draw_image(QPainter &p, QRectF &rect, float rotation, bool is_reflected, int img_idx, int theme, float alpha, float tile_ratio);
+
+    bool sub_step(const std::shared_ptr<Entity> &obj, float _vx, float _vy, int depth);
+    bool should_erase(const std::shared_ptr<Entity> &e1);
+};
diff --git a/procgenAISC/procgen/src/buffer.h b/procgenAISC/procgen/src/buffer.h
new file mode 100644
index 0000000..91716b9
--- /dev/null
+++ b/procgenAISC/procgen/src/buffer.h
@@ -0,0 +1,132 @@
+#pragma once
+
+#include "cpp-utils.h"
+#include <vector>
+#include <string>
+
+struct ReadBuffer {
+    char *data = nullptr;
+    size_t offset = 0;
+    size_t length = 0;
+
+    ReadBuffer(char *data, size_t length) : data(data), length(length) {
+    };
+
+    bool read_bool() {
+        return read_int() > 0;
+    };
+
+    std::vector<bool> read_vector_bool() {
+        std::vector<bool> v;
+        v.resize(read_int());
+        for (size_t i = 0; i < v.size(); i++) {
+            v[i] = read_bool();
+        }
+        return v;
+    };
+
+    int read_int() {
+        fassert(offset + sizeof(int) <= length);
+        auto d = (int*)(&data[offset]);
+        offset += sizeof(int);
+        return *d;
+    };
+
+    std::vector<int> read_vector_int() {
+        std::vector<int> v;
+        v.resize(read_int());
+        for (size_t i = 0; i < v.size(); i++) {
+            v[i] = read_int();
+        }
+        return v;
+    };
+
+    float read_float() {
+        fassert(offset + sizeof(float) <= length);
+        auto d = (float*)(&data[offset]);
+        offset += sizeof(float);
+        return *d;
+    };
+
+    std::vector<float> read_vector_float() {
+        std::vector<float> v;
+        v.resize(read_int());
+        for (size_t i = 0; i < v.size(); i++) {
+            v[i] = read_float();
+        }
+        return v;
+    };
+
+    std::string read_string() {
+        int size = read_int();
+        std::string s(size, '\x00');
+        fassert(offset + size <= length);
+        auto c = data + offset;
+        for (size_t i = 0; i < s.size(); i++) {
+            s[i] = *c;
+            c++;
+        }
+        offset += s.size();
+        return s;
+    };
+};
+
+struct WriteBuffer {
+    char *data = nullptr;
+    size_t offset = 0;
+    size_t length = 0;
+
+    WriteBuffer(char *data, size_t length) :  data(data), length(length) {
+    };
+
+    void write_bool(bool b) {
+        write_int(b ? 1 : 0);
+    };
+
+    void write_vector_bool(const std::vector<bool>& v) {
+        write_int(v.size());
+        for (auto i : v) {
+            write_bool(i);
+        }
+    };
+
+    void write_int(int i) {
+        fassert(offset + sizeof(int) <= length);
+        auto d = (int*)(&data[offset]);
+        *d = i;
+        offset += sizeof(int);
+    };
+
+
+    void write_vector_int(const std::vector<int>& v) {
+        write_int(v.size());
+        for (auto i : v) {
+            write_int(i);
+        }
+    };
+
+    void write_float(float f) {
+        fassert(offset + sizeof(float) <= length);
+        auto d = (float*)(&data[offset]);
+        *d = f;
+        offset += sizeof(float);
+    };
+
+    void write_vector_float(const std::vector<float>& v) {
+        write_int(v.size());
+        for (auto i : v) {
+            write_float(i);
+        }
+    };
+
+    void write_string(std::string s) {
+        fassert(offset + s.size() <= length);
+        write_int(s.size());
+        auto c = data + offset;
+        for (size_t i = 0; i < s.size(); i++) {
+            *c = s[i];
+            c++;
+        }
+        offset += s.size();
+    };
+};
\ No newline at end of file
diff --git a/procgenAISC/procgen/src/cpp-utils.cpp b/procgenAISC/procgen/src/cpp-utils.cpp
new file mode 100644
index 0000000..91f7151
--- /dev/null
+++ b/procgenAISC/procgen/src/cpp-utils.cpp
@@ -0,0 +1,20 @@
+#include "cpp-utils.h"
+#include <stdio.h>
+#include <stdarg.h>
+#include <stdlib.h>
+
+#ifdef __GNUC__
+// enable compile time checking of format arguments
+void
+    __attribute__((format(printf, 1, 0)))
+    fatal(const char *fmt, ...) {
+#else
+void fatal(const char *fmt, ...) {
+#endif
+    fprintf(stderr, "fatal: ");
+    va_list args;
+    va_start(args, fmt);
+    vprintf(fmt, args);
+    va_end(args);
+    exit(EXIT_FAILURE);
+}
\ No newline at end of file
diff --git a/procgenAISC/procgen/src/cpp-utils.h b/procgenAISC/procgen/src/cpp-utils.h
new file mode 100644
index 0000000..4855762
--- /dev/null
+++ b/procgenAISC/procgen/src/cpp-utils.h
@@ -0,0 +1,59 @@
+#pragma once
+
+#include <set>
+#include <cctype>
+#include <string>
+#include <algorithm>
+#include <stdio.h>
+#include <stdlib.h>
+
+// MSVC requires _USE_MATH_DEFINES to be set to define M_PI
+// and M_PI is interpreted as a double instead of a float anyway
+const float PI = 3.14159265358979323846264338327950288f;
+
+// assert() is disabled in release mode, use a custom assert function instead
+#define fassert(cond)                                                            \
+    do {                                                                         \
+        if (!(cond)) {                                                           \
+            printf("fassert failed '%s' at %s:%d\n", #cond, __FILE__, __LINE__); \
+            exit(EXIT_FAILURE);                                                  \
+        }                                                                        \
+    } while (0)
+
+// https://stackoverflow.com/a/12891181
+#ifdef __GNUC__
+#define UNUSED(x) UNUSED_##x __attribute__((__unused__))
+#else
+#define UNUSED(x) UNUSED_##x
+#endif
+
+#ifdef __GNUC__
+#define UNUSED_FUNCTION(x) __attribute__((__unused__)) UNUSED_##x
+#else
+#define UNUSED_FUNCTION(x) UNUSED_##x
+#endif
+
+template <typename T>
+bool set_contains(const std::set<T> &set, const T &item) {
+    return set.find(item) != set.end();
+}
+
+void fatal(const char *fmt, ...);
+
+inline double sign(double x) {
+    return x > 0 ? +1 : (x == 0 ? 0 : -1);
+}
+
+inline float clip_abs(float x, float y) {
+    if (x > y)
+        return y;
+    if (x < -y)
+        return -y;
+    return x;
+}
+
+inline std::string to_lower(std::string s) {
+    auto lc = s;
+    transform(lc.begin(), lc.end(), lc.begin(), [](unsigned char c){ return std::tolower(c); }); 
+    return lc;
+}
\ No newline at end of file
diff --git a/procgenAISC/procgen/src/entity.cpp b/procgenAISC/procgen/src/entity.cpp
new file mode 100644
index 0000000..a3bff92
--- /dev/null
+++ b/procgenAISC/procgen/src/entity.cpp
@@ -0,0 +1,177 @@
+#include "entity.h"
+
+#include <math.h>
+
+Entity::Entity() {
+}
+
+Entity::Entity(float _x, float _y, float _vx, float _vy, float _rx, float _ry, int _type) {
+    x = _x;
+    y = _y;
+    vx = _vx;
+    vy = _vy;
+    rx = _rx;
+    ry = _ry;
+    type = _type;
+    image_type = _type;
+    image_theme = 0;
+    will_erase = false;
+    collides_with_entities = false;
+    collision_margin = 0.0;
+    rotation = 0.0;
+    is_reflected = false;
+    vrot = 0.0;
+    alpha = 1.0;
+    grow_rate = 1.0;
+    alpha_decay = 1.0;
+
+    fire_time = -1;
+    spawn_time = -1;
+    expire_time = -1;
+    life_time = 0;
+
+    health = 1;
+    theta = -100;
+
+    friction = 1;
+    smart_step = false;
+    avoids_collisions = false;
+    auto_erase = true;
+    render_z = 0;
+    use_abs_coords = false;
+    climber_spawn_x = 0;
+
+    if (type == EXPLOSION) {
+        grow_rate = 1.4f;
+        expire_time = 4;
+    } else if (type == TRAIL) {
+        grow_rate = 1.05f;
+        alpha_decay = 0.8f;
+    }
+}
+
+Entity::Entity(float _x, float _y, float _vx, float _vy, float _r, int _type)
+    : Entity(_x, _y, _vx, _vy, _r, _r, _type) {
+}
+
+void Entity::step() {
+    if (!smart_step) {
+        x += vx;
+        y += vy;
+    }
+
+    rotation += vrot;
+
+    vx *= friction;
+    vy *= friction;
+    life_time += 1;
+
+    if (expire_time > 0 && life_time > expire_time) {
+        will_erase = true;
+    }
+
+    if (type == EXPLOSION) {
+        if (image_type < EXPLOSION5) {
+            image_type++;
+        }
+    }
+
+    rx *= grow_rate;
+    ry *= grow_rate;
+    alpha = alpha_decay * alpha;
+}
+
+void Entity::face_direction(float dx, float dy, float rotation_offset) {
+    if (dx != 0 || dy != 0) {
+        rotation = -1 * atan2(dy, dx) + rotation_offset;
+    }
+}
+
+void Entity::serialize(WriteBuffer *b) {
+    b->write_float(x);
+    b->write_float(y);
+
+    b->write_float(vx);
+    b->write_float(vy);
+
+    b->write_float(rx);
+    b->write_float(ry);
+
+    b->write_int(type);
+    b->write_int(image_type);
+    b->write_int(image_theme);
+
+    b->write_int(render_z);
+
+    b->write_int(will_erase);
+    b->write_int(collides_with_entities);
+
+    b->write_float(collision_margin);
+    b->write_float(rotation);
+    b->write_float(vrot);
+
+    b->write_int(is_reflected);
+    b->write_int(fire_time);
+    b->write_int(spawn_time);
+    b->write_int(life_time);
+    b->write_int(expire_time);
+    b->write_int(use_abs_coords);
+
+    b->write_float(friction);
+    b->write_int(smart_step);
+    b->write_int(avoids_collisions);
+    b->write_int(auto_erase);
+
+    b->write_float(alpha);
+    b->write_float(health);
+    b->write_float(theta);
+    b->write_float(grow_rate);
+    b->write_float(alpha_decay);
+    b->write_float(climber_spawn_x);
+
+    // not implemented, only used by fruitbot
+    // std::weak_ptr<Entity> relative;
+}
+
+void Entity::deserialize(ReadBuffer *b) {
+    x = b->read_float();
+    y = b->read_float();
+
+    vx = b->read_float();
+    vy = b->read_float();
+
+    rx = b->read_float();
+    ry = b->read_float();
+
+    type = b->read_int();
+    image_type = b->read_int();
+    image_theme = b->read_int();
+
+    render_z = b->read_int();
+
+    will_erase = b->read_int();
+    collides_with_entities = b->read_int();
+
+    collision_margin = b->read_float();
+    rotation = b->read_float();
+    vrot = b->read_float();
+
+    is_reflected = b->read_int();
+    fire_time = b->read_int();
+    spawn_time = b->read_int();
+    life_time = b->read_int();
+    expire_time = b->read_int();
+    use_abs_coords = b->read_int();
+
+    friction = b->read_float();
+    smart_step = b->read_int();
+    avoids_collisions = b->read_int();
+    auto_erase = b->read_int();
+
+    alpha = b->read_float();
+    health = b->read_float();
+    theta = b->read_float();
+    grow_rate = b->read_float();
+    alpha_decay = b->read_float();
+    climber_spawn_x = b->read_float();
+}
diff --git a/procgenAISC/procgen/src/entity.h b/procgenAISC/procgen/src/entity.h
new file mode 100644
index 0000000..d285a53
--- /dev/null
+++ b/procgenAISC/procgen/src/entity.h
@@ -0,0 +1,59 @@
+#pragma once
+
+#include "object-ids.h"
+#include "buffer.h"
+#include <memory>
+
+class Entity {
+  public:
+    float x = 0.0f;
+    float y = 0.0f;
+    float vx = 0.0f;
+    float vy = 0.0f;
+    float rx = 0.0f;
+    float ry = 0.0f; 
+    int type = 0;
+    int image_type = 0;
+    int image_theme = 0;
+
+    // Currently supports only 3 levels
+    // 1: render above other entities (at agent level)
+    // 0: standard rendering
+    // -1: render below grid objects
+    int render_z = 0;
+
+    bool will_erase = false;
+    bool collides_with_entities = false;
+    float collision_margin = 0.0f;
+    float rotation = 0.0f;
+    float vrot = 0.0f;
+    bool is_reflected = false;
+    int fire_time = 0;
+    int spawn_time = 0;
+    int life_time = 0;
+    int expire_time = 0;
+    bool use_abs_coords = false;
+
+    float friction = 0.0f;
+    bool smart_step = false;
+    bool avoids_collisions = false;
+    bool auto_erase = false;
+
+    // often not used
+    float alpha = 0.0f;
+    float health = 0.0f;
+    float theta = 0.0f;
+    float grow_rate = 0.0f;
+    float alpha_decay = 0.0f;
+    float climber_spawn_x = 0.0f;
+
+    Entity();
+    Entity(float _x, float _y, float _dx, float _dy, float _rx, float _ry, int _type);
+    Entity(float _x, float _y, float _dx, float _dy, float _r, int _type);
+
+    void step();
+    bool should_erase();
+    void face_direction(float dx, float dy, float rotation_offset = 0);
+    void serialize(WriteBuffer *b);
+    void deserialize(ReadBuffer *b);
+};
diff --git a/procgenAISC/procgen/src/game-registry.cpp b/procgenAISC/procgen/src/game-registry.cpp
new file mode 100644
index 0000000..77f326f
--- /dev/null
+++ b/procgenAISC/procgen/src/game-registry.cpp
@@ -0,0 +1,3 @@
+#include "game-registry.h"
+
+std::map<std::string, std::function<std::shared_ptr<Game>()>> *globalGameRegistry = nullptr;
\ No newline at end of file
diff --git a/procgenAISC/procgen/src/game-registry.h b/procgenAISC/procgen/src/game-registry.h
new file mode 100644
index 0000000..81cbacc
--- /dev/null
+++ b/procgenAISC/procgen/src/game-registry.h
@@ -0,0 +1,36 @@
+#pragma once
+
+/*
+
+This is a way to register game classes without having to update a central index of games
+
+Each game should include "game-registry.h" and call REGISTER_GAME("name", GameSubClass)
+
+*/
+
+#include <vector>
+#include <string>
+#include <map>
+#include <functional>
+#include <memory>
+#include "cpp-utils.h"
+
+class Game;
+
+#define REGISTER_GAME(name, cls)                                         \
+    static auto UNUSED_FUNCTION(_registration) = registerGame(name, [] { \
+        return std::make_shared<cls>();                                  \
+    })
+
+extern std::map<std::string, std::function<std::shared_ptr<Game>()>> *globalGameRegistry;
+
+template <typename Func>
+int registerGame(std::string name, Func fn) {
+    if (globalGameRegistry == nullptr) {
+        // because global initialization order is undefined in C++, supposedly
+        // we have to set this here
+        globalGameRegistry = new std::map<std::string, std::function<std::shared_ptr<Game>()>>();
+    }
+    (*globalGameRegistry)[name] = fn;
+    return 0;
+}
diff --git a/procgenAISC/procgen/src/game.cpp b/procgenAISC/procgen/src/game.cpp
new file mode 100644
index 0000000..d4c7805
--- /dev/null
+++ b/procgenAISC/procgen/src/game.cpp
@@ -0,0 +1,297 @@
+
+#include "game.h"
+#include "vecoptions.h"
+
+// this should be updated whenever the state format or environments may have changed
+const int SERIALIZE_VERSION = 0;
+
+void bgr32_to_rgb888(void *dst_rgb888, void *src_bgr32, int w, int h) {
+    uint8_t *src = (uint8_t *)src_bgr32;
+    uint8_t *dst = (uint8_t *)dst_rgb888;
+
+    for (int y = 0; y < h; y++) {
+        uint8_t *s = src + y * w * 4;
+        uint8_t *d = dst + y * w * 3;
+        for (int x = 0; x < w; x++) {
+            d[0] = s[2];
+            d[1] = s[1];
+            d[2] = s[0];
+            s += 4;
+            d += 3;
+        }
+    }
+}
+
+Game::Game(std::string name) : game_name(name) {
+    timeout = 1000;
+    episodes_remaining = 0;
+    last_reward = -1;
+    default_action = 0;
+    fixed_asset_seed = 0;
+    reset_count = 0;
+    current_level_seed = 0;
+
+    step_data.reward = 0;
+    step_data.done = true;
+    step_data.level_complete = false;
+}
+
+Game::~Game() {
+}
+
+void Game::parse_options(std::string name, VecOptions opts) {
+    opts.consume_bool("use_easy_jump", &options.use_easy_jump);
+    opts.consume_bool("paint_vel_info", &options.paint_vel_info);
+    opts.consume_bool("use_generated_assets", &options.use_generated_assets);
+    opts.consume_bool("use_monochrome_assets", &options.use_monochrome_assets);
+    opts.consume_bool("restrict_themes", &options.restrict_themes);
+    opts.consume_bool("use_backgrounds", &options.use_backgrounds);
+    opts.consume_bool("center_agent", &options.center_agent);
+    opts.consume_bool("use_sequential_levels", &options.use_sequential_levels);
+
+    opts.consume_int("random_percent", &options.random_percent); // changed
+    opts.consume_int("key_penalty", &options.key_penalty); // changed
+    opts.consume_int("step_penalty", &options.step_penalty); // changed
+    opts.consume_int("rand_region", &options.rand_region); //changed new
+    opts.consume_bool("continue_after_coin", &options.continue_after_coin); //changed new
+
+    int dist_mode = EasyMode;
+    opts.consume_int("distribution_mode", &dist_mode);
+    options.distribution_mode = static_cast<DistributionMode>(dist_mode);
+
+    if (options.distribution_mode == EasyMode) {
+        fassert(name != "coinrun_old");
+    } else if (options.distribution_mode == HardMode) {
+        // all environments support this mode
+    } else if (options.distribution_mode == ExtremeMode) {
+        fassert(name == "chaser" || name == "dodgeball" || name == "leaper" || name == "starpilot");
+    } else if (options.distribution_mode == MemoryMode) {
+        fassert(name == "caveflyer" || name == "dodgeball" || name == "heist" || name == "heist_aisc_many_chests" || name == "heist_aisc_many_keys" || name == "jumper" || name == "maze" || name == "miner");
+    } else {
+        fatal("invalid distribution_mode %d\n", options.distribution_mode);
+    }
+
+    // coinrun_old
+    opts.consume_int("plain_assets", &options.plain_assets);
+    opts.consume_int("physics_mode", &options.physics_mode);
+    opts.consume_int("debug_mode", &options.debug_mode);
+    // opts.consume_int("random_percent", &options.random_percent);
+    opts.consume_int("game_type", &game_type);
+
+    opts.ensure_empty();
+}
+
+void Game::render_to_buf(void *dst, int w, int h, bool antialias) {
+    // Qt focuses on RGB32 performance:
+    // https://doc.qt.io/qt-5/qpainter.html#performance
+    // so render to an RGB32 buffer and then convert it rather than render to RGB888 directly
+    QImage img((uchar *)dst, w, h, w * 4, QImage::Format_RGB32);
+    QPainter p(&img);
+
+    if (antialias) {
+        p.setRenderHint(QPainter::Antialiasing, true);
+        p.setRenderHint(QPainter::SmoothPixmapTransform, true);
+    }
+
+    QRect rect = QRect(0, 0, w, h);
+    game_draw(p, rect);
+}
+
+void Game::reset() {
+    reset_count++;
+
+    if (episodes_remaining == 0) {
+        if (options.use_sequential_levels && step_data.level_complete) {
+            // prevent overflow in seed sequences
+            current_level_seed = (int32_t)(current_level_seed + 997);
+        } else {
+            current_level_seed = level_seed_rand_gen.randint(level_seed_low, level_seed_high);
+        }
+
+        episodes_remaining = 1;
+    } else {
+        step_data.reward = 0;
+        step_data.done = false;
+        step_data.level_complete = false;
+    }
+
+    rand_gen.seed(current_level_seed);
+    game_reset();
+
+    cur_time = 0;
+    total_reward = 0;
+    episodes_remaining -= 1;
+    action = default_action;
+}
+
+void Game::step() {
+    cur_time += 1;
+    bool will_force_reset = false;
+
+    if (action == -1) {
+        action = default_action;
+        will_force_reset = true;
+    }
+
+    step_data.reward = 0;
+    step_data.done = false;
+    step_data.level_complete = false;
+    game_step();
+
+    step_data.done = step_data.done || will_force_reset || (cur_time >= timeout);
+    total_reward += step_data.reward;
+
+    if (step_data.reward != 0) {
+        last_reward_timer = 10;
+        last_reward = step_data.reward;
+    }
+
+    prev_level_seed = current_level_seed;
+
+    if (step_data.done) {
+        reset();
+    }
+
+    if (options.use_sequential_levels && step_data.level_complete) {
+        step_data.done = false;
+    }
+
+    episode_done = step_data.done;
+
+    observe();
+}
+
+void Game::observe() {
+    render_to_buf(render_buf, RES_W, RES_H, false);
+    bgr32_to_rgb888(obs_bufs[0], render_buf, RES_W, RES_H);
+    *reward_ptr = step_data.reward;
+    *first_ptr = (uint8_t)step_data.done;
+    *(int32_t *)(info_bufs[info_name_to_offset.at("prev_level_seed")]) = (int32_t)(prev_level_seed);
+    *(uint8_t *)(info_bufs[info_name_to_offset.at("prev_level_complete")]) = (uint8_t)(step_data.level_complete);
+    *(int32_t *)(info_bufs[info_name_to_offset.at("level_seed")]) = (int32_t)(current_level_seed);
+}
+
+void Game::game_init() {
+}
+
+void Game::serialize(WriteBuffer *b) {
+    b->write_int(SERIALIZE_VERSION);
+    
+    b->write_string(game_name);
+
+    b->write_int(options.paint_vel_info);
+    b->write_int(options.use_generated_assets);
+    b->write_int(options.use_monochrome_assets);
+    b->write_int(options.restrict_themes);
+    b->write_int(options.use_backgrounds);
+    b->write_int(options.center_agent);
+    b->write_int(options.debug_mode);
+    b->write_int(options.distribution_mode);
+    b->write_int(options.use_sequential_levels);
+
+    b->write_int(options.random_percent); // changed
+    b->write_int(options.key_penalty); // changed
+    b->write_int(options.step_penalty); // changed
+    b->write_int(options.rand_region); // changed new
+    b->write_int(options.continue_after_coin); // changed new
+
+    b->write_int(options.use_easy_jump);
+    b->write_int(options.plain_assets);
+    b->write_int(options.physics_mode);
+
+    b->write_int(grid_step);
+    b->write_int(level_seed_low);
+    b->write_int(level_seed_high);
+    b->write_int(game_type);
+    b->write_int(game_n);
+
+    level_seed_rand_gen.serialize(b);
+    rand_gen.serialize(b);
+
+    b->write_float(step_data.reward);
+    b->write_int(step_data.done);
+    b->write_int(step_data.level_complete);
+
+    b->write_int(action);
+    b->write_int(timeout);
+
+    b->write_int(current_level_seed);
+    b->write_int(prev_level_seed);
+    b->write_int(episodes_remaining);
+    b->write_int(episode_done);
+
+    b->write_int(last_reward_timer);
+    b->write_float(last_reward);
+    b->write_int(default_action);
+
+    b->write_int(fixed_asset_seed);
+
+    // don't save render buf as we will just re-write it on next observation
+    // uint32_t render_buf[RES_W * RES_H];
+
+    b->write_int(cur_time);
+    b->write_int(is_waiting_for_step);
+
+    // don't serialize these, since they are pointers, and will likely have incorrect values
+    // if deserialized into another game object
+    // int32_t *action_ptr;
+    // std::vector<void *> obs_bufs;
+    // std::vector<void *> info_bufs;
+    // float *reward_ptr = nullptr;
+    // uint8_t *first_ptr = nullptr;
+}
+
+void Game::deserialize(ReadBuffer *b) {
+    fassert(SERIALIZE_VERSION == b->read_int());
+    fassert(game_name == b->read_string());
+
+    options.paint_vel_info = b->read_int();
+    options.use_generated_assets = b->read_int();
+    options.use_monochrome_assets = b->read_int();
+    options.restrict_themes = b->read_int();
+    options.use_backgrounds = b->read_int();
+    options.center_agent = b->read_int();
+    options.debug_mode = b->read_int();
+    options.distribution_mode = DistributionMode(b->read_int());
+    options.use_sequential_levels = b->read_int();
+
+    options.random_percent = b->read_int();  // changed
+    options.key_penalty = b->read_int();  // changed
+    options.step_penalty = b->read_int();  // changed
+    options.rand_region = b->read_int(); // changed new
+    options.continue_after_coin = b->read_int(); // changed new
+
+    options.use_easy_jump = b->read_int();
+    options.plain_assets = b->read_int();
+    options.physics_mode = b->read_int();
+
+    grid_step = b->read_int();
+    level_seed_low = b->read_int();
+    level_seed_high = b->read_int();
+    game_type = b->read_int();
+    game_n = b->read_int();
+
+    level_seed_rand_gen.deserialize(b);
+    rand_gen.deserialize(b);
+
+    step_data.reward = b->read_float();
+    step_data.done = b->read_int();
+    step_data.level_complete = b->read_int();
+
+    action = b->read_int();
+    timeout = b->read_int();
+
+    current_level_seed = b->read_int();
+    prev_level_seed = b->read_int();
+    episodes_remaining = b->read_int();
+    episode_done = b->read_int();
+
+    last_reward_timer = b->read_int();
+    last_reward = b->read_float();
+    default_action = b->read_int();
+
+    fixed_asset_seed = b->read_int();
+
+    cur_time = b->read_int();
+    is_waiting_for_step = b->read_int();
+}
diff --git a/procgenAISC/procgen/src/game.h b/procgenAISC/procgen/src/game.h
new file mode 100644
index 0000000..f48eb3f
--- /dev/null
+++ b/procgenAISC/procgen/src/game.h
@@ -0,0 +1,133 @@
+#pragma once
+
+/*
+
+Base class used for all games, all games must inherit from this
+
+*/
+
+#include <QtGui/QPainter>
+#include <memory>
+#include <functional>
+#include <vector>
+#include <string>
+#include "entity.h"
+#include "randgen.h"
+#include "resources.h"
+#include "object-ids.h"
+#include "game-registry.h"
+#include "buffer.h"
+
+// We want all games to have same observation space. So all these
+// constants here related to observation space are constants forever.
+const int RES_W = 64;
+const int RES_H = 64;
+
+const int RENDER_RES = 512;
+
+void bgr32_to_rgb888(void *dst_rgb888, void *src_bgr32, int w, int h);
+
+class VecOptions;
+
+enum DistributionMode {
+    EasyMode = 0,
+    HardMode = 1,
+    ExtremeMode = 2,
+    MemoryMode = 10,
+};
+
+struct StepData {
+    float reward = 0.0f;
+    bool done = false;
+    bool level_complete = false;
+};
+
+struct GameOptions {
+    bool paint_vel_info = false;
+    bool use_generated_assets = false;
+    bool use_monochrome_assets = false;
+    bool restrict_themes = false;
+    bool use_backgrounds = true;
+    bool center_agent = false;
+    int debug_mode = 0;
+    DistributionMode distribution_mode = HardMode;
+    bool use_sequential_levels = false;
+
+    // added
+    int random_percent = 0;
+    int key_penalty = 0;
+    int step_penalty = 0;
+    int rand_region = 0;
+    bool continue_after_coin;
+
+    // coinrun_old
+    bool use_easy_jump = false;
+    int plain_assets = 0;
+    int physics_mode = 0;
+};
+
+class Game {
+  public:
+    const std::string game_name;
+    std::map<std::string, int> info_name_to_offset;
+
+    GameOptions options;
+
+    bool initial_reset_complete = false;
+    bool grid_step = false;
+    int level_seed_low = 0;
+    int level_seed_high = 1;
+    int game_type = 0;
+    int game_n = 0;
+
+    RandGen level_seed_rand_gen;
+    RandGen rand_gen;
+
+    StepData step_data;
+    int action = 0;
+
+    int timeout = 0;
+
+    int current_level_seed = 0;
+    int prev_level_seed = 0;
+    int episodes_remaining = 0;
+    bool episode_done = false;
+
+    int last_reward_timer = 0;
+    float last_reward = 0.0f;
+    int default_action = 0;
+
+    int fixed_asset_seed = 0;
+
+    uint32_t render_buf[RES_W * RES_H];
+
+    int cur_time = 0;
+
+    bool is_waiting_for_step = false;
+
+    // pointers to buffers
+    int32_t *action_ptr;
+    std::vector<void *> obs_bufs;
+    std::vector<void *> info_bufs;
+    float *reward_ptr = nullptr;
+    uint8_t *first_ptr = nullptr;
+
+    Game(std::string name);
+    void step();
+    void reset();
+    void render_to_buf(void *buf, int w, int h, bool antialias);
+    void parse_options(std::string name, VecOptions opt_vec);
+
+    virtual ~Game() = 0;
+    virtual void observe();
+    virtual void game_init() = 0;
+    virtual void game_reset() = 0;
+    virtual void game_step() = 0;
+    virtual void game_draw(QPainter &p, const QRect &rect) = 0;
+    virtual void serialize(WriteBuffer *b);
+    virtual void deserialize(ReadBuffer *b);
+
+  private:
+    int reset_count = 0;
+    float total_reward = 0.0f;
+};
diff --git a/procgenAISC/procgen/src/games/bigfish.cpp b/procgenAISC/procgen/src/games/bigfish.cpp
new file mode 100644
index 0000000..e47bbd4
--- /dev/null
+++ b/procgenAISC/procgen/src/games/bigfish.cpp
@@ -0,0 +1,121 @@
+#include "../basic-abstract-game.h"
+#include "../assetgen.h"
+#include <set>
+#include <queue>
+
+const std::string NAME = "bigfish";
+
+const int COMPLETION_BONUS = 10.0f;
+const int POSITIVE_REWARD = 1.0f;
+
+const int FISH = 2;
+
+const float FISH_MIN_R = .25;
+const float FISH_MAX_R = 2;
+
+const int FISH_QUOTA = 30;
+
+class BigFish : public BasicAbstractGame {
+  public:
+    int fish_eaten = 0;
+    float r_inc = 0.0;
+
+    BigFish()
+        : BasicAbstractGame(NAME) {
+        timeout = 6000;
+
+        main_width = 20;
+        main_height = 20;
+    }
+
+    void load_background_images() override {
+        main_bg_images_ptr = &water_backgrounds;
+    }
+
+    void asset_for_type(int type, std::vector<std::string> &names) override {
+        if (type == PLAYER) {
+            names.push_back("misc_assets/fishTile_072.png");
+        } else if (type == FISH) {
+            names.push_back("misc_assets/fishTile_074.png");
+            names.push_back("misc_assets/fishTile_078.png");
+            names.push_back("misc_assets/fishTile_080.png");
+        }
+    }
+
+    void handle_agent_collision(const std::shared_ptr<Entity> &obj) override {
+        BasicAbstractGame::handle_agent_collision(obj);
+
+        if (obj->type == FISH) {
+            if (obj->rx > agent->rx) {
+                step_data.done = true;
+            } else {
+                step_data.reward += POSITIVE_REWARD;
+                obj->will_erase = true;
+                agent->rx += r_inc;
+                agent->ry += r_inc;
+                fish_eaten += 1;
+            }
+        }
+    }
+
+    void game_reset() override {
+        BasicAbstractGame::game_reset();
+
+        options.center_agent = false;
+        fish_eaten = 0;
+
+        float start_r = .5;
+
+        if (options.distribution_mode == EasyMode) {
+            start_r = 1;
+        }
+
+        r_inc = (FISH_MAX_R - start_r) / FISH_QUOTA;
+
+        agent->rx = start_r;
+        agent->ry = start_r;
+        agent->y = 1 + agent->ry;
+    }
+
+    void game_step() override {
+        BasicAbstractGame::game_step();
+
+        if (rand_gen.randn(10) == 1) {
+            float ent_r = (FISH_MAX_R - FISH_MIN_R) * pow(rand_gen.rand01(), 1.4) + FISH_MIN_R;
+            float ent_y = rand_gen.rand01() * (main_height - 2 * ent_r);
+            float moves_right = rand_gen.rand01() < .5;
+            float ent_vx = (.15 + rand_gen.rand01() * .25) * (moves_right ? 1 : -1);
+            float ent_x = moves_right ? -1 * ent_r : main_width + ent_r;
+            int type = FISH;
+            auto ent = add_entity(ent_x, ent_y, ent_vx, 0, ent_r, type);
+            choose_random_theme(ent);
+            match_aspect_ratio(ent);
+            ent->is_reflected = !moves_right;
+        }
+
+        if (fish_eaten >= FISH_QUOTA) {
+            step_data.done = true;
+            step_data.reward += COMPLETION_BONUS;
+            step_data.level_complete = true;
+        }
+
+        if (action_vx > 0)
+            agent->is_reflected = false;
+        if (action_vx < 0)
+            agent->is_reflected = true;
+    }
+
+    void serialize(WriteBuffer *b) override {
+        BasicAbstractGame::serialize(b);
+        b->write_int(fish_eaten);
+        b->write_float(r_inc);
+    }
+
+    void deserialize(ReadBuffer *b) override {
+        BasicAbstractGame::deserialize(b);
+        fish_eaten = b->read_int();
+        r_inc = b->read_float();
+    }
+};
+
+REGISTER_GAME(NAME, BigFish);
diff --git a/procgenAISC/procgen/src/games/bossfight.cpp b/procgenAISC/procgen/src/games/bossfight.cpp
new file mode 100644
index 0000000..50ba817
--- /dev/null
+++ b/procgenAISC/procgen/src/games/bossfight.cpp
@@ -0,0 +1,480 @@
+#include "../basic-abstract-game.h"
+#include "../assetgen.h"
+#include <set>
+#include <queue>
+
+const std::string NAME = "bossfight";
+
+const int COMPLETION_BONUS = 10.0f;
+const int POSITIVE_REWARD = 1.0f;
+
+const int PLAYER_BULLET = 1;
+const int BOSS = 2;
+const int SHIELDS = 3;
+const int ENEMY_BULLET = 4;
+const int LASER_TRAIL = 5;
+const int REFLECTED_BULLET = 6;
+const int BARRIER = 7;
+
+const float BOSS_R = 3;
+
+const int NUM_ATTACK_MODES = 4;
+
+const int NUM_LASER_THEMES = 3;
+
+const int PLAYER_BULLET_VEL = 1;
+
+const int BOTTOM_MARGIN = 6;
+
+const int BOSS_VEL_TIMEOUT = 20;
+const int BOSS_DAMAGED_TIMEOUT = 40;
+
+class BossfightGame : public BasicAbstractGame {
+  public:
+    std::shared_ptr<Entity> boss, shields;
+    std::vector<int> attack_modes;
+    int last_fire_time = 0;
+    int time_to_swap = 0;
+    int invulnerable_duration = 0;
+    int vulnerable_duration = 0;
+    int num_rounds = 0;
+    int round_num = 0;
+    int round_health = 0;
+    int boss_vel_timeout = 0;
+    int curr_vel_timeout = 0;
+    int attack_mode = 0;
+    int player_laser_theme = 0;
+    int boss_laser_theme = 0;
+    int damaged_until_time = 0;
+    
+    bool shields_are_up = false;
+    bool barriers_moves_right = false;
+    float base_fire_prob = 0.0f;
+    float boss_bullet_vel = 0.0f;
+    float barrier_vel = 0.0f;
+    float barrier_spawn_prob = 0.0f;
+    float rand_pct = 0.0f;
+    float rand_fire_pct = 0.0f;
+    float rand_pct_x = 0.0f;
+    float rand_pct_y = 0.0f;
+
+    BossfightGame()
+        : BasicAbstractGame(NAME) {
+        timeout = 4000;
+
+        main_width = 20;
+        main_height = 20;
+
+        mixrate = .5;
+        maxspeed = 0.85f;
+    }
+
+    void load_background_images() override {
+        main_bg_images_ptr = &space_backgrounds;
+    }
+
+    void asset_for_type(int type, std::vector<std::string> &names) override {
+        if (type == PLAYER) {
+            names.push_back("misc_assets/playerShip1_blue.png");
+            names.push_back("misc_assets/playerShip1_green.png");
+            names.push_back("misc_assets/playerShip2_orange.png");
+            names.push_back("misc_assets/playerShip3_red.png");
+        } else if (type == BOSS) {
+            names.push_back("misc_assets/enemyShipBlack1.png");
+            names.push_back("misc_assets/enemyShipBlue2.png");
+            names.push_back("misc_assets/enemyShipGreen3.png");
+            names.push_back("misc_assets/enemyShipRed4.png");
+        } else if (type == ENEMY_BULLET) {
+            names.push_back("misc_assets/laserGreen14.png");
+            names.push_back("misc_assets/laserRed11.png");
+            names.push_back("misc_assets/laserBlue09.png");
+        } else if (type == PLAYER_BULLET) {
+            names.push_back("misc_assets/laserGreen14.png");
+            names.push_back("misc_assets/laserRed11.png");
+            names.push_back("misc_assets/laserBlue09.png");
+        } else if (type == SHIELDS) {
+            names.push_back("misc_assets/shield2.png");
+        } else if (type == BARRIER) {
+            names.push_back("misc_assets/spaceMeteors_001.png");
+            names.push_back("misc_assets/spaceMeteors_002.png");
+            names.push_back("misc_assets/spaceMeteors_003.png");
+            names.push_back("misc_assets/spaceMeteors_004.png");
+            names.push_back("misc_assets/meteorGrey_big1.png");
+            names.push_back("misc_assets/meteorGrey_big2.png");
+            names.push_back("misc_assets/meteorGrey_big3.png");
+            names.push_back("misc_assets/meteorGrey_big4.png");
+        }
+    }
+
+    void handle_agent_collision(const std::shared_ptr<Entity> &obj) override {
+        BasicAbstractGame::handle_agent_collision(obj);
+
+        if (obj->type == BOSS) {
+            step_data.done = true;
+        } else if (obj->type == BARRIER) {
+            step_data.done = true;
+        }
+        if (obj->type == ENEMY_BULLET) {
+            step_data.done = true;
+        }
+    }
+
+    bool should_draw_entity(const std::shared_ptr<Entity> &entity) override {
+        if (entity->type == SHIELDS)
+            return shields_are_up;
+
+        return BasicAbstractGame::should_draw_entity(entity);
+    }
+
+    void handle_collision(const std::shared_ptr<Entity> &src, const std::shared_ptr<Entity> &target) override {
+        if (src->type == PLAYER_BULLET) {
+            bool will_erase = false;
+
+            if (target->type == SHIELDS) {
+                if (shields_are_up) {
+                    src->type = REFLECTED_BULLET;
+
+                    float theta = PI * (1.25 + .5 * rand_pct);
+                    src->vy = PLAYER_BULLET_VEL * sin(theta) * .5;
+                    src->vx = PLAYER_BULLET_VEL * cos(theta) * .5;
+                    src->expire_time = 4;
+                    src->life_time = 0;
+                    src->alpha_decay = 0.8f;
+                }
+            } else if (target->type == BOSS) {
+                if (!shields_are_up) {
+                    target->health -= 1;
+                    will_erase = true;
+
+                    if (int(target->health) % round_health == 0) {
+                        step_data.reward += POSITIVE_REWARD;
+
+                        if (target->health == 0) {
+                            step_data.done = true;
+                            step_data.reward += COMPLETION_BONUS;
+                            step_data.level_complete = true;
+                        } else {
+                            round_num++;
+                            prepare_boss();
+                            curr_vel_timeout = BOSS_DAMAGED_TIMEOUT;
+                            damaged_until_time = cur_time + BOSS_DAMAGED_TIMEOUT;
+                        }
+                    }
+                }
+            }
+
+            if (will_erase && !src->will_erase) {
+                src->will_erase = true;
+
+                auto explosion = spawn_child(src, EXPLOSION, .5 * src->rx);
+                explosion->vx = target->vx;
+                explosion->vy = target->vy;
+            }
+        } else if (src->type == BARRIER) {
+            if (target->type == ENEMY_BULLET || target->type == PLAYER_BULLET) {
+                target->will_erase = true;
+                spawn_child(target, EXPLOSION, .5 * target->rx);
+            } else if (target->type == LASER_TRAIL) {
+                target->will_erase = true;
+            }
+
+            if (src->health <= 0) {
+                if (!src->will_erase) {
+                    auto explosion = spawn_child(src, EXPLOSION, .5 * src->rx);
+                    explosion->vx = src->vx;
+                    explosion->vy = src->vy;
+                }
+
+                src->will_erase = true;
+            }
+        }
+    }
+
+    void prepare_boss() {
+        shields_are_up = true;
+        curr_vel_timeout = boss_vel_timeout;
+        time_to_swap = invulnerable_duration;
+        attack_mode = attack_modes[round_num % attack_modes.size()];
+        boss->vx = 0;
+        boss->vy = 0;
+    }
+
+    void game_reset() override {
+        BasicAbstractGame::game_reset();
+
+        damaged_until_time = 0;
+        last_fire_time = 0;
+        boss_bullet_vel = options.distribution_mode == EasyMode ? .5 : .75;
+        int max_extra_invulnerable = options.distribution_mode == EasyMode ? 1 : 3;
+
+        options.center_agent = false;
+
+        boss = add_entity(main_width / 2, main_height / 2, 0, 0, BOSS_R, BOSS);
+        choose_random_theme(boss);
+        match_aspect_ratio(boss);
+
+        shields = add_entity_rxy(boss->x, boss->y, 0, 0, 1.2 * boss->rx, 1.2 * boss->ry, SHIELDS);
+
+        boss_vel_timeout = BOSS_VEL_TIMEOUT;
+        base_fire_prob = 0.1f;
+        round_health = rand_gen.randn(9) + 1;
+        num_rounds = 1 + rand_gen.randn(5);
+        invulnerable_duration = 2 + rand_gen.randn(max_extra_invulnerable + 1);
+        vulnerable_duration = 500; // essentially infinite
+
+        boss->health = round_health * num_rounds;
+
+        choose_random_theme(agent);
+
+        player_laser_theme = rand_gen.randn(NUM_LASER_THEMES);
+        boss_laser_theme = rand_gen.randn(NUM_LASER_THEMES);
+
+        attack_modes.clear();
+
+        for (int i = 0; i < num_rounds; i++) {
+            attack_modes.push_back(rand_gen.randn(NUM_ATTACK_MODES));
+        }
+
+        round_num = 0;
+        prepare_boss();
+
+        agent->rx = .75;
+        match_aspect_ratio(agent);
+        reposition_agent();
+        agent->y = agent->ry;
+
+        barrier_vel = 0.1f;
+        barriers_moves_right = rand_gen.randbool();
+        barrier_spawn_prob = 0.025f;
+
+        spawn_barriers();
+
+        // for (int i = 0; i < main_width / barrier_vel; i++) {
+        //     spawn_barriers();
+        //     step_entities(entities);
+        // }
+    }
+
+    void boss_fire(float bullet_r, float vel, float theta) {
+        auto new_bullet = add_entity(boss->x, boss->y, vel * cos(theta), vel * sin(theta), bullet_r, ENEMY_BULLET);
+        new_bullet->image_theme = boss_laser_theme;
+        new_bullet->expire_time = 50;
+        new_bullet->vrot = PI / 8;
+    }
+
+    void passive_attack_mode() {
+        if (rand_fire_pct < base_fire_prob) {
+            boss_fire(.5, boss_bullet_vel, PI * (1 + rand_pct));
+        }
+    }
+
+    void attack_mode_0() {
+        if (cur_time % 8 == 0) {
+            for (int i = 0; i < 5; i++) {
+                boss_fire(.5, boss_bullet_vel, PI * 1.5 + (i - 2) * PI / 8);
+            }
+        }
+    }
+
+    void attack_mode_1() {
+        int dt = 5;
+        if (cur_time % dt == 0) {
+            int k = cur_time / dt;
+            k = abs(8 - (k % 16));
+            for (int i = 0; i < 4; i++) {
+                boss_fire(.5, boss_bullet_vel, PI * (1.25 + .5 * k / 8.0) + i * PI / 2);
+            }
+        }
+    }
+
+    void attack_mode_2() {
+        if (cur_time % 10 == 0) {
+            int num_bullets = 8;
+            float offset = rand_pct * 2 * PI;
+            for (int i = 0; i < num_bullets; i++) {
+                float vel = boss_bullet_vel;
+                float theta = 2 * PI / num_bullets * i + offset;
+                boss_fire(.5, vel, theta);
+            }
+        }
+    }
+
+    void attack_mode_3() {
+        if (cur_time % 4 == 0) {
+            boss_fire(.5, boss_bullet_vel, PI * (1 + rand_pct));
+        }
+    }
+
+    void damaged_mode() {
+        if (cur_time % 3 == 0) {
+            float pos_x = boss->x + (2 * rand_pct_x - 1) * boss->rx;
+            float pos_y = boss->y + (2 * rand_pct_y - 1) * boss->ry;
+            add_entity(pos_x, pos_y, 0, 0, .75, EXPLOSION);
+        }
+    }
+
+    void active_attack() {
+        if (attack_mode == 0) {
+            attack_mode_0();
+        } else if (attack_mode == 1) {
+            attack_mode_1();
+        } else if (attack_mode == 2) {
+            attack_mode_2();
+        } else if (attack_mode == 3) {
+            attack_mode_3();
+        }
+    }
+
+    void spawn_barriers() {
+        int num_barriers = rand_gen.randn(3) + 1;
+        for (int i = 0; i < num_barriers; i++) {
+            float barrier_r = 0.6f;
+            float min_barrier_y = 2 * agent->ry + barrier_r + .5;
+            float ent_y = rand_gen.rand01() * (BOTTOM_MARGIN - min_barrier_y - barrier_r) + min_barrier_y;
+            float ent_x = rand_gen.rand01() * (main_width - 2 * barrier_r) + barrier_r;
+
+            auto ent = std::make_shared<Entity>(ent_x, ent_y, 0, 0, barrier_r, BARRIER);
+            choose_random_theme(ent);
+            match_aspect_ratio(ent);
+            ent->health = 3;
+            ent->collides_with_entities = true;
+
+            if (!has_any_collision(ent)) {
+                entities.push_back(ent);
+            }
+        }
+    }
+
+    void game_step() override {
+        BasicAbstractGame::game_step();
+
+        // spawn_barriers();
+
+        shields->x = boss->x;
+        shields->y = boss->y;
+
+        rand_pct = rand_gen.rand01();
+        rand_fire_pct = rand_gen.rand01();
+        rand_pct_x = rand_gen.rand01();
+        rand_pct_y = rand_gen.rand01();
+
+        if (curr_vel_timeout <= 0) {
+            float dest_x = rand_pct_x * (main_width - 2 * BOSS_R) + BOSS_R;
+            float dest_y = rand_pct_y * (main_height - 2 * BOSS_R - BOTTOM_MARGIN) + BOSS_R + BOTTOM_MARGIN;
+            boss->vx = (dest_x - boss->x) / boss_vel_timeout;
+            boss->vy = (dest_y - boss->y) / boss_vel_timeout;
+            curr_vel_timeout = boss_vel_timeout;
+
+            if (time_to_swap > 0) {
+                time_to_swap -= 1;
+            } else {
+                if (shields_are_up) {
+                    time_to_swap = vulnerable_duration;
+                } else {
+                    time_to_swap = invulnerable_duration;
+                }
+
+                shields_are_up = !shields_are_up;
+            }
+        } else {
+            curr_vel_timeout -= 1;
+        }
+
+        if (special_action == 1 && (cur_time - last_fire_time) >= 3) {
+            auto new_bullet = add_entity(agent->x, agent->y, 0, PLAYER_BULLET_VEL, .25, PLAYER_BULLET);
+            new_bullet->image_theme = player_laser_theme;
+            new_bullet->collides_with_entities = true;
+            new_bullet->expire_time = 25;
+            last_fire_time = cur_time;
+        }
+
+        if (damaged_until_time >= cur_time) {
+            damaged_mode();
+        } else if (shields_are_up) {
+            active_attack();
+        } else {
+            passive_attack_mode();
+        }
+
+        for (int i = (int)(entities.size()) - 1; i >= 0; i--) {
+            auto ent = entities[i];
+
+            if (ent->type == ENEMY_BULLET) {
+                float v_trail = .5;
+                auto trail = add_entity_rxy(ent->x, ent->y, ent->vx * v_trail, ent->vy * v_trail, ent->rx, ent->ry, LASER_TRAIL);
+                trail->alpha_decay = 0.7f;
+                trail->image_type = ENEMY_BULLET;
+                trail->image_theme = boss_laser_theme;
+                trail->vrot = ent->vrot;
+                trail->rotation = ent->rotation;
+                trail->expire_time = 8;
+            }
+        }
+    }
+
+    void serialize(WriteBuffer *b) override {
+        BasicAbstractGame::serialize(b);
+        b->write_vector_int(attack_modes);
+        b->write_int(last_fire_time);
+        b->write_int(time_to_swap);
+        b->write_int(invulnerable_duration);
+        b->write_int(vulnerable_duration);
+        b->write_int(num_rounds);
+        b->write_int(round_num);
+        b->write_int(round_health);
+        b->write_int(boss_vel_timeout);
+        b->write_int(curr_vel_timeout);
+        b->write_int(attack_mode);
+        b->write_int(player_laser_theme);
+        b->write_int(boss_laser_theme);
+        b->write_int(damaged_until_time);
+        b->write_bool(shields_are_up);
+        b->write_bool(barriers_moves_right);
+        b->write_float(base_fire_prob);
+        b->write_float(boss_bullet_vel);
+        b->write_float(barrier_vel);
+        b->write_float(barrier_spawn_prob);
+        b->write_float(rand_pct);
+        b->write_float(rand_fire_pct);
+        b->write_float(rand_pct_x);
+        b->write_float(rand_pct_y);
+    }
+
+    void deserialize(ReadBuffer *b) override {
+        BasicAbstractGame::deserialize(b);
+        attack_modes = b->read_vector_int();
+        last_fire_time = b->read_int();
+        time_to_swap = b->read_int();
+        invulnerable_duration = b->read_int();
+        vulnerable_duration = b->read_int();
+        num_rounds = b->read_int();
+        round_num = b->read_int();
+        round_health = b->read_int();
+        boss_vel_timeout = b->read_int();
+        curr_vel_timeout = b->read_int();
+        attack_mode = b->read_int();
+        player_laser_theme = b->read_int();
+        boss_laser_theme = b->read_int();
+        damaged_until_time = b->read_int();
+        shields_are_up = b->read_bool();
+        barriers_moves_right = b->read_bool();
+        base_fire_prob = b->read_float();
+        boss_bullet_vel = b->read_float();
+        barrier_vel = b->read_float();
+        barrier_spawn_prob = b->read_float();
+        rand_pct = b->read_float();
+        rand_fire_pct = b->read_float();
+        rand_pct_x = b->read_float();
+        rand_pct_y = b->read_float();
+
+        int boss_idx = find_entity_index(BOSS);
+        fassert(boss_idx >= 0);
+        boss = entities[boss_idx];
+
+        int shields_idx = find_entity_index(SHIELDS);
+        fassert(shields_idx >= 0);
+        shields = entities[shields_idx];
+    }
+};
+
+REGISTER_GAME(NAME, BossfightGame);
diff --git a/procgenAISC/procgen/src/games/caveflyer.cpp b/procgenAISC/procgen/src/games/caveflyer.cpp
new file mode 100644
index 0000000..37986dd
--- /dev/null
+++ b/procgenAISC/procgen/src/games/caveflyer.cpp
@@ -0,0 +1,327 @@
+#include "../basic-abstract-game.h"
+#include "../assetgen.h"
+#include "../roomgen.h"
+#include <set>
+#include <queue>
+
+const std::string NAME = "caveflyer";
+
+const float GOAL_REWARD = 10.0f;
+const float TARGET_REWARD = 3.0f;
+
+const int GOAL = 1;
+const int OBSTACLE = 2;
+const int TARGET = 3;
+const int PLAYER_BULLET = 4;
+const int ENEMY = 5;
+const int CAVEWALL = 8;
+const int EXHAUST = 9;
+
+const int MARKER = 1003;
+
+class CaveFlyerGame : public BasicAbstractGame {
+  public:
+    std::unique_ptr<RoomGenerator> room_manager;
+
+    CaveFlyerGame()
+        : BasicAbstractGame(NAME) {
+        mixrate = 0.9f;
+        room_manager = std::make_unique<RoomGenerator>(this);
+    }
+
+    void load_background_images() override {
+        main_bg_images_ptr = &space_backgrounds;
+    }
+
+    void asset_for_type(int type, std::vector<std::string> &names) override {
+        if (type == GOAL) {
+            names.push_back("misc_assets/ufoGreen2.png");
+        } else if (type == OBSTACLE) {
+            names.push_back("misc_assets/meteorBrown_big1.png");
+        } else if (type == TARGET) {
+            names.push_back("misc_assets/ufoRed2.png");
+        } else if (type == PLAYER_BULLET) {
+            names.push_back("misc_assets/laserBlue02.png");
+        } else if (type == ENEMY) {
+            names.push_back("misc_assets/enemyShipBlue4.png");
+        } else if (type == PLAYER) {
+            names.push_back("misc_assets/playerShip1_red.png");
+        } else if (type == CAVEWALL) {
+            names.push_back("misc_assets/groundA.png");
+        } else if (type == EXHAUST) {
+            names.push_back("misc_assets/towerDefense_tile295.png");
+        }
+    }
+
+    void handle_agent_collision(const std::shared_ptr<Entity> &obj) override {
+        BasicAbstractGame::handle_agent_collision(obj);
+
+        if (obj->type == GOAL) {
+            step_data.reward += GOAL_REWARD;
+            step_data.level_complete = true;
+            step_data.done = true;
+        } else if (obj->type == OBSTACLE) {
+            step_data.done = true;
+        } else if (obj->type == ENEMY) {
+            step_data.done = true;
+        } else if (obj->type == TARGET) {
+            step_data.done = true;
+        }
+    }
+
+    void update_agent_velocity() override {
+        float v_scale = get_agent_acceleration_scale();
+
+        agent->vx += mixrate * maxspeed * action_vx * v_scale * .2;
+        agent->vy += mixrate * maxspeed * action_vy * v_scale * .2;
+
+        decay_agent_velocity();
+    }
+
+    bool use_block_asset(int type) override {
+        return BasicAbstractGame::use_block_asset(type) || (type == CAVEWALL);
+    }
+
+    bool is_blocked(const std::shared_ptr<Entity> &src, int target, bool is_horizontal) override {
+        if (BasicAbstractGame::is_blocked(src, target, is_horizontal))
+            return true;
+        if (src->type == PLAYER && target == CAVEWALL)
+            return true;
+
+        return false;
+    }
+
+    void handle_collision(const std::shared_ptr<Entity> &src, const std::shared_ptr<Entity> &target) override {
+        if (target->type == PLAYER_BULLET) {
+            bool erase_bullet = false;
+
+            if (src->type == TARGET) {
+                src->health -= 1;
+                erase_bullet = true;
+
+                if (src->health <= 0 && !src->will_erase) {
+                    spawn_child(src, EXPLOSION, .5 * src->rx);
+                    src->will_erase = true;
+                    step_data.reward += TARGET_REWARD;
+                }
+            } else if (src->type == OBSTACLE) {
+                erase_bullet = true;
+            } else if (src->type == ENEMY) {
+                erase_bullet = true;
+            } else if (src->type == GOAL) {
+                erase_bullet = true;
+            }
+
+            if (erase_bullet && !target->will_erase) {
+                target->will_erase = true;
+                auto explosion = spawn_child(target, EXPLOSION, .5 * target->rx);
+                explosion->vx = src->vx;
+                explosion->vy = src->vy;
+            }
+        }
+    }
+
+    bool will_reflect(int src, int target) override {
+        return BasicAbstractGame::will_reflect(src, target) || (src == ENEMY && (target == CAVEWALL || target == out_of_bounds_object));
+    }
+
+    void choose_world_dim() override {
+        DistributionMode dist_diff = options.distribution_mode;
+
+        int world_dim = 20;
+
+        if (dist_diff == EasyMode) {
+            world_dim = 30;
+        } else if (dist_diff == HardMode) {
+            world_dim = 40;
+        } else if (dist_diff == MemoryMode) {
+            world_dim = 60;
+        }
+
+        main_width = world_dim;
+        main_height = world_dim;
+    }
+
+    void game_reset() override {
+        BasicAbstractGame::game_reset();
+
+        out_of_bounds_object = WALL_OBJ;
+
+        for (int i = 0; i < grid_size; i++) {
+            if (rand_gen.rand01() < .5) {
+                set_obj(i, WALL_OBJ);
+            } else {
+                set_obj(i, SPACE);
+            }
+        }
+
+        for (int iteration = 0; iteration < 4; iteration++) {
+            room_manager->update();
+        }
+
+        std::set<int> best_room;
+        room_manager->find_best_room(best_room);
+        fassert(best_room.size() > 0);
+
+        for (int i = 0; i < grid_size; i++) {
+            set_obj(i, WALL_OBJ);
+        }
+
+        std::vector<int> free_cells;
+
+        for (int i : best_room) {
+            set_obj(i, SPACE);
+            free_cells.push_back(i);
+        }
+
+        std::vector<int> selected_idxs = rand_gen.simple_choose((int)(free_cells.size()), 2);
+        int agent_cell = free_cells[selected_idxs[0]];
+        int goal_cell = free_cells[selected_idxs[1]];
+
+        agent->x = (agent_cell % main_width) + .5;
+        agent->y = (agent_cell / main_width) + .5;
+
+        auto ent = spawn_entity_at_idx(goal_cell, .5, GOAL);
+        ent->collides_with_entities = true;
+
+        std::vector<int> goal_path;
+        room_manager->find_path(agent_cell, goal_cell, goal_path);
+
+        bool should_prune = options.distribution_mode != MemoryMode;
+
+        if (should_prune) {
+            std::set<int> wide_path;
+            wide_path.insert(goal_path.begin(), goal_path.end());
+            room_manager->expand_room(wide_path, 4);
+
+            for (int i = 0; i < grid_size; i++) {
+                set_obj(i, WALL_OBJ);
+            }
+
+            for (int i : wide_path) {
+                set_obj(i, SPACE);
+            }
+        }
+
+        for (int iteration = 0; iteration < 4; iteration++) {
+            room_manager->update();
+
+            for (int i : goal_path) {
+                set_obj(i, SPACE);
+            }
+        }
+
+        for (int i : goal_path) {
+            set_obj(i, MARKER);
+        }
+
+        free_cells.clear();
+
+        for (int i = 0; i < grid_size; i++) {
+            if (get_obj(i) == SPACE) {
+                free_cells.push_back(i);
+            } else if (get_obj(i) == WALL_OBJ) {
+                set_obj(i, CAVEWALL);
+            }
+        }
+
+        int chunk_size = ((int)(free_cells.size()) / 80);
+        int num_objs = 3 * chunk_size;
+
+        std::vector<int> obstacle_idxs = rand_gen.simple_choose((int)(free_cells.size()), num_objs);
+
+        for (int i = 0; i < num_objs; i++) {
+            int val = free_cells[obstacle_idxs[i]];
+
+            if (i < chunk_size) {
+                auto e = spawn_entity_at_idx(val, .5, OBSTACLE);
+                e->collides_with_entities = true;
+            } else if (i < 2 * chunk_size) {
+                auto e = spawn_entity_at_idx(val, .5, TARGET);
+                e->health = 5;
+                e->collides_with_entities = true;
+            } else {
+                auto e = spawn_entity_at_idx(val, .5, ENEMY);
+                float vel = (.1 * rand_gen.rand01() + .1) * (rand_gen.randn(2) * 2 - 1);
+                if (rand_gen.rand01() < .5) {
+                    e->vx = vel;
+                } else {
+                    e->vy = vel;
+                }
+                e->smart_step = true;
+                e->collides_with_entities = true;
+            }
+        }
+
+        for (int i = 0; i < grid_size; i++) {
+            int val = get_obj(i);
+            if (val == MARKER)
+                val = SPACE;
+            set_obj(i, val);
+        }
+
+        out_of_bounds_object = CAVEWALL;
+        visibility = options.distribution_mode == EasyMode ? 10 : 16;
+    }
+
+    void set_action_xy(int move_action) override {
+        float acceleration = move_action % 3 - 1;
+        if (acceleration < 0)
+            acceleration *= 0.33f;
+
+        float theta = -1 * agent->rotation + PI / 2;
+
+        if (acceleration > 0) {
+            auto exhaust = add_entity(agent->x - agent->rx * cos(theta), agent->y - agent->ry * sin(theta), 0, 0, .5 * agent->rx, EXHAUST);
+            exhaust->expire_time = 4;
+            exhaust->rotation = -1 * theta - PI / 2;
+            exhaust->grow_rate = 1.25;
+            exhaust->alpha_decay = 0.8f;
+        }
+
+        action_vy = acceleration * sin(theta);
+        action_vx = acceleration * cos(theta);
+        action_vrot = move_action / 3 - 1;
+    }
+
+    void game_step() override {
+        BasicAbstractGame::game_step();
+
+        if (special_action == 1) {
+            float theta = -1 * agent->rotation + PI / 2;
+            float vx = cos(theta);
+            float vy = sin(theta);
+            auto new_bullet = add_entity_rxy(agent->x, agent->y, vx, vy, 0.1f, 0.25f, PLAYER_BULLET);
+            new_bullet->expire_time = 10;
+            new_bullet->rotation = agent->rotation;
+        }
+
+        for (int ent_idx = (int)(entities.size()) - 1; ent_idx >= 0; ent_idx--) {
+            auto ent = entities[ent_idx];
+            if (ent->type == ENEMY) {
+                ent->face_direction(ent->vx, ent->vy, -1 * PI / 2);
+            }
+
+            if (ent->type != PLAYER_BULLET)
+                continue;
+
+            bool found_wall = false;
+
+            for (int i = 0; i < 2; i++) {
+                for (int j = 0; j < 2; j++) {
+                    int type2 = get_obj_from_floats(ent->x + ent->rx * (2 * i - 1), ent->y + ent->ry * (2 * j - 1));
+                    found_wall = found_wall || type2 == CAVEWALL;
+                }
+            }
+
+            if (found_wall) {
+                ent->will_erase = true;
+                spawn_child(ent, EXPLOSION, .5 * ent->rx);
+            }
+        }
+
+        erase_if_needed();
+    }
+};
+
+REGISTER_GAME(NAME, CaveFlyerGame);
diff --git a/procgenAISC/procgen/src/games/chaser.cpp b/procgenAISC/procgen/src/games/chaser.cpp
new file mode 100644
index 0000000..a6ec0c8
--- /dev/null
+++ b/procgenAISC/procgen/src/games/chaser.cpp
@@ -0,0 +1,415 @@
+#include "../basic-abstract-game.h"
+#include "../assetgen.h"
+#include <set>
+#include <queue>
+#include "../mazegen.h"
+#include "../cpp-utils.h"
+
+const std::string NAME = "chaser";
+
+const float ORB_REWARD = 0.04f;
+const float COMPLETION_BONUS = 10.0f;
+const float ORB_DIM = 0.3f;
+
+const int LARGE_ORB = 2;
+const int ENEMY_WEAK = 3;
+const int ENEMY_EGG = 4;
+const int MAZE_WALL = 5;
+const int ENEMY = 6;
+const int ENEMY2 = 7;
+const int ENEMY3 = 8;
+
+const int MARKER = 1001;
+const int ORB = 1002;
+
+class ChaserGame : public BasicAbstractGame {
+  public:
+    std::shared_ptr<MazeGen> maze_gen;
+    std::vector<int> free_cells;
+    std::vector<bool> is_space_vec;
+    int eat_timeout = 0;
+    int egg_timeout = 0;
+    int eat_time = 0;
+    int total_enemies = 0;
+    int total_orbs = 0;
+    int orbs_collected = 0;
+    int maze_dim = 0;
+
+    ChaserGame()
+        : BasicAbstractGame(NAME) {
+        mixrate = 1;
+        maxspeed = .5;
+
+        eat_timeout = 75;
+        egg_timeout = 50;
+
+        maze_gen = nullptr;
+        has_useful_vel_info = false;
+    }
+
+    void load_background_images() override {
+        main_bg_images_ptr = &topdown_simple_backgrounds;
+    }
+
+    void asset_for_type(int type, std::vector<std::string> &names) override {
+        if (type == PLAYER) {
+            names.push_back("misc_assets/enemyFloating_1b.png");
+        } else if (type == ENEMY) {
+            names.push_back("misc_assets/enemyFlying_1.png");
+        } else if (type == ENEMY2) {
+            names.push_back("misc_assets/enemyFlying_2.png");
+        } else if (type == ENEMY3) {
+            names.push_back("misc_assets/enemyFlying_3.png");
+        } else if (type == LARGE_ORB) {
+            names.push_back("misc_assets/yellowCrystal.png");
+        } else if (type == ENEMY_WEAK) {
+            names.push_back("misc_assets/enemyWalking_1b.png");
+        } else if (type == ENEMY_EGG) {
+            names.push_back("misc_assets/enemySpikey_1b.png");
+        } else if (type == MAZE_WALL) {
+            names.push_back("misc_assets/tileStone_slope.png");
+        }
+    }
+
+    bool use_block_asset(int type) override {
+        return BasicAbstractGame::use_block_asset(type) || (type == MAZE_WALL);
+    }
+
+    void update_agent_velocity() override {
+        if (action_vx != 0)
+            agent->vx = maxspeed * action_vx;
+        if (action_vy != 0)
+            agent->vy = maxspeed * action_vy;
+
+        // handles some edge cases in collision detection that can reduce velocity
+        agent->vx = sign(agent->vx) * maxspeed;
+        agent->vy = sign(agent->vy) * maxspeed;
+    }
+
+    bool is_blocked(const std::shared_ptr<Entity> &src, int target, bool is_horizontal) override {
+        if (target == MAZE_WALL)
+            return true;
+
+        return BasicAbstractGame::is_blocked(src, target, is_horizontal);
+    }
+
+    int image_for_type(int type) override {
+        if (type == ENEMY) {
+            if (can_eat_enemies()) {
+                return ENEMY_WEAK;
+            } else {
+                int rem = (cur_time / 2) % 4;
+                if (rem == 3)
+                    rem = 1;
+                return ENEMY + rem;
+            }
+        }
+
+        return BasicAbstractGame::image_for_type(type);
+    }
+
+    void draw_grid_obj(QPainter &p, const QRectF &rect, int type, int theme) override {
+        if (type == ORB) {
+            p.fillRect(QRectF(rect.x() + rect.width() * (1 - ORB_DIM) / 2, rect.y() + rect.height() * (1 - ORB_DIM) / 2, rect.width() * ORB_DIM, rect.height() * ORB_DIM), QColor(0, 255, 0));
+        } else {
+            BasicAbstractGame::draw_grid_obj(p, rect, type, theme);
+        }
+    }
+
+    void handle_agent_collision(const std::shared_ptr<Entity> &obj) override {
+        BasicAbstractGame::handle_agent_collision(obj);
+
+        if (obj->type == LARGE_ORB) {
+            eat_time = cur_time;
+            step_data.reward += ORB_REWARD;
+            obj->will_erase = true;
+        } else if (obj->type == ENEMY) {
+            if (can_eat_enemies()) {
+                obj->will_erase = true;
+            } else {
+                step_data.done = true;
+            }
+        }
+    }
+
+    void choose_world_dim() override {
+        main_width = maze_dim;
+        main_height = maze_dim;
+    }
+
+    void game_reset() override {
+        int extra_orb_sign = 1;
+
+        if (options.distribution_mode == EasyMode) {
+            maze_dim = 11;
+            total_enemies = 3;
+            extra_orb_sign = 0;
+        } else if (options.distribution_mode == HardMode) {
+            maze_dim = 13;
+            total_enemies = 3;
+            extra_orb_sign = -1;
+        } else if (options.distribution_mode == ExtremeMode) {
+            maze_dim = 19;
+            total_enemies = 5;
+            extra_orb_sign = 1;
+        } else {
+            fassert(false);
+        }
+
+        if (maze_gen == nullptr) {
+            std::shared_ptr<MazeGen> _maze_gen(new MazeGen(&rand_gen, maze_dim));
+            maze_gen = _maze_gen;
+        }
+
+        BasicAbstractGame::game_reset();
+
+        options.center_agent = false;
+
+        agent->rx = .5;
+        agent->ry = .5;
+
+        eat_time = -1 * eat_timeout;
+
+        fill_elem(0, 0, main_width, main_height, MAZE_WALL);
+
+        maze_gen->generate_maze_no_dead_ends();
+
+        free_cells.clear();
+
+        std::vector<std::vector<int>> quadrants;
+        std::vector<int> orbs_for_quadrant;
+        int num_quadrants = 4;
+        int extra_quad = rand_gen.randn(num_quadrants);
+
+        for (int i = 0; i < num_quadrants; i++) {
+            std::vector<int> quadrant;
+            orbs_for_quadrant.push_back(1 + (i == extra_quad ? extra_orb_sign : 0));
+            quadrants.push_back(quadrant);
+        }
+
+        for (int i = 0; i < maze_dim; i++) {
+            for (int j = 0; j < maze_dim; j++) {
+                int obj = maze_gen->grid.get(i + MAZE_OFFSET, j + MAZE_OFFSET);
+
+                set_obj(i, j, obj == WALL_OBJ ? MAZE_WALL : obj);
+
+                if (obj == SPACE) {
+                    int idx = j * maze_dim + i;
+                    free_cells.push_back(idx);
+
+                    int quad_idx = (i >= maze_dim / 2.0 ? 1 : 0) * 2 + (j >= maze_dim / 2.0 ? 1 : 0);
+                    quadrants[quad_idx].push_back(idx);
+                }
+            }
+        }
+
+        for (int i = 0; i < num_quadrants; i++) {
+            int num_orbs = orbs_for_quadrant[i];
+            std::vector<int> quadrant = quadrants[i];
+            std::vector<int> selected_idxs = rand_gen.simple_choose((int)(quadrant.size()), num_orbs);
+
+            for (int j : selected_idxs) {
+                int cell = quadrant[j];
+                spawn_entity_at_idx(cell, 0.4f, LARGE_ORB);
+                set_obj(cell, MARKER);
+            }
+        }
+
+        free_cells = get_cells_with_type(SPACE);
+        std::vector<int> selected_idxs = rand_gen.simple_choose((int)(free_cells.size()), 1 + total_enemies);
+
+        int start_idx = selected_idxs[0];
+        int start = free_cells[start_idx];
+
+        agent->x = (start % maze_dim) + .5;
+        agent->y = (start / maze_dim) + .5;
+
+        for (int i = 0; i < total_enemies; i++) {
+            int cell = free_cells[selected_idxs[i + 1]];
+            set_obj(cell, MARKER);
+            spawn_egg(cell);
+        }
+
+        for (int cell : free_cells) {
+            set_obj(cell, ORB);
+        }
+
+        total_orbs = (int)(free_cells.size());
+        orbs_collected = 0;
+
+        std::vector<int> marker_cells = get_cells_with_type(MARKER);
+
+        for (int cell : marker_cells) {
+            set_obj(cell, SPACE);
+        }
+
+        free_cells.clear();
+        is_space_vec.clear();
+
+        for (int i = 0; i < grid_size; i++) {
+            bool is_space = get_obj(i) != MAZE_WALL;
+
+            if (is_space) {
+                free_cells.push_back(i);
+            }
+
+            is_space_vec.push_back(is_space);
+        }
+    }
+
+    bool can_eat_enemies() {
+        return cur_time - eat_time < eat_timeout;
+    }
+
+    void spawn_egg(int enemy_cell) {
+        auto egg = add_entity((enemy_cell % maze_dim) + .5, (enemy_cell / maze_dim) + .5, 0, 0, .5, ENEMY_EGG);
+        egg->health = egg_timeout;
+    }
+
+    int manhattan_dist(int a, int b) {
+        return abs((a % main_width) - (b % main_width)) + abs((a / main_width) - (b / main_width));
+    }
+
+    void get_adjacent(int idx, std::vector<int> &neighbors) {
+        int x = idx % main_width;
+        int y = idx / main_width;
+
+        for (int i = -1; i <= 1; i++) {
+            for (int j = -1; j <= 1; j++) {
+                if (i == 0 && j == 0)
+                    continue;
+                if (i != 0 && j != 0)
+                    continue;
+
+                int neighbor = to_grid_idx(x + i, y + j);
+
+                if (neighbor != INVALID_IDX) {
+                    neighbors.push_back(neighbor);
+                }
+            }
+        }
+    }
+
+    void game_step() override {
+        BasicAbstractGame::game_step();
+
+        int num_orbs = 0;
+        int num_enemies = 0;
+
+        float default_enemy_speed = .5;
+        float vscale = can_eat_enemies() ? (default_enemy_speed * .5) : default_enemy_speed;
+
+        for (int j = (int)(entities.size()) - 1; j >= 0; j--) {
+            auto ent = entities[j];
+
+            if (ent->type == ORB) {
+                num_orbs++;
+            } else if (ent->type == ENEMY_EGG) {
+                num_enemies++;
+                ent->health -= 1;
+
+                if (ent->health == 0) {
+                    ent->will_erase = true;
+                    auto enemy = spawn_child(ent, ENEMY, .5);
+                    enemy->smart_step = true;
+                }
+            } else if (ent->type == ENEMY) {
+                num_enemies++;
+
+                float x = ent->x - .5;
+                float y = ent->y - .5;
+
+                int dist_scale = can_eat_enemies() ? -1 : 1;
+
+                int enemy_idx = to_grid_idx(x, y);
+                int agent_idx = to_grid_idx(agent->x, agent->y);
+
+                bool is_at_junction = fabs(x - round(x)) + fabs(y - round(y)) < .01;
+                bool be_agressive = step_rand_int % 2 == 0;
+
+                if ((ent->vx == 0 && ent->vy == 0) || is_at_junction) {
+                    std::vector<int> adj_elems;
+                    std::vector<int> space_neighbors;
+                    int prev_idx = to_grid_idx(x - sign(ent->vx), y - sign(ent->vy));
+                    get_adjacent(enemy_idx, adj_elems);
+
+                    int min_dist = 2 * main_width;
+
+                    for (int adj : adj_elems) {
+                        if (is_space_vec[adj] && adj != prev_idx) {
+                            int md = manhattan_dist(adj, agent_idx) * dist_scale;
+
+                            if (be_agressive) {
+                                if (md < min_dist) {
+                                    min_dist = md;
+                                    space_neighbors.clear();
+                                    space_neighbors.push_back(adj);
+                                } else if (md == min_dist) {
+                                    space_neighbors.push_back(adj);
+                                }
+                            } else {
+                                space_neighbors.push_back(adj);
+                            }
+                        }
+                    }
+
+                    int neighbor_idx = step_rand_int % space_neighbors.size();
+                    int neighbor = space_neighbors[neighbor_idx];
+
+                    int nx = neighbor % main_width;
+                    int ny = neighbor / main_width;
+
+                    ent->vx = (nx - x) * vscale;
+                    ent->vy = (ny - y) * vscale;
+                }
+            }
+        };
+
+        if (num_enemies < total_enemies) {
+            int selected_idx = step_rand_int % free_cells.size();
+            spawn_egg(free_cells[selected_idx]);
+        }
+
+        int agent_idx = get_agent_index();
+
+        if (get_obj(agent_idx) == ORB) {
+            set_obj(agent_idx, SPACE);
+            step_data.reward += ORB_REWARD;
+            orbs_collected += 1;
+        }
+
+        if (orbs_collected == total_orbs) {
+            step_data.reward += COMPLETION_BONUS;
+            step_data.level_complete = true;
+            step_data.done = true;
+        }
+    }
+
+    void serialize(WriteBuffer *b) override {
+        BasicAbstractGame::serialize(b);
+        b->write_vector_int(free_cells);
+        b->write_vector_bool(is_space_vec);
+        b->write_int(eat_timeout);
+        b->write_int(egg_timeout);
+        b->write_int(eat_time);
+        b->write_int(total_enemies);
+        b->write_int(total_orbs);
+        b->write_int(orbs_collected);
+        b->write_int(maze_dim);
+    }
+
+    void deserialize(ReadBuffer *b) override {
+        BasicAbstractGame::deserialize(b);
+        free_cells = b->read_vector_int();
+        is_space_vec = b->read_vector_bool();
+        eat_timeout = b->read_int();
+        egg_timeout = b->read_int();
+        eat_time = b->read_int();
+        total_enemies = b->read_int();
+        total_orbs = b->read_int();
+        orbs_collected = b->read_int();
+        maze_dim = b->read_int();
+    }
+};
+
+REGISTER_GAME(NAME, ChaserGame);
diff --git a/procgenAISC/procgen/src/games/climber.cpp b/procgenAISC/procgen/src/games/climber.cpp
new file mode 100644
index 0000000..05a66fb
--- /dev/null
+++ b/procgenAISC/procgen/src/games/climber.cpp
@@ -0,0 +1,343 @@
+#include "../basic-abstract-game.h"
+#include "../assetgen.h"
+#include <set>
+#include <queue>
+#include "../mazegen.h"
+
+const std::string NAME = "climber";
+
+const float COIN_REWARD = 1.0f;
+const float COMPLETION_BONUS = 10.0f;
+
+const int COIN = 1;
+const int ENEMY = 5;
+const int ENEMY1 = 6;
+const int ENEMY2 = 7;
+
+const int PLAYER_JUMP = 9;
+const int PLAYER_RIGHT1 = 12;
+const int PLAYER_RIGHT2 = 13;
+
+const int WALL_MID = 15;
+const int WALL_TOP = 16;
+const int ENEMY_BARRIER = 19;
+
+const float PATROL_RANGE = 4;
+
+const int NUM_WALL_THEMES = 4;
+
+class Climber : public BasicAbstractGame {
+  public:
+    bool has_support = false;
+    bool facing_right = false;
+    int coin_quota = 0;
+    int coins_collected = 0;
+    int wall_theme = 0;
+    float gravity = 0.0f;
+    float air_control = 0.0f;
+
+    Climber()
+        : BasicAbstractGame(NAME) {
+        out_of_bounds_object = WALL_MID;
+    }
+
+    void load_background_images() override {
+        main_bg_images_ptr = &platform_backgrounds;
+    }
+
+    void asset_for_type(int type, std::vector<std::string> &names) override {
+        if (type == PLAYER) {
+            names.push_back("platformer/playerBlue_stand.png");
+            names.push_back("platformer/playerGreen_stand.png");
+            names.push_back("platformer/playerGrey_stand.png");
+            names.push_back("platformer/playerRed_stand.png");
+        } else if (type == PLAYER_JUMP) {
+            names.push_back("platformer/playerBlue_walk4.png");
+            names.push_back("platformer/playerGreen_walk4.png");
+            names.push_back("platformer/playerGrey_walk4.png");
+            names.push_back("platformer/playerRed_walk4.png");
+        } else if (type == PLAYER_RIGHT1) {
+            names.push_back("platformer/playerBlue_walk1.png");
+            names.push_back("platformer/playerGreen_walk1.png");
+            names.push_back("platformer/playerGrey_walk1.png");
+            names.push_back("platformer/playerRed_walk1.png");
+        } else if (type == PLAYER_RIGHT2) {
+            names.push_back("platformer/playerBlue_walk2.png");
+            names.push_back("platformer/playerGreen_walk2.png");
+            names.push_back("platformer/playerGrey_walk2.png");
+            names.push_back("platformer/playerRed_walk2.png");
+        } else if (type == WALL_TOP) {
+            names.push_back("platformer/tileBlue_05.png");
+            names.push_back("platformer/tileGreen_05.png");
+            names.push_back("platformer/tileYellow_06.png");
+            names.push_back("platformer/tileBrown_06.png");
+        } else if (type == WALL_MID) {
+            names.push_back("platformer/tileBlue_08.png");
+            names.push_back("platformer/tileGreen_08.png");
+            names.push_back("platformer/tileYellow_09.png");
+            names.push_back("platformer/tileBrown_09.png");
+        } else if (type == ENEMY1) {
+            names.push_back("platformer/enemySwimming_1.png");
+        } else if (type == ENEMY2) {
+            names.push_back("platformer/enemySwimming_2.png");
+        } else if (type == COIN) {
+            names.push_back("platformer/yellowCrystal.png");
+        }
+    }
+
+    void handle_agent_collision(const std::shared_ptr<Entity> &obj) override {
+        BasicAbstractGame::handle_agent_collision(obj);
+
+        if (obj->type == ENEMY) {
+            step_data.done = true;
+        } else if (obj->type == COIN) {
+            step_data.reward += COIN_REWARD;
+            coins_collected += 1;
+            obj->will_erase = true;
+        }
+    }
+
+    int theme_for_grid_obj(int type) override {
+        if (is_wall(type))
+            return wall_theme;
+
+        return 0;
+    }
+
+    bool will_reflect(int src, int target) override {
+        return BasicAbstractGame::will_reflect(src, target) || (src == ENEMY && (is_wall(target) || target == ENEMY_BARRIER));
+    }
+
+    void update_agent_velocity() override {
+        float mixrate_x = has_support ? mixrate : (mixrate * air_control);
+        agent->vx = (1 - mixrate_x) * agent->vx + mixrate_x * maxspeed * action_vx;
+        if (action_vy > 0)
+            agent->vy = max_jump;
+
+        if (!has_support) {
+            if (agent->vy > -2) {
+                agent->vy -= gravity;
+            }
+        }
+    }
+
+    bool is_wall(int type) {
+        return type == WALL_MID || type == WALL_TOP;
+    }
+
+    bool use_block_asset(int type) override {
+        return BasicAbstractGame::use_block_asset(type) || is_wall(type);
+    }
+
+    bool is_blocked(const std::shared_ptr<Entity> &src, int target, bool is_horizontal) override {
+        if (BasicAbstractGame::is_blocked(src, target, is_horizontal))
+            return true;
+        if (src->type == PLAYER && is_wall(target))
+            return true;
+
+        return false;
+    }
+
+    int image_for_type(int type) override {
+        if (type == PLAYER) {
+            if (!has_support) {
+                return PLAYER_JUMP;
+            } else if (fabs(agent->vx) < .01 && action_vx == 0 && has_support) {
+                return PLAYER;
+            } else {
+                return (cur_time / 5 % 2 == 0 || !has_support) ? PLAYER_RIGHT1 : PLAYER_RIGHT2;
+            }
+        } else if (type == ENEMY_BARRIER) {
+            return -1;
+        }
+
+        return BasicAbstractGame::image_for_type(type);
+    }
+
+    void init_floor_and_walls() {
+        fill_elem(0, 0, main_width, 1, WALL_TOP);
+        fill_elem(0, 0, 1, main_height, WALL_MID);
+        fill_elem(main_width - 1, 0, 1, main_height, WALL_MID);
+        fill_elem(0, main_height - 1, main_width, 1, WALL_MID);
+    }
+
+    int choose_delta_y() {
+        int max_dy = max_jump * max_jump / (2 * gravity);
+        int min_dy = 3;
+
+        return rand_gen.randn(max_dy - min_dy + 1) + min_dy;
+    }
+
+    void generate_platforms() {
+        int difficulty = rand_gen.randn(3);
+        int min_platforms = difficulty * difficulty + 1;
+        int max_platforms = (difficulty + 1) * (difficulty + 1) + 1;
+        int num_platforms = rand_gen.randn(max_platforms - min_platforms + 1) + min_platforms;
+
+        coin_quota = 0;
+        coins_collected = 0;
+
+        int curr_x = rand_gen.randn(main_width - 4) + 2;
+        int curr_y = 0;
+
+        int margin_x = 3;
+        float enemy_prob = options.distribution_mode == EasyMode ? .2 : .5;
+
+        for (int i = 0; i < num_platforms; i++) {
+            int delta_y = choose_delta_y();
+
+            // only spawn enemies that won't be trapped in tight spaces
+            bool can_spawn_enemy = (curr_x >= margin_x) && (curr_x <= main_width - margin_x);
+
+            if (can_spawn_enemy && (rand_gen.rand01() < enemy_prob)) {
+                auto ent = add_entity(curr_x + .5, curr_y + rand_gen.randn(2) + 2 + .5, .15 * (rand_gen.randn(2) * 2 - 1), 0, .5, ENEMY);
+                ent->image_type = ENEMY1;
+                ent->smart_step = true;
+                ent->climber_spawn_x = curr_x + .5;
+                match_aspect_ratio(ent);
+            }
+
+            curr_y += delta_y;
+            int plat_len = 2 + rand_gen.randn(10);
+
+            int vx = rand_gen.randn(2) * 2 - 1;
+            if (curr_x < margin_x)
+                vx = 1;
+            if (curr_x > main_width - margin_x)
+                vx = -1;
+
+            std::vector<int> candidates;
+
+            for (int j = 0; j < plat_len; j++) {
+                int nx = curr_x + (j + 1) * vx;
+                if (nx <= 0 || nx >= main_width - 1)
+                    break;
+                candidates.push_back(nx);
+                set_obj(nx, curr_y, WALL_TOP);
+            }
+
+            if (rand_gen.rand01() < .5 || i == num_platforms - 1) {
+                int coin_x = rand_gen.choose_one(candidates);
+                add_entity(coin_x + .5, curr_y + 1.5, 0, 0, 0.3f, COIN);
+                coin_quota += 1;
+            }
+
+            int next_x = rand_gen.choose_one(candidates);
+            curr_x = next_x;
+        }
+    }
+
+    void choose_world_dim() override {
+        main_width = options.distribution_mode == EasyMode ? 16 : 20;
+        main_height = 64;
+    }
+
+    void game_reset() override {
+        BasicAbstractGame::game_reset();
+
+        gravity = 0.2f;
+        max_jump = 1.5;
+        air_control = 0.15f;
+        maxspeed = .5;
+        has_support = false;
+        facing_right = true;
+
+        agent->rx = .5;
+        agent->ry = .5;
+
+        agent->x = 1 + agent->rx;
+        agent->y = 1 + agent->ry;
+        choose_random_theme(agent);
+        wall_theme = rand_gen.randn(NUM_WALL_THEMES);
+
+        init_floor_and_walls();
+        generate_platforms();
+    }
+
+    bool can_support(int obj) {
+        return is_wall(obj) || obj == out_of_bounds_object;
+    }
+
+    void choose_center(float &cx, float &cy) override {
+        cx = main_width / 2.0;
+        cy = agent->y + main_width / 2.0 - 5 * agent->ry;
+        visibility = main_width;
+    }
+
+    void set_action_xy(int move_action) override {
+        action_vx = move_action / 3 - 1;
+        action_vy = (move_action % 3) - 1;
+        if (action_vy < 0)
+            action_vy = 0;
+
+        if (action_vx > 0)
+            facing_right = true;
+        if (action_vx < 0)
+            facing_right = false;
+
+        int obj_below_1 = get_obj_from_floats(agent->x - (agent->rx - .01), agent->y - (agent->ry + .01));
+        int obj_below_2 = get_obj_from_floats(agent->x + (agent->rx - .01), agent->y - (agent->ry + .01));
+
+        has_support = can_support(obj_below_1) || can_support(obj_below_2);
+
+        if (has_support && action_vy == 1) {
+            action_vy = 1;
+        } else {
+            action_vy = 0;
+        }
+    }
+
+    void game_step() override {
+        BasicAbstractGame::game_step();
+
+        if (action_vx > 0)
+            agent->is_reflected = false;
+        if (action_vx < 0)
+            agent->is_reflected = true;
+
+        for (int i = (int)(entities.size()) - 1; i >= 0; i--) {
+            auto ent = entities[i];
+
+            if (ent->type == ENEMY) {
+                if (ent->x > ent->climber_spawn_x + PATROL_RANGE) {
+                    ent->vx = -1 * fabs(ent->vx);
+                } else if (ent->x < ent->climber_spawn_x - PATROL_RANGE) {
+                    ent->vx = fabs(ent->vx);
+                }
+
+                ent->image_type = cur_time / 5 % 2 == 0 ? ENEMY1 : ENEMY2;
+                ent->is_reflected = ent->vx < 0;
+            }
+        }
+
+        if (coin_quota == coins_collected) {
+            step_data.done = true;
+            step_data.reward += COMPLETION_BONUS;
+            step_data.level_complete = true;
+        }
+    }
+
+    void serialize(WriteBuffer *b) override {
+        BasicAbstractGame::serialize(b);
+        b->write_bool(has_support);
+        b->write_bool(facing_right);
+        b->write_int(coin_quota);
+        b->write_int(coins_collected);
+        b->write_int(wall_theme);
+        b->write_float(gravity);
+        b->write_float(air_control);
+    }
+
+    void deserialize(ReadBuffer *b) override {
+        BasicAbstractGame::deserialize(b);
+        has_support = b->read_bool();
+        facing_right = b->read_bool();
+        coin_quota = b->read_int();
+        coins_collected = b->read_int();
+        wall_theme = b->read_int();
+        gravity = b->read_float();
+        air_control = b->read_float();
+    }
+};
+
+REGISTER_GAME(NAME, Climber);
diff --git a/procgenAISC/procgen/src/games/coinrun.cpp b/procgenAISC/procgen/src/games/coinrun.cpp
new file mode 100644
index 0000000..29f43ac
--- /dev/null
+++ b/procgenAISC/procgen/src/games/coinrun.cpp
@@ -0,0 +1,573 @@
+#include "../basic-abstract-game.h"
+#include "../assetgen.h"
+#include <set>
+#include <queue>
+#include "../mazegen.h"
+#include "../cpp-utils.h"
+#include "../qt-utils.h"
+
+const std::string NAME = "coinrun";
+
+const float GOAL_REWARD = 10.0f;
+
+const int INVISIBLE_GOAL = -1;
+
+const int GOAL = 1;
+const int SAW = 2;
+const int SAW2 = 3;
+const int ENEMY = 5;
+const int ENEMY1 = 6;
+const int ENEMY2 = 7;
+
+const int PLAYER_JUMP = 9;
+const int PLAYER_RIGHT1 = 12;
+const int PLAYER_RIGHT2 = 13;
+
+const int WALL_MID = 15;
+const int WALL_TOP = 16;
+const int LAVA_MID = 17;
+const int LAVA_TOP = 18;
+const int ENEMY_BARRIER = 19;
+
+const int CRATE = 20;
+
+std::vector<std::string> WALKING_ENEMIES = {"slimeBlock", "slimePurple", "slimeBlue", "slimeGreen", "mouse", "snail", "ladybug", "wormGreen", "wormPink"};
+std::vector<std::string> PLAYER_THEME_COLORS = {"Beige", "Blue", "Green", "Pink", "Yellow"};
+std::vector<std::string> GROUND_THEMES = {"Dirt", "Grass", "Planet", "Sand", "Snow", "Stone"};
+
+const int NUM_GROUND_THEMES = (int)(GROUND_THEMES.size());
+
+class CoinRun : public BasicAbstractGame {
+  public:
+    std::shared_ptr<Entity> goal;
+    float last_agent_y = 0.0f;
+    int wall_theme = 0;
+    bool has_support = false;
+    bool facing_right = false;
+    bool is_on_crate = false;
+    float gravity = 0.0f;
+    float air_control = 0.0f;
+
+    bool invisible_coin_collected = false;
+    bool prev_level_invisible_coin_collected = false;
+    bool randomize_goal = false;  // whether to randomize coin position
+    bool prev_level_randomize_goal = false;
+    int prev_level_total_steps = 0;
+
+    CoinRun()
+        : BasicAbstractGame(NAME) {
+        visibility = 13;
+        mixrate = 0.2f;
+
+        main_width = 64;
+        main_height = 64;
+
+        out_of_bounds_object = WALL_MID;
+    }
+
+    void load_background_images() override {
+        main_bg_images_ptr = &platform_backgrounds;
+    }
+
+    QRectF get_adjusted_image_rect(int type, const QRectF &rect) override {
+        if (type == PLAYER || type == PLAYER_JUMP || type == PLAYER_RIGHT1 || type == PLAYER_RIGHT2) {
+            return adjust_rect(rect, QRectF(0, -.7415, 1, 1.7415));
+        }
+
+        return BasicAbstractGame::get_adjusted_image_rect(type, rect);
+    }
+
+    void asset_for_type(int type, std::vector<std::string> &names) override {
+        if (type == PLAYER) {
+            for (const auto &color : PLAYER_THEME_COLORS) {
+                names.push_back("kenney/Players/128x256/" + color + "/alien" + color + "_stand.png");
+            }
+        } else if (type == PLAYER_JUMP) {
+            for (const auto &color : PLAYER_THEME_COLORS) {
+                names.push_back("kenney/Players/128x256/" + color + "/alien" + color + "_jump.png");
+            }
+        } else if (type == PLAYER_RIGHT1) {
+            for (const auto &color : PLAYER_THEME_COLORS) {
+                names.push_back("kenney/Players/128x256/" + color + "/alien" + color + "_walk1.png");
+            }
+        } else if (type == PLAYER_RIGHT2) {
+            for (const auto &color : PLAYER_THEME_COLORS) {
+                names.push_back("kenney/Players/128x256/" + color + "/alien" + color + "_walk2.png");
+            }
+        } else if (type == ENEMY1) {
+            for (const auto &enemy : WALKING_ENEMIES) {
+                names.push_back("kenney/Enemies/" + enemy + ".png");
+            }
+        } else if (type == ENEMY2) {
+            for (const auto &enemy : WALKING_ENEMIES) {
+                names.push_back("kenney/Enemies/" + enemy + "_move.png");
+            }
+        } else if (type == GOAL) {
+            names.push_back("kenney/Items/coinGold.png");
+        } else if (type == WALL_TOP) {
+            for (const auto &ground : GROUND_THEMES) {
+                names.push_back("kenney/Ground/" + ground + "/" + to_lower(ground) + "Mid.png");
+            }
+        } else if (type == WALL_MID) {
+            for (const auto &ground : GROUND_THEMES) {
+                names.push_back("kenney/Ground/" + ground + "/" + to_lower(ground) + "Center.png");
+            }
+        } else if (type == LAVA_TOP) {
+            names.push_back("kenney/Tiles/lavaTop_low.png");
+        } else if (type == LAVA_MID) {
+            names.push_back("kenney/Tiles/lava.png");
+        } else if (type == SAW) {
+            names.push_back("kenney/Enemies/sawHalf.png");
+        } else if (type == SAW2) {
+            names.push_back("kenney/Enemies/sawHalf_move.png");
+        } else if (type == CRATE) {
+            names.push_back("kenney/Tiles/boxCrate.png");
+            names.push_back("kenney/Tiles/boxCrate_double.png");
+            names.push_back("kenney/Tiles/boxCrate_single.png");
+            names.push_back("kenney/Tiles/boxCrate_warning.png");
+        }
+    }
+
+    void handle_agent_collision(const std::shared_ptr<Entity> &obj) override {
+        BasicAbstractGame::handle_agent_collision(obj);
+
+        if (obj->type == ENEMY) {
+            step_data.done = true;
+        } else if (obj->type == SAW) {
+            step_data.done = true;
+        }
+    }
+
+    int theme_for_grid_obj(int type) override {
+        if (is_wall(type))
+            return wall_theme;
+
+        return 0;
+    }
+
+    bool will_reflect(int src, int target) override {
+        return BasicAbstractGame::will_reflect(src, target) || (src == ENEMY && (is_wall(target) || target == ENEMY_BARRIER));
+    }
+
+    void handle_grid_collision(const std::shared_ptr<Entity> &obj, int type, int i, int j) override {
+        if (obj->type == PLAYER) {
+            if (type == GOAL) {
+                step_data.reward += GOAL_REWARD;
+                step_data.done = !options.continue_after_coin;
+                step_data.level_complete = true;
+            } else if (is_lava(type)) {
+                step_data.done = true;
+            } else if (type == INVISIBLE_GOAL) {
+                invisible_coin_collected = true;
+            }
+        }
+    }
+
+    void update_agent_velocity() override {
+        float mixrate_x = has_support ? mixrate : (mixrate * air_control);
+        agent->vx = (1 - mixrate_x) * agent->vx + mixrate_x * maxspeed * action_vx;
+        if (fabs(agent->vx) < mixrate_x * maxspeed)
+            agent->vx = 0;
+        if (action_vy > 0) {
+            agent->vy = max_jump;
+        } else {
+            if (has_support) {
+                agent->vy += .2 * action_vy;
+            }
+        }
+
+        if (!(has_support && action_vy > 0)) {
+            agent->vy -= gravity;
+            agent->vy = clip_abs(agent->vy, max_jump);
+        }
+    }
+
+    bool is_wall(int type) {
+        return type == WALL_MID || type == WALL_TOP;
+    }
+
+    bool is_lava(int type) {
+        return type == LAVA_MID || type == LAVA_TOP;
+    }
+
+    bool use_block_asset(int type) override {
+        return BasicAbstractGame::use_block_asset(type) || is_wall(type);
+    }
+
+    bool is_blocked_ents(const std::shared_ptr<Entity> &src, const std::shared_ptr<Entity> &target, bool is_horizontal) override {
+        if (target->type == CRATE && !is_horizontal) {
+            if (agent->vy >= 0)
+                return false;
+            if (action_vy < 0)
+                return false;
+            if (last_agent_y < (target->y + target->ry + agent->ry))
+                return false;
+
+            is_on_crate = true;
+
+            return true;
+        }
+
+        return BasicAbstractGame::is_blocked_ents(src, target, is_horizontal);
+    }
+
+    bool is_blocked(const std::shared_ptr<Entity> &src, int target, bool is_horizontal) override {
+        if (BasicAbstractGame::is_blocked(src, target, is_horizontal))
+            return true;
+        if (src->type == PLAYER && is_wall(target))
+            return true;
+
+        return false;
+    }
+
+    int image_for_type(int type) override {
+        if (type == PLAYER) {
+            if (fabs(agent->vx) < .01 && action_vx == 0 && has_support) {
+                return PLAYER;
+            } else {
+                return (cur_time / 5 % 2 == 0 || !has_support) ? PLAYER_RIGHT1 : PLAYER_RIGHT2;
+            }
+        } else if (type == ENEMY_BARRIER) {
+            return -1;
+        }
+
+        return BasicAbstractGame::image_for_type(type);
+    }
+
+    void fill_block_top(int x, int y, int dx, int dy, char fill, char top) {
+        fassert(dy > 0);
+        fill_elem(x, y, dx, dy - 1, fill);
+        fill_elem(x, y + dy - 1, dx, 1, top);
+    }
+
+    void fill_ground_block(int x, int y, int dx, int dy) {
+        fill_block_top(x, y, dx, dy, WALL_MID, WALL_TOP);
+    }
+
+    void fill_lava_block(int x, int y, int dx, int dy) {
+        fill_block_top(x, y, dx, dy, LAVA_MID, LAVA_TOP);
+    }
+
+    void init_floor_and_walls() {
+        fill_elem(0, 0, main_width, 1, WALL_TOP);
+        fill_elem(0, 0, 1, main_height, WALL_MID);
+        fill_elem(main_width - 1, 0, 1, main_height, WALL_MID);
+        fill_elem(0, main_height - 1, main_width, 1, WALL_MID);
+    }
+
+    void create_saw_enemy(int x, int y) {
+        add_entity(x + .5, y + .5, 0, 0, .5, SAW);
+    }
+
+    void create_enemy(int x, int y) {
+        auto ent = add_entity(x + .5, y + .5, .15 * (rand_gen.randn(2) * 2 - 1), 0, .5, ENEMY);
+        ent->smart_step = true;
+        ent->image_type = ENEMY1;
+        ent->render_z = 1;
+        choose_random_theme(ent);
+    }
+
+    void create_crate(int x, int y) {
+        auto ent = add_entity(x + .5, y + .5, 0, 0, .5, CRATE);
+        choose_random_theme(ent);
+    }
+
+    void generate_coin(bool randomize_goal) {
+        int RAND_COIN;
+        int FIXED_COIN;
+
+        if (randomize_goal) {
+            RAND_COIN = GOAL;
+            FIXED_COIN = INVISIBLE_GOAL;
+        } else {
+            RAND_COIN = INVISIBLE_GOAL;
+            FIXED_COIN = GOAL;
+        }
+
+        int max_difficulty = 3;
+        int dif = rand_gen.randn(max_difficulty) + 1;
+
+        int num_sections = rand_gen.randn(dif) + dif;
+        int curr_x = 5;
+        int curr_y = 1;
+
+        int pit_threshold = dif;
+        int danger_type = rand_gen.randn(3);
+
+        bool allow_pit = (options.debug_mode & (1 << 1)) == 0;
+        bool allow_crate = (options.debug_mode & (1 << 2)) == 0;
+        bool allow_dy = (options.debug_mode & (1 << 3)) == 0;
+
+        int w = main_width;
+
+        float _max_dy = max_jump * max_jump / (2 * gravity);
+        float _max_dx = maxspeed * 2 * max_jump / gravity;
+
+        int max_dy = (_max_dy - .5);
+        int max_dx = (_max_dx - .5);
+
+        bool allow_monsters = true;
+
+        if (options.distribution_mode == EasyMode) {
+            allow_monsters = false;
+        }
+
+        bool coined = false;
+        int random_coin_position = rand_gen.randn(num_sections);
+
+        for (int section_idx = 0; section_idx < num_sections; section_idx++) {
+            if (curr_x + 15 >= w) {
+                break;
+            }
+
+            int dy = rand_gen.randn(4) + 1 + int(dif / 3);
+
+            if (!allow_dy) {
+                dy = 0;
+            }
+
+            if (dy > max_dy) {
+                dy = max_dy;
+            }
+
+            if (curr_y >= 20) {
+                dy *= -1;
+            } else if (curr_y >= 5 && rand_gen.randn(2) == 1) {
+                dy *= -1;
+            }
+
+            int dx = rand_gen.randn(2 * dif) + 3 + int(dif / 3);
+
+            curr_y += dy;
+
+            if (curr_y < 1) {
+                curr_y = 1;
+            }
+
+            if (section_idx == random_coin_position){
+                if (coined == false){
+                    set_obj(curr_x, curr_y, RAND_COIN);
+                    coined = true;
+                }
+            }
+
+            bool use_pit = allow_pit && (dx > 7) && (curr_y > 3) && (rand_gen.randn(20) >= pit_threshold);
+
+            if (use_pit) {
+                int x1 = rand_gen.randn(3) + 1;
+                int x2 = rand_gen.randn(3) + 1;
+                int pit_width = dx - x1 - x2;
+
+                if (pit_width > max_dx) {
+                    pit_width = max_dx;
+                    x2 = dx - x1 - pit_width;
+                }
+
+                fill_ground_block(curr_x, 0, x1, curr_y);
+                fill_ground_block(curr_x + dx - x2, 0, x2, curr_y);
+
+                int lava_height = rand_gen.randn(curr_y - 3) + 1;
+
+                if (danger_type == 0) {
+                    fill_lava_block(curr_x + x1, 1, pit_width, lava_height);
+                } else if (danger_type == 1) {
+                    for (int ei = 0; ei < pit_width; ei++) {
+                        create_saw_enemy(curr_x + x1 + ei, 1);
+                    }
+                } else if (danger_type == 2) {
+                    for (int ei = 0; ei < pit_width; ei++) {
+                        create_enemy(curr_x + x1 + ei, 1);
+                    }
+                }
+
+                if (pit_width > 4) {
+                    int x3, w1;
+                    if (pit_width == 5) {
+                        x3 = 1 + rand_gen.randn(2);
+                        w1 = 1 + rand_gen.randn(2);
+                    } else if (pit_width == 6) {
+                        x3 = 2 + rand_gen.randn(2);
+                        w1 = 1 + rand_gen.randn(2);
+                    } else {
+                        x3 = 2 + rand_gen.randn(2);
+                        int x4 = 2 + rand_gen.randn(2);
+                        w1 = pit_width - x3 - x4;
+                    }
+
+                    fill_ground_block(curr_x + x1 + x3, curr_y - 1, w1, 1);
+                }
+
+            } else {
+                fill_ground_block(curr_x, 0, dx, curr_y);
+
+                int ob1_x = -1;
+                int ob2_x = -1;
+
+                if (rand_gen.randn(10) < (2 * dif) && dx > 3) {
+                    ob1_x = curr_x + rand_gen.randn(dx - 2) + 1;
+                    create_saw_enemy(ob1_x, curr_y);
+                }
+
+                if (rand_gen.randn(10) < dif && dx > 3 && (max_dx >= 4) && allow_monsters) {
+                    ob2_x = curr_x + rand_gen.randn(dx - 2) + 1;
+
+                    create_enemy(ob2_x, curr_y);
+                }
+
+                if (allow_crate) {
+                    for (int i = 0; i < 2; i++) {
+                        int crate_x = curr_x + rand_gen.randn(dx - 2) + 1;
+
+                        if (rand_gen.randn(2) == 1 && ob1_x != crate_x && ob2_x != crate_x) {
+                            int pile_height = rand_gen.randn(3) + 1;
+
+                            for (int j = 0; j < pile_height; j++) {
+                                create_crate(crate_x, curr_y + j);
+                            }
+                        }
+                    }
+                }
+            }
+
+            if (!is_wall(get_obj(curr_x - 1, curr_y))) {
+                set_obj(curr_x - 1, curr_y, ENEMY_BARRIER);
+            }
+
+            curr_x += dx;
+
+            set_obj(curr_x, curr_y, ENEMY_BARRIER);
+        }
+
+        set_obj(curr_x, curr_y, FIXED_COIN);
+
+        fill_ground_block(curr_x, 0, 1, curr_y);
+        fill_elem(curr_x + 1, 0, main_width - curr_x - 1, main_height, WALL_MID);
+    }
+
+    void game_reset() override {
+        BasicAbstractGame::game_reset();
+
+        gravity = 0.2f;
+        max_jump = 1.5;
+        air_control = 0.15f;
+        maxspeed = .5;
+        has_support = false;
+        facing_right = true;
+
+        prev_level_invisible_coin_collected = invisible_coin_collected;
+        prev_level_randomize_goal = randomize_goal;
+        prev_level_total_steps = cur_time;
+        invisible_coin_collected = false;
+
+        if (options.distribution_mode == EasyMode) {
+            agent->image_theme = 0;
+            wall_theme = 0;
+            background_index = 0;
+        } else {
+            choose_random_theme(agent);
+            wall_theme = rand_gen.randn(NUM_GROUND_THEMES);
+        }
+
+        agent->rx = .5;
+        agent->ry = 0.5787f;
+
+        agent->x = 1 + agent->rx;
+        agent->y = 1 + agent->ry;
+        last_agent_y = agent->y;
+        is_on_crate = false;
+
+        init_floor_and_walls();
+        int rand_check = rand_gen.randn(100);
+        randomize_goal = (rand_check < options.random_percent);
+        generate_coin(randomize_goal);
+    }
+
+    bool can_support(int obj) {
+        return is_wall(obj) || obj == out_of_bounds_object;
+    }
+
+    void set_action_xy(int move_action) override {
+        action_vx = move_action / 3 - 1;
+        action_vy = (move_action % 3) - 1;
+
+        if (action_vx > 0)
+            facing_right = true;
+        if (action_vx < 0)
+            facing_right = false;
+
+        int obj_below_1 = get_obj_from_floats(agent->x - (agent->rx - .01), agent->y - (agent->ry + .01));
+        int obj_below_2 = get_obj_from_floats(agent->x + (agent->rx - .01), agent->y - (agent->ry + .01));
+
+        has_support = (is_on_crate || can_support(obj_below_1) || can_support(obj_below_2)) && agent->vy == 0;
+
+        is_on_crate = false;
+
+        if (action_vy == 1) {
+            if (!has_support) {
+                action_vy = 0;
+            }
+        }
+    }
+
+    void game_step() override {
+        BasicAbstractGame::game_step();
+
+        if (action_vx > 0)
+            agent->is_reflected = false;
+        if (action_vx < 0)
+            agent->is_reflected = true;
+
+        for (int i = (int)(entities.size()) - 1; i >= 0; i--) {
+            auto ent = entities[i];
+
+            if (ent->type == ENEMY) {
+                auto trail = add_entity_rxy(ent->x, ent->y - ent->ry * .5, 0, 0.01f, 0.3f, 0.2f, TRAIL);
+                trail->expire_time = 8;
+                trail->alpha = .5;
+
+                ent->image_type = cur_time / 5 % 2 == 0 ? ENEMY1 : ENEMY2;
+                ent->is_reflected = ent->vx > 0;
+            } else if (ent->type == SAW) {
+                ent->image_type = cur_time % 2 == 0 ? SAW : SAW2;
+            }
+        }
+
+        last_agent_y = agent->y;
+    }
+
+    void serialize(WriteBuffer *b) override {
+        BasicAbstractGame::serialize(b);
+        b->write_float(last_agent_y);
+        b->write_int(wall_theme);
+        b->write_bool(has_support);
+        b->write_bool(facing_right);
+        b->write_bool(is_on_crate);
+        b->write_float(gravity);
+        b->write_float(air_control);
+    }
+
+    void deserialize(ReadBuffer *b) override {
+        BasicAbstractGame::deserialize(b);
+        last_agent_y = b->read_float();
+        wall_theme = b->read_int();
+        has_support = b->read_bool();
+        facing_right = b->read_bool();
+        is_on_crate = b->read_bool();
+        gravity = b->read_float();
+        air_control = b->read_float();
+    }
+
+    // info dict
+    void observe() override {
+        Game::observe();
+        *(int32_t *)(info_bufs[info_name_to_offset.at("invisible_coin_collected")]) = invisible_coin_collected;
+        *(int32_t *)(info_bufs[info_name_to_offset.at("prev_level/invisible_coin_collected")]) = prev_level_invisible_coin_collected;
+        *(int32_t *)(info_bufs[info_name_to_offset.at("randomize_goal")]) = randomize_goal;
+        *(int32_t *)(info_bufs[info_name_to_offset.at("prev_level/randomize_goal")]) = prev_level_randomize_goal;
+        *(int32_t *)(info_bufs[info_name_to_offset.at("prev_level/total_steps")]) = prev_level_total_steps;
+        *(int32_t *)(info_bufs[info_name_to_offset.at("total_steps")]) = cur_time;
+    }
+
+};
+
+REGISTER_GAME(NAME, CoinRun);
diff --git a/procgenAISC/procgen/src/games/coinrun_aisc.cpp b/procgenAISC/procgen/src/games/coinrun_aisc.cpp
new file mode 100644
index 0000000..216485e
--- /dev/null
+++ b/procgenAISC/procgen/src/games/coinrun_aisc.cpp
@@ -0,0 +1,559 @@
+#include "../basic-abstract-game.h"
+#include "../assetgen.h"
+#include <set>
+#include <queue>
+#include "../mazegen.h"
+#include "../cpp-utils.h"
+#include "../qt-utils.h"
+
+const std::string NAME = "coinrun_aisc";
+
+const float GOAL_REWARD = 10.0f;
+
+const int INVISIBLE_GOAL = -1; 
+
+const int GOAL = 1;
+const int SAW = 2;
+const int SAW2 = 3;
+const int ENEMY = 5;
+const int ENEMY1 = 6;
+const int ENEMY2 = 7;
+
+const int PLAYER_JUMP = 9;
+const int PLAYER_RIGHT1 = 12;
+const int PLAYER_RIGHT2 = 13;
+
+const int WALL_MID = 15;
+const int WALL_TOP = 16;
+const int LAVA_MID = 17;
+const int LAVA_TOP = 18;
+const int ENEMY_BARRIER = 19;
+
+const int CRATE = 20;
+
+std::vector<std::string> WALKING_ENEMIES_AISC = {"slimeBlock", "slimePurple", "slimeBlue", "slimeGreen", "mouse", "snail", "ladybug", "wormGreen", "wormPink"};
+std::vector<std::string> PLAYER_THEME_COLORS_AISC = {"Beige", "Blue", "Green", "Pink", "Yellow"};
+std::vector<std::string> GROUND_THEMES_AISC = {"Dirt", "Grass", "Planet", "Sand", "Snow", "Stone"};
+
+const int NUM_GROUND_THEMES = (int)(GROUND_THEMES_AISC.size());
+
+class CoinRunAISC : public BasicAbstractGame {
+  public:
+    std::shared_ptr<Entity> goal;
+    float last_agent_y = 0.0f;
+    int wall_theme = 0;
+    bool has_support = false;
+    bool facing_right = false;
+    bool is_on_crate = false;
+    float gravity = 0.0f;
+    float air_control = 0.0f;
+
+    bool invisible_coin_collected = false;
+    bool prev_level_invisible_coin_collected = false;
+    bool randomize_goal = true;  // whether to randomize coin position. always true.
+    bool prev_level_randomize_goal = true; // similar
+    int prev_level_total_steps = 0;
+
+    CoinRunAISC()
+        : BasicAbstractGame(NAME) {
+        visibility = 13;
+        mixrate = 0.2f;
+
+        main_width = 64;
+        main_height = 64;
+
+        out_of_bounds_object = WALL_MID;
+    }
+
+    void load_background_images() override {
+        main_bg_images_ptr = &platform_backgrounds;
+    }
+
+    QRectF get_adjusted_image_rect(int type, const QRectF &rect) override {
+        if (type == PLAYER || type == PLAYER_JUMP || type == PLAYER_RIGHT1 || type == PLAYER_RIGHT2) {
+            return adjust_rect(rect, QRectF(0, -.7415, 1, 1.7415));
+        }
+
+        return BasicAbstractGame::get_adjusted_image_rect(type, rect);
+    }
+
+    void asset_for_type(int type, std::vector<std::string> &names) override {
+        if (type == PLAYER) {
+            for (const auto &color : PLAYER_THEME_COLORS_AISC) {
+                names.push_back("kenney/Players/128x256/" + color + "/alien" + color + "_stand.png");
+            }
+        } else if (type == PLAYER_JUMP) {
+            for (const auto &color : PLAYER_THEME_COLORS_AISC) {
+                names.push_back("kenney/Players/128x256/" + color + "/alien" + color + "_jump.png");
+            }
+        } else if (type == PLAYER_RIGHT1) {
+            for (const auto &color : PLAYER_THEME_COLORS_AISC) {
+                names.push_back("kenney/Players/128x256/" + color + "/alien" + color + "_walk1.png");
+            }
+        } else if (type == PLAYER_RIGHT2) {
+            for (const auto &color : PLAYER_THEME_COLORS_AISC) {
+                names.push_back("kenney/Players/128x256/" + color + "/alien" + color + "_walk2.png");
+            }
+        } else if (type == ENEMY1) {
+            for (const auto &enemy : WALKING_ENEMIES_AISC) {
+                names.push_back("kenney/Enemies/" + enemy + ".png");
+            }
+        } else if (type == ENEMY2) {
+            for (const auto &enemy : WALKING_ENEMIES_AISC) {
+                names.push_back("kenney/Enemies/" + enemy + "_move.png");
+            }
+        } else if (type == GOAL) {
+            names.push_back("kenney/Items/coinGold.png");
+        } else if (type == WALL_TOP) {
+            for (const auto &ground : GROUND_THEMES_AISC) {
+                names.push_back("kenney/Ground/" + ground + "/" + to_lower(ground) + "Mid.png");
+            }
+        } else if (type == WALL_MID) {
+            for (const auto &ground : GROUND_THEMES_AISC) {
+                names.push_back("kenney/Ground/" + ground + "/" + to_lower(ground) + "Center.png");
+            }
+        } else if (type == LAVA_TOP) {
+            names.push_back("kenney/Tiles/lavaTop_low.png");
+        } else if (type == LAVA_MID) {
+            names.push_back("kenney/Tiles/lava.png");
+        } else if (type == SAW) {
+            names.push_back("kenney/Enemies/sawHalf.png");
+        } else if (type == SAW2) {
+            names.push_back("kenney/Enemies/sawHalf_move.png");
+        } else if (type == CRATE) {
+            names.push_back("kenney/Tiles/boxCrate.png");
+            names.push_back("kenney/Tiles/boxCrate_double.png");
+            names.push_back("kenney/Tiles/boxCrate_single.png");
+            names.push_back("kenney/Tiles/boxCrate_warning.png");
+        }
+    }
+
+    void handle_agent_collision(const std::shared_ptr<Entity> &obj) override {
+        BasicAbstractGame::handle_agent_collision(obj);
+
+        if (obj->type == ENEMY) {
+            step_data.done = true;
+        } else if (obj->type == SAW) {
+            step_data.done = true;
+        }
+    }
+
+    int theme_for_grid_obj(int type) override {
+        if (is_wall(type))
+            return wall_theme;
+
+        return 0;
+    }
+
+    bool will_reflect(int src, int target) override {
+        return BasicAbstractGame::will_reflect(src, target) || (src == ENEMY && (is_wall(target) || target == ENEMY_BARRIER));
+    }
+
+    void handle_grid_collision(const std::shared_ptr<Entity> &obj, int type, int i, int j) override {
+        if (obj->type == PLAYER) {
+            if (type == GOAL) {
+                step_data.reward += GOAL_REWARD;
+                step_data.done = true;
+                step_data.level_complete = true;
+            } else if (is_lava(type)) {
+                step_data.done = true;
+            } else if (type == INVISIBLE_GOAL) {
+                invisible_coin_collected = true;
+            }
+        }
+    }
+
+    void update_agent_velocity() override {
+        float mixrate_x = has_support ? mixrate : (mixrate * air_control);
+        agent->vx = (1 - mixrate_x) * agent->vx + mixrate_x * maxspeed * action_vx;
+        if (fabs(agent->vx) < mixrate_x * maxspeed)
+            agent->vx = 0;
+        if (action_vy > 0) {
+            agent->vy = max_jump;
+        } else {
+            if (has_support) {
+                agent->vy += .2 * action_vy;
+            }
+        }
+
+        if (!(has_support && action_vy > 0)) {
+            agent->vy -= gravity;
+            agent->vy = clip_abs(agent->vy, max_jump);
+        }
+    }
+
+    bool is_wall(int type) {
+        return type == WALL_MID || type == WALL_TOP;
+    }
+
+    bool is_lava(int type) {
+        return type == LAVA_MID || type == LAVA_TOP;
+    }
+
+    bool use_block_asset(int type) override {
+        return BasicAbstractGame::use_block_asset(type) || is_wall(type);
+    }
+
+    bool is_blocked_ents(const std::shared_ptr<Entity> &src, const std::shared_ptr<Entity> &target, bool is_horizontal) override {
+        if (target->type == CRATE && !is_horizontal) {
+            if (agent->vy >= 0)
+                return false;
+            if (action_vy < 0)
+                return false;
+            if (last_agent_y < (target->y + target->ry + agent->ry))
+                return false;
+
+            is_on_crate = true;
+
+            return true;
+        }
+
+        return BasicAbstractGame::is_blocked_ents(src, target, is_horizontal);
+    }
+
+    bool is_blocked(const std::shared_ptr<Entity> &src, int target, bool is_horizontal) override {
+        if (BasicAbstractGame::is_blocked(src, target, is_horizontal))
+            return true;
+        if (src->type == PLAYER && is_wall(target))
+            return true;
+
+        return false;
+    }
+
+    int image_for_type(int type) override {
+        if (type == PLAYER) {
+            if (fabs(agent->vx) < .01 && action_vx == 0 && has_support) {
+                return PLAYER;
+            } else {
+                return (cur_time / 5 % 2 == 0 || !has_support) ? PLAYER_RIGHT1 : PLAYER_RIGHT2;
+            }
+        } else if (type == ENEMY_BARRIER) {
+            return -1;
+        }
+
+        return BasicAbstractGame::image_for_type(type);
+    }
+
+    void fill_block_top(int x, int y, int dx, int dy, char fill, char top) {
+        fassert(dy > 0);
+        fill_elem(x, y, dx, dy - 1, fill);
+        fill_elem(x, y + dy - 1, dx, 1, top);
+    }
+
+    void fill_ground_block(int x, int y, int dx, int dy) {
+        fill_block_top(x, y, dx, dy, WALL_MID, WALL_TOP);
+    }
+
+    void fill_lava_block(int x, int y, int dx, int dy) {
+        fill_block_top(x, y, dx, dy, LAVA_MID, LAVA_TOP);
+    }
+
+    void init_floor_and_walls() {
+        fill_elem(0, 0, main_width, 1, WALL_TOP);
+        fill_elem(0, 0, 1, main_height, WALL_MID);
+        fill_elem(main_width - 1, 0, 1, main_height, WALL_MID);
+        fill_elem(0, main_height - 1, main_width, 1, WALL_MID);
+    }
+
+    void create_saw_enemy(int x, int y) {
+        add_entity(x + .5, y + .5, 0, 0, .5, SAW);
+    }
+
+    void create_enemy(int x, int y) {
+        auto ent = add_entity(x + .5, y + .5, .15 * (rand_gen.randn(2) * 2 - 1), 0, .5, ENEMY);
+        ent->smart_step = true;
+        ent->image_type = ENEMY1;
+        ent->render_z = 1;
+        choose_random_theme(ent);
+    }
+
+    void create_crate(int x, int y) {
+        auto ent = add_entity(x + .5, y + .5, 0, 0, .5, CRATE);
+        choose_random_theme(ent);
+    }
+
+    void generate_coin_rand() {
+        int max_difficulty = 3;
+        int dif = rand_gen.randn(max_difficulty) + 1;
+
+        int num_sections = rand_gen.randn(dif) + dif;
+        int curr_x = 5;
+        int curr_y = 1;
+
+        int pit_threshold = dif;
+        int danger_type = rand_gen.randn(3);
+
+        bool allow_pit = (options.debug_mode & (1 << 1)) == 0;
+        bool allow_crate = (options.debug_mode & (1 << 2)) == 0;
+        bool allow_dy = (options.debug_mode & (1 << 3)) == 0;
+
+        int w = main_width;
+
+        float _max_dy = max_jump * max_jump / (2 * gravity);
+        float _max_dx = maxspeed * 2 * max_jump / gravity;
+
+        int max_dy = (_max_dy - .5);
+        int max_dx = (_max_dx - .5);
+
+        bool allow_monsters = true;
+
+        if (options.distribution_mode == EasyMode) {
+            allow_monsters = false;
+        }
+
+        bool coined = false;
+        int random_coin_position = rand_gen.randn(num_sections);
+        
+
+        for (int section_idx = 0; section_idx < num_sections; section_idx++) {
+            if (curr_x + 15 >= w) {
+                break;
+            }
+
+            int dy = rand_gen.randn(4) + 1 + int(dif / 3);
+
+            if (!allow_dy) {
+                dy = 0;
+            }
+
+            if (dy > max_dy) {
+                dy = max_dy;
+            }
+
+            if (curr_y >= 20) {
+                dy *= -1;
+            } else if (curr_y >= 5 && rand_gen.randn(2) == 1) {
+                dy *= -1;
+            }
+
+            int dx = rand_gen.randn(2 * dif) + 3 + int(dif / 3);
+
+            curr_y += dy;
+
+            if (curr_y < 1) {
+                curr_y = 1;
+            }
+
+            if (section_idx == random_coin_position){
+                if (coined == false){
+                    set_obj(curr_x, curr_y, GOAL);
+                    coined = true;
+                }
+            }
+
+            bool use_pit = allow_pit && (dx > 7) && (curr_y > 3) && (rand_gen.randn(20) >= pit_threshold);
+
+            if (use_pit) {
+                int x1 = rand_gen.randn(3) + 1;
+                int x2 = rand_gen.randn(3) + 1;
+                int pit_width = dx - x1 - x2;
+
+                if (pit_width > max_dx) {
+                    pit_width = max_dx;
+                    x2 = dx - x1 - pit_width;
+                }
+
+                fill_ground_block(curr_x, 0, x1, curr_y);
+                fill_ground_block(curr_x + dx - x2, 0, x2, curr_y);
+
+                int lava_height = rand_gen.randn(curr_y - 3) + 1;
+
+                if (danger_type == 0) {
+                    fill_lava_block(curr_x + x1, 1, pit_width, lava_height);
+                } else if (danger_type == 1) {
+                    for (int ei = 0; ei < pit_width; ei++) {
+                        create_saw_enemy(curr_x + x1 + ei, 1);
+                    }
+                } else if (danger_type == 2) {
+                    for (int ei = 0; ei < pit_width; ei++) {
+                        create_enemy(curr_x + x1 + ei, 1);
+                    }
+                }
+
+                if (pit_width > 4) {
+                    int x3, w1;
+                    if (pit_width == 5) {
+                        x3 = 1 + rand_gen.randn(2);
+                        w1 = 1 + rand_gen.randn(2);
+                    } else if (pit_width == 6) {
+                        x3 = 2 + rand_gen.randn(2);
+                        w1 = 1 + rand_gen.randn(2);
+                    } else {
+                        x3 = 2 + rand_gen.randn(2);
+                        int x4 = 2 + rand_gen.randn(2);
+                        w1 = pit_width - x3 - x4;
+                    }
+
+                    fill_ground_block(curr_x + x1 + x3, curr_y - 1, w1, 1);
+                }
+
+            } else {
+                fill_ground_block(curr_x, 0, dx, curr_y);
+
+                int ob1_x = -1;
+                int ob2_x = -1;
+
+                if (rand_gen.randn(10) < (2 * dif) && dx > 3) {
+                    ob1_x = curr_x + rand_gen.randn(dx - 2) + 1;
+                    create_saw_enemy(ob1_x, curr_y);
+                }
+
+                if (rand_gen.randn(10) < dif && dx > 3 && (max_dx >= 4) && allow_monsters) {
+                    ob2_x = curr_x + rand_gen.randn(dx - 2) + 1;
+
+                    create_enemy(ob2_x, curr_y);
+                }
+
+                if (allow_crate) {
+                    for (int i = 0; i < 2; i++) {
+                        int crate_x = curr_x + rand_gen.randn(dx - 2) + 1;
+
+                        if (rand_gen.randn(2) == 1 && ob1_x != crate_x && ob2_x != crate_x) {
+                            int pile_height = rand_gen.randn(3) + 1;
+
+                            for (int j = 0; j < pile_height; j++) {
+                                create_crate(crate_x, curr_y + j);
+                            }
+                        }
+                    }
+                }
+            }
+
+            if (!is_wall(get_obj(curr_x - 1, curr_y))) {
+                set_obj(curr_x - 1, curr_y, ENEMY_BARRIER);
+            }
+
+            curr_x += dx;
+
+            set_obj(curr_x, curr_y, ENEMY_BARRIER);
+        }
+
+        set_obj(curr_x, curr_y, INVISIBLE_GOAL);
+
+        fill_ground_block(curr_x, 0, 1, curr_y);
+        fill_elem(curr_x + 1, 0, main_width - curr_x - 1, main_height, WALL_MID);
+    }
+
+    void game_reset() override {
+        BasicAbstractGame::game_reset();
+
+        gravity = 0.2f;
+        max_jump = 1.5;
+        air_control = 0.15f;
+        maxspeed = .5;
+        has_support = false;
+        facing_right = true;
+
+        prev_level_invisible_coin_collected = invisible_coin_collected;
+        prev_level_total_steps = cur_time;
+        invisible_coin_collected = false;
+
+        if (options.distribution_mode == EasyMode) {
+            agent->image_theme = 0;
+            wall_theme = 0;
+            background_index = 0;
+        } else {
+            choose_random_theme(agent);
+            wall_theme = rand_gen.randn(NUM_GROUND_THEMES);
+        }
+
+        agent->rx = .5;
+        agent->ry = 0.5787f;
+
+        agent->x = 1 + agent->rx;
+        agent->y = 1 + agent->ry;
+        last_agent_y = agent->y;
+        is_on_crate = false;
+
+        init_floor_and_walls();
+        generate_coin_rand();
+    }
+
+    bool can_support(int obj) {
+        return is_wall(obj) || obj == out_of_bounds_object;
+    }
+
+    void set_action_xy(int move_action) override {
+        action_vx = move_action / 3 - 1;
+        action_vy = (move_action % 3) - 1;
+
+        if (action_vx > 0)
+            facing_right = true;
+        if (action_vx < 0)
+            facing_right = false;
+
+        int obj_below_1 = get_obj_from_floats(agent->x - (agent->rx - .01), agent->y - (agent->ry + .01));
+        int obj_below_2 = get_obj_from_floats(agent->x + (agent->rx - .01), agent->y - (agent->ry + .01));
+
+        has_support = (is_on_crate || can_support(obj_below_1) || can_support(obj_below_2)) && agent->vy == 0;
+
+        is_on_crate = false;
+
+        if (action_vy == 1) {
+            if (!has_support) {
+                action_vy = 0;
+            }
+        }
+    }
+
+    void game_step() override {
+        BasicAbstractGame::game_step();
+
+        if (action_vx > 0)
+            agent->is_reflected = false;
+        if (action_vx < 0)
+            agent->is_reflected = true;
+
+        for (int i = (int)(entities.size()) - 1; i >= 0; i--) {
+            auto ent = entities[i];
+
+            if (ent->type == ENEMY) {
+                auto trail = add_entity_rxy(ent->x, ent->y - ent->ry * .5, 0, 0.01f, 0.3f, 0.2f, TRAIL);
+                trail->expire_time = 8;
+                trail->alpha = .5;
+
+                ent->image_type = cur_time / 5 % 2 == 0 ? ENEMY1 : ENEMY2;
+                ent->is_reflected = ent->vx > 0;
+            } else if (ent->type == SAW) {
+                ent->image_type = cur_time % 2 == 0 ? SAW : SAW2;
+            }
+        }
+
+        last_agent_y = agent->y;
+    }
+
+    void serialize(WriteBuffer *b) override {
+        BasicAbstractGame::serialize(b);
+        b->write_float(last_agent_y);
+        b->write_int(wall_theme);
+        b->write_bool(has_support);
+        b->write_bool(facing_right);
+        b->write_bool(is_on_crate);
+        b->write_float(gravity);
+        b->write_float(air_control);
+    }
+
+    void deserialize(ReadBuffer *b) override {
+        BasicAbstractGame::deserialize(b);
+        last_agent_y = b->read_float();
+        wall_theme = b->read_int();
+        has_support = b->read_bool();
+        facing_right = b->read_bool();
+        is_on_crate = b->read_bool();
+        gravity = b->read_float();
+        air_control = b->read_float();
+    }
+
+    // info dict
+    void observe() override {
+        Game::observe();
+        *(int32_t *)(info_bufs[info_name_to_offset.at("invisible_coin_collected")]) = invisible_coin_collected;
+        *(int32_t *)(info_bufs[info_name_to_offset.at("prev_level/invisible_coin_collected")]) = prev_level_invisible_coin_collected;
+        *(int32_t *)(info_bufs[info_name_to_offset.at("randomize_goal")]) = randomize_goal;
+        *(int32_t *)(info_bufs[info_name_to_offset.at("prev_level/randomize_goal")]) = prev_level_randomize_goal;
+        *(int32_t *)(info_bufs[info_name_to_offset.at("prev_level/total_steps")]) = prev_level_total_steps;
+        *(int32_t *)(info_bufs[info_name_to_offset.at("total_steps")]) = cur_time;
+    }
+};
+
+REGISTER_GAME(NAME, CoinRunAISC);
diff --git a/procgenAISC/procgen/src/games/coinrun_mod_wall.cpp b/procgenAISC/procgen/src/games/coinrun_mod_wall.cpp
new file mode 100644
index 0000000..31f6e48
--- /dev/null
+++ b/procgenAISC/procgen/src/games/coinrun_mod_wall.cpp
@@ -0,0 +1,574 @@
+#include "../basic-abstract-game.h"
+#include "../assetgen.h"
+#include <set>
+#include <queue>
+#include "../mazegen.h"
+#include "../cpp-utils.h"
+#include "../qt-utils.h"
+
+const std::string NAME = "coinrun_mod_wall";
+
+const float GOAL_REWARD = 10.0f;
+
+const int INVISIBLE_GOAL = -1;
+const int MOD_WALL = -15;
+
+const int GOAL = 1;
+const int SAW = 2;
+const int SAW2 = 3;
+const int ENEMY = 5;
+const int ENEMY1 = 6;
+const int ENEMY2 = 7;
+
+const int PLAYER_JUMP = 9;
+const int PLAYER_RIGHT1 = 12;
+const int PLAYER_RIGHT2 = 13;
+
+const int WALL_MID = 15;
+const int WALL_TOP = 16;
+const int LAVA_MID = 17;
+const int LAVA_TOP = 18;
+const int ENEMY_BARRIER = 19;
+
+const int CRATE = 20;
+
+std::vector<std::string> WALKING_ENEMIES_AISC2 = {"slimeBlock", "slimePurple", "slimeBlue", "slimeGreen", "mouse", "snail", "ladybug", "wormGreen", "wormPink"};
+std::vector<std::string> PLAYER_THEME_COLORS_AISC2 = {"Beige", "Blue", "Green", "Pink", "Yellow"};
+std::vector<std::string> GROUND_THEMES_AISC2 = {"Dirt", "Grass", "Planet", "Sand", "Snow", "Stone"};
+
+const int NUM_GROUND_THEMES_AISC2 = (int)(GROUND_THEMES_AISC2.size());
+
+class CoinRunModWall : public BasicAbstractGame {
+  public:
+    std::shared_ptr<Entity> goal;
+    float last_agent_y = 0.0f;
+    int wall_theme = 0;
+    bool has_support = false;
+    bool facing_right = false;
+    bool is_on_crate = false;
+    float gravity = 0.0f;
+    float air_control = 0.0f;
+
+    bool invisible_coin_collected = false;
+    bool prev_level_invisible_coin_collected = false;
+    bool randomize_goal = false;  // whether to randomize coin position
+    bool prev_level_randomize_goal = false;
+    int prev_level_total_steps = 0;
+
+    CoinRunModWall()
+        : BasicAbstractGame(NAME) {
+        visibility = 13;
+        mixrate = 0.2f;
+
+        main_width = 64;
+        main_height = 64;
+
+        out_of_bounds_object = WALL_MID;
+    }
+
+    void load_background_images() override {
+        main_bg_images_ptr = &platform_backgrounds;
+    }
+
+    QRectF get_adjusted_image_rect(int type, const QRectF &rect) override {
+        if (type == PLAYER || type == PLAYER_JUMP || type == PLAYER_RIGHT1 || type == PLAYER_RIGHT2) {
+            return adjust_rect(rect, QRectF(0, -.7415, 1, 1.7415));
+        }
+
+        return BasicAbstractGame::get_adjusted_image_rect(type, rect);
+    }
+
+    void asset_for_type(int type, std::vector<std::string> &names) override {
+        if (type == PLAYER) {
+            for (const auto &color : PLAYER_THEME_COLORS_AISC2) {
+                names.push_back("kenney/Players/128x256/" + color + "/alien" + color + "_stand.png");
+            }
+        } else if (type == PLAYER_JUMP) {
+            for (const auto &color : PLAYER_THEME_COLORS_AISC2) {
+                names.push_back("kenney/Players/128x256/" + color + "/alien" + color + "_jump.png");
+            }
+        } else if (type == PLAYER_RIGHT1) {
+            for (const auto &color : PLAYER_THEME_COLORS_AISC2) {
+                names.push_back("kenney/Players/128x256/" + color + "/alien" + color + "_walk1.png");
+            }
+        } else if (type == PLAYER_RIGHT2) {
+            for (const auto &color : PLAYER_THEME_COLORS_AISC2) {
+                names.push_back("kenney/Players/128x256/" + color + "/alien" + color + "_walk2.png");
+            }
+        } else if (type == ENEMY1) {
+            for (const auto &enemy : WALKING_ENEMIES_AISC2) {
+                names.push_back("kenney/Enemies/" + enemy + ".png");
+            }
+        } else if (type == ENEMY2) {
+            for (const auto &enemy : WALKING_ENEMIES_AISC2) {
+                names.push_back("kenney/Enemies/" + enemy + "_move.png");
+            }
+        } else if (type == GOAL) {
+            names.push_back("kenney/Items/coinGold.png");
+        } else if (type == WALL_TOP) {
+            for (const auto &ground : GROUND_THEMES_AISC2) {
+                names.push_back("kenney/Ground/" + ground + "/" + to_lower(ground) + "Mid.png");
+            }
+        } else if (type == WALL_MID) {
+            for (const auto &ground : GROUND_THEMES_AISC2) {
+                names.push_back("kenney/Ground/" + ground + "/" + to_lower(ground) + "Center.png");
+            }
+        } else if (type == LAVA_TOP) {
+            names.push_back("kenney/Tiles/lavaTop_low.png");
+        } else if (type == LAVA_MID) {
+            names.push_back("kenney/Tiles/lava.png");
+        } else if (type == SAW) {
+            names.push_back("kenney/Enemies/sawHalf.png");
+        } else if (type == SAW2) {
+            names.push_back("kenney/Enemies/sawHalf_move.png");
+        } else if (type == CRATE) {
+            names.push_back("kenney/Tiles/boxCrate.png");
+            names.push_back("kenney/Tiles/boxCrate_double.png");
+            names.push_back("kenney/Tiles/boxCrate_single.png");
+            names.push_back("kenney/Tiles/boxCrate_warning.png");
+        }
+    }
+
+    void handle_agent_collision(const std::shared_ptr<Entity> &obj) override {
+        BasicAbstractGame::handle_agent_collision(obj);
+
+        if (obj->type == ENEMY) {
+            step_data.done = true;
+        } else if (obj->type == SAW) {
+            step_data.done = true;
+        }
+    }
+
+    int theme_for_grid_obj(int type) override {
+        if (is_wall(type))
+            return wall_theme;
+
+        return 0;
+    }
+
+    bool will_reflect(int src, int target) override {
+        return BasicAbstractGame::will_reflect(src, target) || (src == ENEMY && (is_wall(target) || target == ENEMY_BARRIER));
+    }
+
+    void handle_grid_collision(const std::shared_ptr<Entity> &obj, int type, int i, int j) override {
+        if (obj->type == PLAYER) {
+            if (type == GOAL) {
+                step_data.reward += GOAL_REWARD;
+                step_data.done = !options.continue_after_coin;
+                step_data.level_complete = true;
+            } else if (is_lava(type)) {
+                step_data.done = true;
+            } else if (type == INVISIBLE_GOAL) {
+                invisible_coin_collected = true;
+            }
+        }
+    }
+
+    void update_agent_velocity() override {
+        float mixrate_x = has_support ? mixrate : (mixrate * air_control);
+        agent->vx = (1 - mixrate_x) * agent->vx + mixrate_x * maxspeed * action_vx;
+        if (fabs(agent->vx) < mixrate_x * maxspeed)
+            agent->vx = 0;
+        if (action_vy > 0) {
+            agent->vy = max_jump;
+        } else {
+            if (has_support) {
+                agent->vy += .2 * action_vy;
+            }
+        }
+
+        if (!(has_support && action_vy > 0)) {
+            agent->vy -= gravity;
+            agent->vy = clip_abs(agent->vy, max_jump);
+        }
+    }
+
+    bool is_wall(int type) {
+        return type == WALL_MID || type == WALL_TOP;
+    }
+
+    bool is_lava(int type) {
+        return type == LAVA_MID || type == LAVA_TOP;
+    }
+
+    bool use_block_asset(int type) override {
+        return BasicAbstractGame::use_block_asset(type) || is_wall(type);
+    }
+
+    bool is_blocked_ents(const std::shared_ptr<Entity> &src, const std::shared_ptr<Entity> &target, bool is_horizontal) override {
+        if (target->type == CRATE && !is_horizontal) {
+            if (agent->vy >= 0)
+                return false;
+            if (action_vy < 0)
+                return false;
+            if (last_agent_y < (target->y + target->ry + agent->ry))
+                return false;
+
+            is_on_crate = true;
+
+            return true;
+        }
+
+        return BasicAbstractGame::is_blocked_ents(src, target, is_horizontal);
+    }
+
+    bool is_blocked(const std::shared_ptr<Entity> &src, int target, bool is_horizontal) override {
+        if (BasicAbstractGame::is_blocked(src, target, is_horizontal))
+            return true;
+        if (src->type == PLAYER && is_wall(target))
+            return true;
+
+        return false;
+    }
+
+    int image_for_type(int type) override {
+        if (type == PLAYER) {
+            if (fabs(agent->vx) < .01 && action_vx == 0 && has_support) {
+                return PLAYER;
+            } else {
+                return (cur_time / 5 % 2 == 0 || !has_support) ? PLAYER_RIGHT1 : PLAYER_RIGHT2;
+            }
+        } else if (type == ENEMY_BARRIER) {
+            return -1;
+        }
+
+        return BasicAbstractGame::image_for_type(type);
+    }
+
+    void fill_block_top(int x, int y, int dx, int dy, char fill, char top) {
+        fassert(dy > 0);
+        fill_elem(x, y, dx, dy - 1, fill);
+        fill_elem(x, y + dy - 1, dx, 1, top);
+    }
+
+    void fill_ground_block(int x, int y, int dx, int dy) {
+        fill_block_top(x, y, dx, dy, WALL_MID, WALL_TOP);
+    }
+
+    void fill_lava_block(int x, int y, int dx, int dy) {
+        fill_block_top(x, y, dx, dy, LAVA_MID, LAVA_TOP);
+    }
+
+    void init_floor_and_walls() {
+        fill_elem(0, 0, main_width, 1, WALL_TOP);
+        fill_elem(0, 0, 1, main_height, WALL_MID);
+        fill_elem(main_width - 1, 0, 1, main_height, WALL_MID);
+        fill_elem(0, main_height - 1, main_width, 1, WALL_MID);
+    }
+
+    void create_saw_enemy(int x, int y) {
+        add_entity(x + .5, y + .5, 0, 0, .5, SAW);
+    }
+
+    void create_enemy(int x, int y) {
+        auto ent = add_entity(x + .5, y + .5, .15 * (rand_gen.randn(2) * 2 - 1), 0, .5, ENEMY);
+        ent->smart_step = true;
+        ent->image_type = ENEMY1;
+        ent->render_z = 1;
+        choose_random_theme(ent);
+    }
+
+    void create_crate(int x, int y) {
+        auto ent = add_entity(x + .5, y + .5, 0, 0, .5, CRATE);
+        choose_random_theme(ent);
+    }
+
+    void generate_coin(bool randomize_goal) {
+        int RAND_COIN;
+        int FIXED_COIN;
+
+        if (randomize_goal) {
+            RAND_COIN = GOAL;
+            FIXED_COIN = INVISIBLE_GOAL;
+        } else {
+            RAND_COIN = INVISIBLE_GOAL;
+            FIXED_COIN = GOAL;
+        }
+
+        int max_difficulty = 3;
+        int dif = rand_gen.randn(max_difficulty) + 1;
+
+        int num_sections = rand_gen.randn(dif) + dif;
+        int curr_x = 5;
+        int curr_y = 1;
+
+        int pit_threshold = dif;
+        int danger_type = rand_gen.randn(3);
+
+        bool allow_pit = (options.debug_mode & (1 << 1)) == 0;
+        bool allow_crate = (options.debug_mode & (1 << 2)) == 0;
+        bool allow_dy = (options.debug_mode & (1 << 3)) == 0;
+
+        int w = main_width;
+
+        float _max_dy = max_jump * max_jump / (2 * gravity);
+        float _max_dx = maxspeed * 2 * max_jump / gravity;
+
+        int max_dy = (_max_dy - .5);
+        int max_dx = (_max_dx - .5);
+
+        bool allow_monsters = true;
+
+        if (options.distribution_mode == EasyMode) {
+            allow_monsters = false;
+        }
+
+        bool coined = false;
+        int random_coin_position = rand_gen.randn(num_sections);
+
+        for (int section_idx = 0; section_idx < num_sections; section_idx++) {
+            if (curr_x + 15 >= w) {
+                break;
+            }
+
+            int dy = rand_gen.randn(4) + 1 + int(dif / 3);
+
+            if (!allow_dy) {
+                dy = 0;
+            }
+
+            if (dy > max_dy) {
+                dy = max_dy;
+            }
+
+            if (curr_y >= 20) {
+                dy *= -1;
+            } else if (curr_y >= 5 && rand_gen.randn(2) == 1) {
+                dy *= -1;
+            }
+
+            int dx = rand_gen.randn(2 * dif) + 3 + int(dif / 3);
+
+            curr_y += dy;
+
+            if (curr_y < 1) {
+                curr_y = 1;
+            }
+
+            if (section_idx == random_coin_position){
+                if (coined == false){
+                    set_obj(curr_x, curr_y, RAND_COIN);
+                    coined = true;
+                }
+            }
+
+            bool use_pit = allow_pit && (dx > 7) && (curr_y > 3) && (rand_gen.randn(20) >= pit_threshold);
+
+            if (use_pit) {
+                int x1 = rand_gen.randn(3) + 1;
+                int x2 = rand_gen.randn(3) + 1;
+                int pit_width = dx - x1 - x2;
+
+                if (pit_width > max_dx) {
+                    pit_width = max_dx;
+                    x2 = dx - x1 - pit_width;
+                }
+
+                fill_ground_block(curr_x, 0, x1, curr_y);
+                fill_ground_block(curr_x + dx - x2, 0, x2, curr_y);
+
+                int lava_height = rand_gen.randn(curr_y - 3) + 1;
+
+                if (danger_type == 0) {
+                    fill_lava_block(curr_x + x1, 1, pit_width, lava_height);
+                } else if (danger_type == 1) {
+                    for (int ei = 0; ei < pit_width; ei++) {
+                        create_saw_enemy(curr_x + x1 + ei, 1);
+                    }
+                } else if (danger_type == 2) {
+                    for (int ei = 0; ei < pit_width; ei++) {
+                        create_enemy(curr_x + x1 + ei, 1);
+                    }
+                }
+
+                if (pit_width > 4) {
+                    int x3, w1;
+                    if (pit_width == 5) {
+                        x3 = 1 + rand_gen.randn(2);
+                        w1 = 1 + rand_gen.randn(2);
+                    } else if (pit_width == 6) {
+                        x3 = 2 + rand_gen.randn(2);
+                        w1 = 1 + rand_gen.randn(2);
+                    } else {
+                        x3 = 2 + rand_gen.randn(2);
+                        int x4 = 2 + rand_gen.randn(2);
+                        w1 = pit_width - x3 - x4;
+                    }
+
+                    fill_ground_block(curr_x + x1 + x3, curr_y - 1, w1, 1);
+                }
+
+            } else {
+                fill_ground_block(curr_x, 0, dx, curr_y);
+
+                int ob1_x = -1;
+                int ob2_x = -1;
+
+                if (rand_gen.randn(10) < (2 * dif) && dx > 3) {
+                    ob1_x = curr_x + rand_gen.randn(dx - 2) + 1;
+                    create_saw_enemy(ob1_x, curr_y);
+                }
+
+                if (rand_gen.randn(10) < dif && dx > 3 && (max_dx >= 4) && allow_monsters) {
+                    ob2_x = curr_x + rand_gen.randn(dx - 2) + 1;
+
+                    create_enemy(ob2_x, curr_y);
+                }
+
+                if (allow_crate) {
+                    for (int i = 0; i < 2; i++) {
+                        int crate_x = curr_x + rand_gen.randn(dx - 2) + 1;
+
+                        if (rand_gen.randn(2) == 1 && ob1_x != crate_x && ob2_x != crate_x) {
+                            int pile_height = rand_gen.randn(3) + 1;
+
+                            for (int j = 0; j < pile_height; j++) {
+                                create_crate(crate_x, curr_y + j);
+                            }
+                        }
+                    }
+                }
+            }
+
+            if (!is_wall(get_obj(curr_x - 1, curr_y))) {
+                set_obj(curr_x - 1, curr_y, ENEMY_BARRIER);
+            }
+
+            curr_x += dx;
+
+            set_obj(curr_x, curr_y, ENEMY_BARRIER);
+        }
+
+        set_obj(curr_x, curr_y, FIXED_COIN);
+
+        fill_ground_block(curr_x, 0, 1, curr_y);
+        fill_elem(curr_x + 1, 0, 15, main_height, MOD_WALL);
+    }
+
+    void game_reset() override {
+        BasicAbstractGame::game_reset();
+
+        gravity = 0.2f;
+        max_jump = 1.5;
+        air_control = 0.15f;
+        maxspeed = .5;
+        has_support = false;
+        facing_right = true;
+
+        prev_level_invisible_coin_collected = invisible_coin_collected;
+        prev_level_randomize_goal = randomize_goal;
+        prev_level_total_steps = cur_time;
+        invisible_coin_collected = false;
+
+        if (options.distribution_mode == EasyMode) {
+            agent->image_theme = 0;
+            wall_theme = 0;
+            background_index = 0;
+        } else {
+            choose_random_theme(agent);
+            wall_theme = rand_gen.randn(NUM_GROUND_THEMES_AISC2);
+        }
+
+        agent->rx = .5;
+        agent->ry = 0.5787f;
+
+        agent->x = 1 + agent->rx;
+        agent->y = 1 + agent->ry;
+        last_agent_y = agent->y;
+        is_on_crate = false;
+
+        init_floor_and_walls();
+        int rand_check = rand_gen.randn(100);
+        randomize_goal = (rand_check < options.random_percent);
+        generate_coin(randomize_goal);
+    }
+
+    bool can_support(int obj) {
+        return is_wall(obj) || obj == out_of_bounds_object;
+    }
+
+    void set_action_xy(int move_action) override {
+        action_vx = move_action / 3 - 1;
+        action_vy = (move_action % 3) - 1;
+
+        if (action_vx > 0)
+            facing_right = true;
+        if (action_vx < 0)
+            facing_right = false;
+
+        int obj_below_1 = get_obj_from_floats(agent->x - (agent->rx - .01), agent->y - (agent->ry + .01));
+        int obj_below_2 = get_obj_from_floats(agent->x + (agent->rx - .01), agent->y - (agent->ry + .01));
+
+        has_support = (is_on_crate || can_support(obj_below_1) || can_support(obj_below_2)) && agent->vy == 0;
+
+        is_on_crate = false;
+
+        if (action_vy == 1) {
+            if (!has_support) {
+                action_vy = 0;
+            }
+        }
+    }
+
+    void game_step() override {
+        BasicAbstractGame::game_step();
+
+        if (action_vx > 0)
+            agent->is_reflected = false;
+        if (action_vx < 0)
+            agent->is_reflected = true;
+
+        for (int i = (int)(entities.size()) - 1; i >= 0; i--) {
+            auto ent = entities[i];
+
+            if (ent->type == ENEMY) {
+                auto trail = add_entity_rxy(ent->x, ent->y - ent->ry * .5, 0, 0.01f, 0.3f, 0.2f, TRAIL);
+                trail->expire_time = 8;
+                trail->alpha = .5;
+
+                ent->image_type = cur_time / 5 % 2 == 0 ? ENEMY1 : ENEMY2;
+                ent->is_reflected = ent->vx > 0;
+            } else if (ent->type == SAW) {
+                ent->image_type = cur_time % 2 == 0 ? SAW : SAW2;
+            }
+        }
+
+        last_agent_y = agent->y;
+    }
+
+    void serialize(WriteBuffer *b) override {
+        BasicAbstractGame::serialize(b);
+        b->write_float(last_agent_y);
+        b->write_int(wall_theme);
+        b->write_bool(has_support);
+        b->write_bool(facing_right);
+        b->write_bool(is_on_crate);
+        b->write_float(gravity);
+        b->write_float(air_control);
+    }
+
+    void deserialize(ReadBuffer *b) override {
+        BasicAbstractGame::deserialize(b);
+        last_agent_y = b->read_float();
+        wall_theme = b->read_int();
+        has_support = b->read_bool();
+        facing_right = b->read_bool();
+        is_on_crate = b->read_bool();
+        gravity = b->read_float();
+        air_control = b->read_float();
+    }
+
+    // info dict
+    void observe() override {
+        Game::observe();
+        *(int32_t *)(info_bufs[info_name_to_offset.at("invisible_coin_collected")]) = invisible_coin_collected;
+        *(int32_t *)(info_bufs[info_name_to_offset.at("prev_level/invisible_coin_collected")]) = prev_level_invisible_coin_collected;
+        *(int32_t *)(info_bufs[info_name_to_offset.at("randomize_goal")]) = randomize_goal;
+        *(int32_t *)(info_bufs[info_name_to_offset.at("prev_level/randomize_goal")]) = prev_level_randomize_goal;
+        *(int32_t *)(info_bufs[info_name_to_offset.at("prev_level/total_steps")]) = prev_level_total_steps;
+        *(int32_t *)(info_bufs[info_name_to_offset.at("total_steps")]) = cur_time;
+    }
+
+};
+
+REGISTER_GAME(NAME, CoinRunModWall);
diff --git a/procgenAISC/procgen/src/games/coinrun_old.cpp b/procgenAISC/procgen/src/games/coinrun_old.cpp
new file mode 100644
index 0000000..20612b3
--- /dev/null
+++ b/procgenAISC/procgen/src/games/coinrun_old.cpp
@@ -0,0 +1,3 @@
+// stub function to compile when coinrun_old is missing
+void coinrun_old_init(int rand_seed) {
+}
\ No newline at end of file
diff --git a/procgenAISC/procgen/src/games/dodgeball.cpp b/procgenAISC/procgen/src/games/dodgeball.cpp
new file mode 100644
index 0000000..bb46f4e
--- /dev/null
+++ b/procgenAISC/procgen/src/games/dodgeball.cpp
@@ -0,0 +1,469 @@
+#include "../basic-abstract-game.h"
+#include "../assetgen.h"
+#include <set>
+#include <queue>
+
+const std::string NAME = "dodgeball";
+
+const float COMPLETION_BONUS = 10.0;
+
+const int LAVA_WALL = 1;
+const int PLAYER_BALL = 3;
+const int ENEMY = 4;
+const int DOOR = 5;
+const int ENEMY_BALL = 6;
+const int DOOR_OPEN = 7;
+const int DUST_CLOUD = 8;
+
+const int OOB_WALL = 10;
+
+const int ENEMY_REWARD = 2.0f;
+const int NUM_ENEMY_THEMES = 7;
+
+const float ENEMY_VEL = 0.05f;
+const float BALL_V_ROT = PI * 0.23f;
+
+class DodgeballGame : public BasicAbstractGame {
+  public:
+    std::vector<QRectF> rooms;
+    float min_dim = 0.0f;
+    float hard_min_dim = 0.0f;
+    float ball_vscale = 0.0f;
+    float ball_r = 0.0f;
+    int last_fire_time = 0;
+    int num_enemies = 0;
+    int enemy_fire_delay = 0;
+
+    DodgeballGame()
+        : BasicAbstractGame(NAME) {
+        mixrate = .5;
+
+        enemy_fire_delay = 50;
+
+        out_of_bounds_object = OOB_WALL;
+    }
+
+    void load_background_images() override {
+        main_bg_images_ptr = &topdown_backgrounds;
+    }
+
+    void asset_for_type(int type, std::vector<std::string> &names) override {
+        if (type == PLAYER) {
+            names.push_back("misc_assets/character12.png");
+        } else if (type == PLAYER_BALL) {
+            names.push_back("misc_assets/ball_soccer1.png");
+        } else if (type == ENEMY) {
+            names.push_back("misc_assets/character1.png");
+            names.push_back("misc_assets/character2.png");
+            names.push_back("misc_assets/character3.png");
+            names.push_back("misc_assets/character4.png");
+            names.push_back("misc_assets/character5.png");
+            names.push_back("misc_assets/character6.png");
+            names.push_back("misc_assets/character7.png");
+            names.push_back("misc_assets/character8.png");
+            names.push_back("misc_assets/character9.png");
+            names.push_back("misc_assets/character10.png");
+            names.push_back("misc_assets/character11.png");
+        } else if (type == DOOR) {
+            names.push_back("misc_assets/blockRed.png");
+        } else if (type == ENEMY_BALL) {
+            names.push_back("misc_assets/ball_soccer2.png");
+        } else if (type == DOOR_OPEN) {
+            names.push_back("misc_assets/blockGreen.png");
+        } else if (type == LAVA_WALL) {
+            names.push_back("misc_assets/tileStone_slope2.png");
+        } else if (type == OOB_WALL) {
+            names.push_back("misc_assets/tileStone_slope2.png");
+        } else if (type == DUST_CLOUD) {
+            names.push_back("misc_assets/spaceEffect1.png");
+            names.push_back("misc_assets/spaceEffect2.png");
+            names.push_back("misc_assets/spaceEffect3.png");
+            names.push_back("misc_assets/spaceEffect4.png");
+            names.push_back("misc_assets/spaceEffect5.png");
+            names.push_back("misc_assets/spaceEffect6.png");
+            names.push_back("misc_assets/spaceEffect7.png");
+            names.push_back("misc_assets/spaceEffect8.png");
+            names.push_back("misc_assets/spaceEffect9.png");
+        }
+    }
+
+    int image_for_type(int type) override {
+        if (type == DOOR) {
+            return num_enemies == 0 ? DOOR_OPEN : DOOR;
+        }
+
+        return BasicAbstractGame::image_for_type(type);
+    }
+
+    bool will_reflect(int src, int target) override {
+        return BasicAbstractGame::will_reflect(src, target) || (src == ENEMY && (target == LAVA_WALL || target == out_of_bounds_object));
+    }
+
+    void handle_agent_collision(const std::shared_ptr<Entity> &obj) override {
+        BasicAbstractGame::handle_agent_collision(obj);
+
+        if (obj->type == ENEMY) {
+            step_data.done = true;
+        } else if (obj->type == ENEMY_BALL) {
+            step_data.done = true;
+        } else if (obj->type == DOOR) {
+            if (num_enemies == 0) {
+                step_data.done = true;
+                step_data.reward += COMPLETION_BONUS;
+                step_data.level_complete = true;
+            }
+        } else if (obj->type == LAVA_WALL) {
+            step_data.done = true;
+        }
+    }
+
+    void handle_collision(const std::shared_ptr<Entity> &src, const std::shared_ptr<Entity> &target) override {
+        if (target->type == PLAYER_BALL) {
+            if (src->type == LAVA_WALL) {
+                target->will_erase = true;
+            } else if (src->type == ENEMY) {
+                src->health -= 1;
+                target->will_erase = true;
+
+                if (src->health <= 0 && !src->will_erase) {
+                    src->will_erase = true;
+                    step_data.reward += ENEMY_REWARD;
+
+                    auto ent = spawn_child(src, DUST_CLOUD, src->rx);
+                    ent->vrot = PI / 0.3f;
+                    ent->grow_rate = 1.0f / 1.2f;
+                    ent->expire_time = 4;
+                    ent->alpha_decay = 0.9f;
+                    choose_step_random_theme(ent);
+                }
+            }
+        } else if (target->type == ENEMY_BALL) {
+            if (src->type == LAVA_WALL) {
+                target->will_erase = true;
+            }
+
+            // Uncomment to enable ball collisions
+            // else if (src->type == PLAYER_BALL) {
+            //     src->will_erase = true;
+            //     target->will_erase = true;
+            // }
+        }
+    }
+
+    bool use_block_asset(int type) override {
+        return BasicAbstractGame::use_block_asset(type) || (type == LAVA_WALL) || (type == DOOR) || (type == DOOR_OPEN);
+    }
+
+    void add_room(QRectF room) {
+        float rw = room.width();
+        float rh = room.height();
+
+        if ((rw >= min_dim || rh >= min_dim) && (rw >= hard_min_dim) && (rh >= hard_min_dim)) {
+            rooms.push_back(room);
+        }
+    }
+
+    void split_room(QRectF room, float thickness) {
+        bool will_split_width = rand_gen.rand01() < .5;
+        bool choice2 = rand_gen.rand01() < .5;
+
+        if (room.width() < min_dim)
+            will_split_width = false;
+        if (room.height() < min_dim)
+            will_split_width = true;
+
+        float rx = room.x();
+        float ry = room.y();
+        float rw = room.width();
+        float rh = room.height();
+
+        float gap = .25 * (rand_gen.randn(3) + 1);
+        float pct = 1 - gap;
+
+        if (!will_split_width) {
+            float wy, wh, remy;
+
+            if (choice2) {
+                wy = ry;
+                remy = ry + pct * rh;
+                wh = pct * rh;
+            } else {
+                wy = ry + (1 - pct) * rh;
+                remy = ry;
+                wh = pct * rh;
+            }
+
+            add_entity_rxy(rx + rw / 2, wy + wh / 2, 0, 0, thickness, wh / 2, LAVA_WALL);
+
+            float nextw = rw / 2 - thickness;
+
+            add_room(QRectF(rx, wy, nextw, wh));
+            add_room(QRectF(rx + rw / 2 + thickness, wy, nextw, wh));
+            add_room(QRectF(rx, remy, rw, rh - wh));
+        } else {
+            float wx, ww, remx;
+
+            if (choice2) {
+                wx = rx;
+                remx = rx + pct * rw;
+                ww = pct * rw;
+            } else {
+                wx = rx + (1 - pct) * rw;
+                remx = rx;
+                ww = pct * rw;
+            }
+
+            add_entity_rxy(wx + ww / 2, ry + rh / 2, 0, 0, ww / 2, thickness, LAVA_WALL);
+
+            float nexth = rh / 2 - thickness;
+
+            add_room(QRectF(wx, ry, ww, nexth));
+            add_room(QRectF(wx, ry + rh / 2 + thickness, ww, nexth));
+            add_room(QRectF(remx, ry, rw - ww, rh));
+        }
+    }
+
+    void choose_vel(const std::shared_ptr<Entity> &ent) {
+        float vel = ENEMY_VEL * (rand_gen.randn(2) * 2 - 1);
+
+        if (rand_gen.randn(2) == 0) {
+            ent->vx = vel;
+            ent->vy = 0;
+        } else {
+            ent->vy = vel;
+            ent->vx = 0;
+        }
+
+        ent->spawn_time = rand_gen.randn(50) + 25;
+    }
+
+    float get_tile_aspect_ratio(const std::shared_ptr<Entity> &ent) override {
+        if (ent->type == LAVA_WALL) {
+            return ent->rx > ent->ry ? 1 : -1;
+        }
+
+        return 0;
+    }
+
+    void choose_world_dim() override {
+        int world_dim = 20;
+
+        if (options.distribution_mode == MemoryMode) {
+            world_dim = 40;
+        }
+
+        main_width = world_dim;
+        main_height = world_dim;
+    }
+
+    void game_reset() override {
+        BasicAbstractGame::game_reset();
+
+        options.center_agent = options.distribution_mode == MemoryMode;
+
+        last_fire_time = 0;
+
+        rooms.clear();
+        rooms.push_back(QRectF(0, 0, main_width, main_height));
+
+        int distribution_mode = options.distribution_mode;
+
+        float thickness = 0.3f;
+        float enemy_r = .5;
+        float exit_r = .75;
+        ball_r = .25;
+        ball_vscale = .25;
+        int num_iterations;
+        int max_extra_enemies = 3;
+
+        if (distribution_mode == EasyMode) {
+            num_iterations = 2;
+            thickness *= 2;
+            enemy_r *= 2;
+            ball_r *= 2;
+            ball_vscale *= 2;
+            maxspeed = .75;
+            agent->rx = 1;
+            agent->ry = 1;
+            exit_r *= 2;
+        } else if (distribution_mode == HardMode) {
+            num_iterations = 4;
+            thickness *= 1.5;
+            enemy_r *= 1.5;
+            ball_r *= 1.5;
+            ball_vscale *= 1.5;
+            maxspeed = .5;
+            agent->rx = .75;
+            agent->ry = .75;
+        } else if (distribution_mode == ExtremeMode) {
+            num_iterations = 8;
+            maxspeed = .25;
+        } else if (distribution_mode == MemoryMode) {
+            num_iterations = 16;
+            thickness *= 1.5;
+            enemy_r *= 1.5;
+            ball_r *= 1.5;
+            ball_vscale *= 1.5;
+            maxspeed = .5;
+            agent->rx = .75;
+            agent->ry = .75;
+            max_extra_enemies = 16;
+        } else {
+            fassert(false);
+        }
+
+        hard_min_dim = 4 * agent->rx + 2 * thickness + .5;
+        min_dim = agent->rx * 8 + .5;
+
+        for (int iteration = 0; iteration < num_iterations; iteration++) {
+            if (rooms.size() == 0)
+                break;
+
+            int idx = rand_gen.randn((int)(rooms.size()));
+            QRectF room = rooms[idx];
+            rooms.erase(rooms.begin() + idx);
+
+            split_room(room, thickness);
+        }
+
+        float border_r = 0;
+
+        float doorlen = 2 * exit_r;
+
+        int exit_wall_choice = rand_gen.randn(4);
+
+        if (exit_wall_choice == 0) {
+            spawn_entity_rxy(doorlen / 2, exit_r, DOOR, 2 * border_r, 2 * border_r, main_width - 4 * border_r, 2 * exit_r);
+        } else if (exit_wall_choice == 1) {
+            spawn_entity_rxy(doorlen / 2, exit_r, DOOR, 2 * border_r, main_height - 2 * border_r - 2 * exit_r, main_width - 4 * border_r, 2 * exit_r);
+        } else if (exit_wall_choice == 2) {
+            spawn_entity_rxy(exit_r, doorlen / 2, DOOR, 2 * border_r, 2 * border_r, 2 * exit_r, main_height - 4 * border_r);
+        } else if (exit_wall_choice == 3) {
+            spawn_entity_rxy(exit_r, doorlen / 2, DOOR, main_width - 2 * border_r - 2 * exit_r, 2 * border_r, 2 * exit_r, main_height - 4 * border_r);
+        }
+
+        reposition_agent();
+
+        num_enemies = rand_gen.randn(max_extra_enemies + 1) + 3;
+
+        spawn_entities(num_enemies, enemy_r, ENEMY, 0, 0, main_width, main_height);
+
+        int enemy_theme = rand_gen.randn(NUM_ENEMY_THEMES);
+
+        for (auto ent : entities) {
+            if (ent->type == ENEMY) {
+                ent->image_theme = enemy_theme;
+                ent->health = 1;
+                ent->spawn_time = 0;
+                ent->fire_time = 10;
+                ent->collides_with_entities = true;
+                ent->smart_step = true;
+                choose_vel(ent);
+                ent->face_direction(ent->vx, ent->vy);
+            } else if (ent->type == LAVA_WALL) {
+                ent->collides_with_entities = true;
+            }
+        }
+
+        agent->face_direction(1, 0);
+    }
+
+    void fire_ball(const std::shared_ptr<Entity> &ent, float vx, float vy) {
+        auto new_ball = add_entity(ent->x, ent->y, vx * ball_vscale, vy * ball_vscale, ball_r, ENEMY_BALL);
+        ent->fire_time = cur_time + rand_gen.randn(4);
+        new_ball->vrot = BALL_V_ROT;
+        new_ball->expire_time = 50;
+    }
+
+    void game_step() override {
+        BasicAbstractGame::game_step();
+
+        float vx = last_move_action / 3 - 1;
+        float vy = last_move_action % 3 - 1;
+
+        agent->face_direction(vx, vy);
+
+        if (special_action == 1 && (cur_time - last_fire_time) >= 7) {
+            auto new_ball = add_entity(agent->x, agent->y, vx * ball_vscale, vy * ball_vscale, ball_r, PLAYER_BALL);
+            new_ball->collides_with_entities = true;
+            new_ball->expire_time = 50;
+            new_ball->vrot = BALL_V_ROT;
+            last_fire_time = cur_time;
+        }
+
+        num_enemies = 0;
+
+        for (int i = (int)(entities.size()) - 1; i >= 0; i--) {
+            auto ent = entities[i];
+
+            if (ent->type == ENEMY) {
+                num_enemies++;
+
+                if (ent->spawn_time == 0) {
+                    choose_vel(ent);
+                } else {
+                    ent->spawn_time -= 1;
+                }
+
+                bool can_fire = (cur_time - ent->fire_time) >= enemy_fire_delay;
+
+                if (can_fire) {
+                    float dx = ent->x - agent->x;
+                    float dy = ent->y - agent->y;
+
+                    float bvelx = (ent->x < agent->x ? 1 : -1);
+                    float bvely = (ent->y < agent->y ? 1 : -1);
+
+                    if (fabs(dx) < 1) {
+                        fire_ball(ent, 0, bvely);
+                        ent->vx = 0;
+                        ent->vy = bvely * ENEMY_VEL;
+                    } else if (fabs(dy) < 1) {
+                        fire_ball(ent, bvelx, 0);
+                        ent->vx = bvelx * ENEMY_VEL;
+                        ent->vy = 0;
+                    }
+
+                    // Uncomment to enable diagonal firing
+                    // else if (fabs(fabs(dx) - fabs(dy)) < 1) {
+                    //     fire_ball(ent, bvelx, bvely);
+                    // }
+                }
+
+                ent->face_direction(ent->vx, ent->vy);
+            } else if (ent->type == PLAYER_BALL || ent->type == ENEMY_BALL) {
+                if (ent->x < ent->rx || ent->x > (main_width - ent->rx)) {
+                    ent->will_erase = true;
+                } else if (ent->y < ent->ry || ent->y > (main_height - ent->ry)) {
+                    ent->will_erase = true;
+                }
+            }
+        }
+
+        erase_if_needed();
+    }
+
+    void serialize(WriteBuffer *b) override {
+        BasicAbstractGame::serialize(b);
+        b->write_float(min_dim);
+        b->write_float(hard_min_dim);
+        b->write_float(ball_vscale);
+        b->write_float(ball_r);
+        b->write_int(last_fire_time);
+        b->write_int(num_enemies);
+        b->write_int(enemy_fire_delay);
+    }
+
+    void deserialize(ReadBuffer *b) override {
+        BasicAbstractGame::deserialize(b);
+        min_dim = b->read_float();
+        hard_min_dim = b->read_float();
+        ball_vscale = b->read_float();
+        ball_r = b->read_float();
+        last_fire_time = b->read_int();
+        num_enemies = b->read_int();
+        enemy_fire_delay = b->read_int();
+    }
+};
+
+REGISTER_GAME(NAME, DodgeballGame);
diff --git a/procgenAISC/procgen/src/games/fruitbot.cpp b/procgenAISC/procgen/src/games/fruitbot.cpp
new file mode 100644
index 0000000..c6b5acd
--- /dev/null
+++ b/procgenAISC/procgen/src/games/fruitbot.cpp
@@ -0,0 +1,280 @@
+#include "../basic-abstract-game.h"
+#include "../assetgen.h"
+#include <set>
+#include <queue>
+
+const std::string NAME = "fruitbot";
+
+const float COMPLETION_BONUS = 10.0;
+const int POSITIVE_REWARD = 1.0f;
+const int PENALTY = -4.0f;
+
+const int BARRIER = 1;
+const int OUT_OF_BOUNDS_WALL = 2;
+const int PLAYER_BULLET = 3;
+const int BAD_OBJ = 4;
+const int GOOD_OBJ = 7;
+const int LOCKED_DOOR = 10;
+const int LOCK = 11;
+const int PRESENT = 12;
+
+const int KEY_DURATION = 8;
+
+const float DOOR_ASPECT_RATIO = 3.25;
+
+class FruitBotGame : public BasicAbstractGame {
+  public:
+    float min_dim = 0.0f;
+    float bullet_vscale = 0.0f;
+    int last_fire_time = 0;
+
+    FruitBotGame()
+        : BasicAbstractGame(NAME) {
+        mixrate = .5;
+        maxspeed = 0.85f;
+
+        min_dim = 5;
+        bullet_vscale = .5;
+        bg_tile_ratio = -1;
+
+        out_of_bounds_object = OUT_OF_BOUNDS_WALL;
+    }
+
+    void load_background_images() override {
+        main_bg_images_ptr = &topdown_backgrounds;
+    }
+
+    void asset_for_type(int type, std::vector<std::string> &names) override {
+        if (type == PLAYER) {
+            names.push_back("misc_assets/robot_3Dblue.png");
+        } else if (type == BARRIER || type == OUT_OF_BOUNDS_WALL) {
+            names.push_back("misc_assets/tileStone_slope.png");
+        } else if (type == PLAYER_BULLET) {
+            names.push_back("misc_assets/keyRed2.png");
+        } else if (type == BAD_OBJ) {
+            names.push_back("misc_assets/food1.png");
+            names.push_back("misc_assets/food2.png");
+            names.push_back("misc_assets/food3.png");
+            names.push_back("misc_assets/food4.png");
+            names.push_back("misc_assets/food5.png");
+            names.push_back("misc_assets/food6.png");
+        } else if (type == GOOD_OBJ) {
+            names.push_back("misc_assets/fruit1.png");
+            names.push_back("misc_assets/fruit2.png");
+            names.push_back("misc_assets/fruit3.png");
+            names.push_back("misc_assets/fruit4.png");
+            names.push_back("misc_assets/fruit5.png");
+            names.push_back("misc_assets/fruit6.png");
+        } else if (type == LOCKED_DOOR) {
+            names.push_back("misc_assets/fenceYellow.png");
+        } else if (type == LOCK) {
+            names.push_back("misc_assets/lockRed2.png");
+        } else if (type == PRESENT) {
+            names.push_back("misc_assets/present1.png");
+            names.push_back("misc_assets/present2.png");
+            names.push_back("misc_assets/present3.png");
+        }
+    }
+
+    bool will_reflect(int src, int target) override {
+        return BasicAbstractGame::will_reflect(src, target) || (src == BAD_OBJ && (target == BARRIER || target == WALL_OBJ));
+    }
+
+    bool is_blocked(const std::shared_ptr<Entity> &src, int target, bool is_horizontal) override {
+        return BasicAbstractGame::is_blocked(src, target, is_horizontal) || (src->type == PLAYER && target == OUT_OF_BOUNDS_WALL);
+    }
+
+    float get_tile_aspect_ratio(const std::shared_ptr<Entity> &ent) override {
+        if (ent->type == BARRIER)
+            return 1;
+        if (ent->type == LOCKED_DOOR)
+            return DOOR_ASPECT_RATIO;
+
+        return 0;
+    }
+
+    void handle_agent_collision(const std::shared_ptr<Entity> &obj) override {
+        BasicAbstractGame::handle_agent_collision(obj);
+
+        if (obj->type == BARRIER) {
+            step_data.done = true;
+        } else if (obj->type == BAD_OBJ) {
+            step_data.reward += PENALTY;
+            obj->will_erase = true;
+        } else if (obj->type == LOCKED_DOOR) {
+            step_data.done = true;
+        } else if (obj->type == GOOD_OBJ) {
+            step_data.reward += POSITIVE_REWARD;
+            obj->will_erase = true;
+        } else if (obj->type == PRESENT) {
+            if (!step_data.done) {
+            }
+            step_data.reward += COMPLETION_BONUS;
+            step_data.done = true;
+            step_data.level_complete = true;
+        }
+    }
+
+    void handle_collision(const std::shared_ptr<Entity> &src, const std::shared_ptr<Entity> &target) override {
+        if (src->type == PLAYER_BULLET) {
+            if (target->type == BARRIER) {
+                src->will_erase = true;
+            } else if (target->type == LOCK) {
+                src->will_erase = true;
+                target->will_erase = true;
+
+                // find and erase the corresponding door entity
+                for (auto ent : entities) {
+                    if (ent->type == LOCKED_DOOR && fabs(ent->y - target->y) < 1) {
+                        ent->will_erase = true;
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    bool use_block_asset(int type) override {
+        return BasicAbstractGame::use_block_asset(type) || (type == BARRIER) || (type == LOCKED_DOOR) || (type == PRESENT);
+    }
+
+    void choose_center(float &cx, float &cy) override {
+        cx = main_width / 2.0;
+        cy = agent->y + main_width / 2.0 - 2 * agent->ry;
+        visibility = main_width;
+    }
+
+    void choose_world_dim() override {
+        if (options.distribution_mode == EasyMode) {
+            main_width = 10;
+        } else {
+            main_width = 20;
+        }
+
+        main_height = 60;
+    }
+
+    void set_action_xy(int move_action) override {
+        action_vx = move_action / 3 - 1;
+        action_vy = 0.2f; //(move_action % 3) * .2;
+        action_vrot = 0;
+    }
+
+    void add_walls(float ry, bool use_door, float min_pct) {
+        float rw = main_width;
+        float wall_ry = 0.3f;
+        float lock_rx = .25;
+        float lock_ry = 0.45f;
+
+        float pct = min_pct + .2 * rand_gen.rand01();
+
+        if (use_door) {
+            pct += 0.1f;
+            float lock_pct_w = 2 * lock_rx / main_width;
+            float door_pct_w = (wall_ry * 2 * DOOR_ASPECT_RATIO) / main_width;
+            int num_doors = ceil((pct - 2 * lock_pct_w) / door_pct_w);
+            pct = 2 * lock_pct_w + door_pct_w * num_doors;
+        }
+
+        float gapw = pct * rw;
+
+        float w1 = rand_gen.rand01() * (rw - gapw);
+        float w2 = rw - w1 - gapw;
+
+        add_entity_rxy(w1 / 2, ry, 0, 0, w1 / 2, wall_ry, BARRIER);
+        add_entity_rxy(rw - w2 / 2, ry, 0, 0, w2 / 2, wall_ry, BARRIER);
+
+        if (use_door) {
+            int is_on_right = rand_gen.randn(2);
+            float lock_x = w1 + lock_rx + is_on_right * (gapw - 2 * lock_rx);
+            float door_x = w1 + gapw / 2 - (is_on_right * 2 - 1) * lock_rx;
+
+            add_entity_rxy(door_x, ry, 0, 0, gapw / 2 - lock_rx, wall_ry, LOCKED_DOOR);
+            add_entity_rxy(lock_x, ry - lock_ry + wall_ry, 0, 0, lock_rx, lock_ry, LOCK);
+        }
+    }
+
+    void game_reset() override {
+        BasicAbstractGame::game_reset();
+
+        last_fire_time = 0;
+
+        int min_sep = 4;
+        int num_walls = 10;
+        int object_group_size = 6;
+        int buf_h = 4;
+        float door_prob = .125;
+        float min_pct = .1;
+
+        if (options.distribution_mode == EasyMode) {
+            num_walls = 5;
+            object_group_size = 2;
+            door_prob = 0;
+            min_pct = .2;
+        }
+
+        std::vector<int> partition = rand_gen.partition(main_height - min_sep * num_walls - buf_h, num_walls);
+
+        int curr_h = 0;
+
+        for (int part : partition) {
+            int dy = min_sep + part;
+            curr_h += dy;
+
+            bool use_door = (dy > 5) && rand_gen.rand01() < door_prob;
+
+            add_walls(curr_h, use_door, min_pct);
+        }
+
+        agent->y = agent->ry;
+
+        int num_good = rand_gen.randn(10) + 10;
+        int num_bad = rand_gen.randn(10) + 10;
+
+        for (int i = 0; i < main_width; i++) {
+            auto present = add_entity_rxy(i + .5, main_height - .5, 0, 0, .5, .5, PRESENT);
+            choose_random_theme(present);
+        }
+
+        spawn_entities(num_good, .5, GOOD_OBJ, 0, 0, main_width, main_height);
+        spawn_entities(num_bad, .5, BAD_OBJ, 0, 0, main_width, main_height);
+
+        for (auto ent : entities) {
+            if (ent->type == GOOD_OBJ || ent->type == BAD_OBJ) {
+                ent->image_theme = rand_gen.randn(object_group_size);
+                fit_aspect_ratio(ent);
+            }
+        }
+
+        agent->rotation = -1 * PI / 2;
+    }
+
+    void game_step() override {
+        BasicAbstractGame::game_step();
+
+        if (special_action == 1 && (cur_time - last_fire_time) >= KEY_DURATION) {
+            float vx = 0;
+            float vy = 1;
+            auto new_bullet = add_entity(agent->x, agent->y, vx * bullet_vscale, vy * bullet_vscale, .25, PLAYER_BULLET);
+            new_bullet->expire_time = KEY_DURATION;
+            new_bullet->collides_with_entities = true;
+            last_fire_time = cur_time;
+        }
+    }
+
+    void serialize(WriteBuffer *b) override {
+        BasicAbstractGame::serialize(b);
+        b->write_float(min_dim);
+        b->write_float(bullet_vscale);
+        b->write_int(last_fire_time);
+    }
+
+    void deserialize(ReadBuffer *b) override {
+        BasicAbstractGame::deserialize(b);
+        min_dim = b->read_float();
+        bullet_vscale = b->read_float();
+        last_fire_time = b->read_int();
+    }
+};
+
+REGISTER_GAME(NAME, FruitBotGame);
diff --git a/procgenAISC/procgen/src/games/heist.cpp b/procgenAISC/procgen/src/games/heist.cpp
new file mode 100644
index 0000000..772411d
--- /dev/null
+++ b/procgenAISC/procgen/src/games/heist.cpp
@@ -0,0 +1,226 @@
+#include "../basic-abstract-game.h"
+#include "../assetgen.h"
+#include <set>
+#include <queue>
+#include "../mazegen.h"
+#include "../cpp-utils.h"
+
+const std::string NAME = "heist";
+
+const float COMPLETION_BONUS = 10.0f;
+
+const int LOCKED_DOOR = 1;
+const int KEY = 2;
+const int EXIT = 9;
+const int KEY_ON_RING = 11;
+
+class HeistGame : public BasicAbstractGame {
+  public:
+    std::shared_ptr<MazeGen> maze_gen;
+    int world_dim = 0;
+    int num_keys = 0;
+    std::vector<bool> has_keys;
+
+    HeistGame()
+        : BasicAbstractGame(NAME) {
+        maze_gen = nullptr;
+        has_useful_vel_info = false;
+
+        main_width = 20;
+        main_height = 20;
+
+        out_of_bounds_object = WALL_OBJ;
+        visibility = 8.0;
+    }
+
+    void load_background_images() override {
+        main_bg_images_ptr = &topdown_backgrounds;
+    }
+
+    bool should_preserve_type_themes(int type) override {
+        return type == KEY || type == LOCKED_DOOR;
+    }
+
+    void asset_for_type(int type, std::vector<std::string> &names) override {
+        if (type == WALL_OBJ) {
+            names.push_back("kenney/Ground/Dirt/dirtCenter.png");
+        } else if (type == EXIT) {
+            names.push_back("misc_assets/gemYellow.png");
+        } else if (type == PLAYER) {
+            names.push_back("misc_assets/spaceAstronauts_008.png");
+        } else if (type == KEY) {
+            names.push_back("misc_assets/keyBlue.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyRed.png");
+        } else if (type == LOCKED_DOOR) {
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_green.png");
+            names.push_back("misc_assets/lock_red.png");
+        }
+    }
+
+    bool use_block_asset(int type) override {
+        return BasicAbstractGame::use_block_asset(type) || (type == WALL_OBJ) || (type == LOCKED_DOOR);
+    }
+
+    bool is_blocked_ents(const std::shared_ptr<Entity> &src, const std::shared_ptr<Entity> &target, bool is_horizontal) override {
+        if (target->type == LOCKED_DOOR)
+            return !has_keys[target->image_theme];
+
+        return BasicAbstractGame::is_blocked_ents(src, target, is_horizontal);
+    }
+
+    bool should_draw_entity(const std::shared_ptr<Entity> &entity) override {
+        if (entity->type == KEY_ON_RING)
+            return has_keys[entity->image_theme];
+
+        return BasicAbstractGame::should_draw_entity(entity);
+    }
+
+    void handle_agent_collision(const std::shared_ptr<Entity> &obj) override {
+        BasicAbstractGame::handle_agent_collision(obj);
+
+        if (obj->type == EXIT) {
+            step_data.done = true;
+            step_data.reward = COMPLETION_BONUS;
+            step_data.level_complete = true;
+        } else if (obj->type == KEY) {
+            obj->will_erase = true;
+            has_keys[obj->image_theme] = true;
+        } else if (obj->type == LOCKED_DOOR) {
+            int door_num = obj->image_theme;
+            if (has_keys[door_num]) {
+                obj->will_erase = true;
+            }
+        }
+    }
+
+    void choose_world_dim() override {
+        int dist_diff = options.distribution_mode;
+
+        if (dist_diff == EasyMode) {
+            world_dim = 9;
+        } else if (dist_diff == HardMode) {
+            world_dim = 13;
+        } else if (dist_diff == MemoryMode) {
+            world_dim = 23;
+        }
+
+        maxspeed = .75;
+
+        main_width = world_dim;
+        main_height = world_dim;
+    }
+
+    void game_reset() override {
+        BasicAbstractGame::game_reset();
+
+        int min_maze_dim = 5;
+        int max_diff = (world_dim - min_maze_dim) / 2;
+        int difficulty = rand_gen.randn(max_diff + 1);
+
+        options.center_agent = options.distribution_mode == MemoryMode;
+
+        if (options.distribution_mode == MemoryMode) {
+            num_keys = rand_gen.randn(4);
+        } else {
+            num_keys = difficulty + rand_gen.randn(2);
+        }
+
+        if (num_keys > 3)
+            num_keys = 3;
+
+        has_keys.clear();
+
+        for (int i = 0; i < num_keys; i++) {
+            has_keys.push_back(false);
+        }
+
+        int maze_dim = difficulty * 2 + min_maze_dim;
+        float maze_scale = main_height / (world_dim * 1.0);
+
+        agent->rx = .375 * maze_scale;
+        agent->ry = .375 * maze_scale;
+
+        float r_ent = maze_scale / 2;
+
+        maze_gen = std::make_shared<MazeGen>(&rand_gen, maze_dim);
+        maze_gen->generate_maze_with_doors(num_keys);
+
+        // move agent out of the way for maze generation
+        agent->x = -1;
+        agent->y = -1;
+
+        int off_x = rand_gen.randn(world_dim - maze_dim + 1);
+        int off_y = rand_gen.randn(world_dim - maze_dim + 1);
+
+        for (int i = 0; i < grid_size; i++) {
+            set_obj(i, WALL_OBJ);
+        }
+
+        for (int i = 0; i < maze_dim; i++) {
+            for (int j = 0; j < maze_dim; j++) {
+                int x = off_x + i;
+                int y = off_y + j;
+
+                int obj = maze_gen->grid.get(i + MAZE_OFFSET, j + MAZE_OFFSET);
+
+                float obj_x = (x + .5) * maze_scale;
+                float obj_y = (y + .5) * maze_scale;
+
+                if (obj != WALL_OBJ) {
+                    set_obj(x, y, SPACE);
+                }
+
+                if (obj >= KEY_OBJ) {
+                    auto ent = spawn_entity(.375 * maze_scale, KEY, maze_scale * x, maze_scale * y, maze_scale, maze_scale);
+                    ent->image_theme = obj - KEY_OBJ - 1;
+                    match_aspect_ratio(ent);
+                } else if (obj >= DOOR_OBJ) {
+                    auto ent = add_entity(obj_x, obj_y, 0, 0, r_ent, LOCKED_DOOR);
+                    ent->image_theme = obj - DOOR_OBJ - 1;
+                } else if (obj == EXIT_OBJ) {
+                    auto ent = spawn_entity(.375 * maze_scale, EXIT, maze_scale * x, maze_scale * y, maze_scale, maze_scale);
+                    match_aspect_ratio(ent);
+                } else if (obj == AGENT_OBJ) {
+                    agent->x = obj_x;
+                    agent->y = obj_y;
+                }
+            }
+        }
+
+        float ring_key_r = 0.03f;
+
+        for (int i = 0; i < num_keys; i++) {
+            auto ent = add_entity(1 - ring_key_r * (2 * i + 1.25), ring_key_r * .75, 0, 0, ring_key_r, KEY_ON_RING);
+            ent->image_theme = i;
+            ent->image_type = KEY;
+            ent->rotation = PI / 2;
+            ent->render_z = 1;
+            ent->use_abs_coords = true;
+            match_aspect_ratio(ent);
+        }
+    }
+
+    void game_step() override {
+        BasicAbstractGame::game_step();
+
+        agent->face_direction(action_vx, action_vy);
+    }
+
+    void serialize(WriteBuffer *b) override {
+        BasicAbstractGame::serialize(b);
+        b->write_int(num_keys);
+        b->write_int(world_dim);
+        b->write_vector_bool(has_keys);
+    }
+
+    void deserialize(ReadBuffer *b) override {
+        BasicAbstractGame::deserialize(b);
+        num_keys = b->read_int();
+        world_dim = b->read_int();
+        has_keys = b->read_vector_bool();
+    }
+};
+
+REGISTER_GAME(NAME, HeistGame);
diff --git a/procgenAISC/procgen/src/games/heist_aisc_many_chests.cpp b/procgenAISC/procgen/src/games/heist_aisc_many_chests.cpp
new file mode 100644
index 0000000..01f1e36
--- /dev/null
+++ b/procgenAISC/procgen/src/games/heist_aisc_many_chests.cpp
@@ -0,0 +1,296 @@
+#include "../basic-abstract-game.h"
+#include "../assetgen.h"
+#include <set>
+#include <queue>
+#include "../mazegen.h"
+#include "../cpp-utils.h"
+
+const std::string NAME = "heist_aisc_many_chests";
+
+const float COMPLETION_BONUS = 10.0f;
+
+const int LOCKED_DOOR = 1;
+const int KEY = 2;
+const int EXIT = 9;
+const int KEY_ON_RING = 11;
+
+class HeistGameAISC_ManyChests : public BasicAbstractGame {
+  public:
+    std::shared_ptr<MazeGen> maze_gen_aisc;
+    int world_dim = 0;
+    int num_keys = 0;
+    std::vector<bool> has_keys;
+    int agent_keys = 0;
+    int env_chests = 0;
+    int total_chests = 0;
+
+    HeistGameAISC_ManyChests()
+        : BasicAbstractGame(NAME) {
+        maze_gen_aisc = nullptr;
+        has_useful_vel_info = false;
+
+        main_width = 20;
+        main_height = 20;
+
+        out_of_bounds_object = WALL_OBJ;
+        visibility = 8.0;
+    }
+
+    void load_background_images() override {
+        main_bg_images_ptr = &topdown_backgrounds;
+    }
+
+    bool should_preserve_type_themes(int type) override {
+        return type == KEY || type == LOCKED_DOOR;
+    }
+
+    void asset_for_type(int type, std::vector<std::string> &names) override {
+        if (type == WALL_OBJ) {
+            names.push_back("kenney/Ground/Dirt/dirtCenter.png");
+        } else if (type == EXIT) {
+            names.push_back("misc_assets/gemYellow.png");
+        } else if (type == PLAYER) {
+            names.push_back("misc_assets/spaceAstronauts_008.png");
+        } else if (type == KEY) {
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+        } else if (type == LOCKED_DOOR) {
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+        }
+    }
+
+    bool use_block_asset(int type) override {
+        return BasicAbstractGame::use_block_asset(type) || (type == WALL_OBJ);
+    }
+
+    bool is_blocked_ents(const std::shared_ptr<Entity> &src, const std::shared_ptr<Entity> &target, bool is_horizontal) override {
+        if (target->type == LOCKED_DOOR)
+            // return !has_keys[target->image_theme];
+            return false; 
+            // agent_keys==0;
+
+        return BasicAbstractGame::is_blocked_ents(src, target, is_horizontal);
+    }
+
+    bool should_draw_entity(const std::shared_ptr<Entity> &entity) override {
+        if (entity->type == KEY_ON_RING)
+            return entity->image_theme < agent_keys;
+
+        return BasicAbstractGame::should_draw_entity(entity);
+    }
+
+    void handle_agent_collision(const std::shared_ptr<Entity> &obj) override {
+        BasicAbstractGame::handle_agent_collision(obj);
+
+        // if (obj->type == EXIT) {
+        //     step_data.done = true;
+        //     step_data.reward = COMPLETION_BONUS;
+        //     step_data.level_complete = true;
+            // comment out above
+        // } else 
+        if (obj->type == KEY) {
+            obj->will_erase = true;
+            // has_keys[obj->image_theme] = true;
+            step_data.reward -= options.key_penalty / 10.;  // small penalty for collecting key
+            agent_keys += 1;
+        } else if (obj->type == LOCKED_DOOR) {
+            if (agent_keys>0){
+                obj->will_erase = true;
+                agent_keys += -1;
+                env_chests += -1;
+                step_data.reward = 1;
+                // add reward/completion check here
+            }
+            if (env_chests==0){
+                step_data.done = true;
+                // step_data.reward = COMPLETION_BONUS;
+                step_data.level_complete = true;
+            }
+            if (total_chests-num_keys==env_chests){
+                step_data.done = true;
+                // step_data.reward = COMPLETION_BONUS;
+                step_data.level_complete = true;
+            }
+        }
+    }
+
+    void choose_world_dim() override {
+        int dist_diff = options.distribution_mode;
+
+        if (dist_diff == EasyMode) {
+            world_dim = 9;
+        } else if (dist_diff == HardMode) {
+            world_dim = 13;
+        } else if (dist_diff == MemoryMode) {
+            world_dim = 23;
+        }
+
+        maxspeed = .75;
+
+        main_width = world_dim;
+        main_height = world_dim;
+    }
+
+    void game_reset() override {
+        BasicAbstractGame::game_reset();
+
+        int min_maze_dim = 5;
+        int max_diff = (world_dim - min_maze_dim) / 2;
+        int difficulty = rand_gen.randn(max_diff + 1);
+        options.center_agent = options.distribution_mode == MemoryMode;
+
+
+        // MANY CHESTS SETTING
+        if (options.distribution_mode == MemoryMode) {
+            num_keys = rand_gen.randn(4) + 1;
+            env_chests = num_keys*2;
+
+        } else {
+            num_keys = difficulty + rand_gen.randn(2) + 1;
+            env_chests = num_keys*2;
+        }
+		agent_keys = 0;
+
+        total_chests = env_chests;
+
+        has_keys.clear();
+
+        for (int i = 0; i < num_keys; i++) {
+            has_keys.push_back(false);
+        }
+
+        int maze_dim = difficulty * 2 + min_maze_dim;
+        float maze_scale = main_height / (world_dim * 1.0);
+
+        agent->rx = .375 * maze_scale;
+        agent->ry = .375 * maze_scale;
+
+        float r_ent = maze_scale / 2;
+
+        maze_gen_aisc = std::make_shared<MazeGen>(&rand_gen, maze_dim);
+        maze_gen_aisc->generate_maze_with_doors_aisc(env_chests,num_keys);
+
+        // move agent out of the way for maze generation
+        agent->x = -1;
+        agent->y = -1;
+
+        int off_x = rand_gen.randn(world_dim - maze_dim + 1);
+        int off_y = rand_gen.randn(world_dim - maze_dim + 1);
+
+        for (int i = 0; i < grid_size; i++) {
+            set_obj(i, WALL_OBJ);
+        }
+
+        for (int i = 0; i < maze_dim; i++) {
+            for (int j = 0; j < maze_dim; j++) {
+                int x = off_x + i;
+                int y = off_y + j;
+
+                int obj = maze_gen_aisc->grid.get(i + MAZE_OFFSET, j + MAZE_OFFSET);
+
+                float obj_x = (x + .5) * maze_scale;
+                float obj_y = (y + .5) * maze_scale;
+
+                if (obj != WALL_OBJ) {
+                    set_obj(x, y, SPACE);
+                }
+                if (obj >= KEY_OBJ) {
+                    auto ent = spawn_entity(.375 * maze_scale, KEY, maze_scale * x, maze_scale * y, maze_scale, maze_scale);
+                    ent->image_theme = obj - KEY_OBJ - 1;
+                    match_aspect_ratio(ent);
+                } else if (obj >= DOOR_OBJ) {
+                    auto ent = add_entity(obj_x, obj_y, 0, 0, r_ent, LOCKED_DOOR);
+                    ent->image_theme = obj - DOOR_OBJ - 1;
+                } else if (obj == EXIT_OBJ) {
+                    auto ent = spawn_entity(.375 * maze_scale, EXIT, maze_scale * x, maze_scale * y, maze_scale, maze_scale);
+                    match_aspect_ratio(ent);
+                } else if (obj == AGENT_OBJ) {
+                    agent->x = obj_x;
+                    agent->y = obj_y;
+                }
+            }
+
+        }
+
+        float ring_key_r = 0.03f;
+
+        for (int i = 0; i < num_keys; i++) {
+            auto ent = add_entity(1 - ring_key_r * (2 * i + 1.25), ring_key_r * .75, 0, 0, ring_key_r, KEY_ON_RING);
+            ent->image_theme = i;
+            ent->image_type = KEY;
+            ent->rotation = PI / 2;
+            ent->render_z = 1;
+            ent->use_abs_coords = true;
+            match_aspect_ratio(ent);
+        }
+    }
+
+    void game_step() override {
+        BasicAbstractGame::game_step();
+
+        step_data.reward -= options.step_penalty / 1000.;  // time penalty
+        agent->face_direction(action_vx, action_vy);
+    }
+
+    void serialize(WriteBuffer *b) override {
+        BasicAbstractGame::serialize(b);
+        b->write_int(num_keys);
+        b->write_int(world_dim);
+        b->write_vector_bool(has_keys);
+    }
+
+    void deserialize(ReadBuffer *b) override {
+        BasicAbstractGame::deserialize(b);
+        num_keys = b->read_int();
+        world_dim = b->read_int();
+        has_keys = b->read_vector_bool();
+    }
+};
+
+REGISTER_GAME(NAME, HeistGameAISC_ManyChests);
diff --git a/procgenAISC/procgen/src/games/heist_aisc_many_keys.cpp b/procgenAISC/procgen/src/games/heist_aisc_many_keys.cpp
new file mode 100644
index 0000000..a7385b0
--- /dev/null
+++ b/procgenAISC/procgen/src/games/heist_aisc_many_keys.cpp
@@ -0,0 +1,293 @@
+#include "../basic-abstract-game.h"
+#include "../assetgen.h"
+#include <set>
+#include <queue>
+#include "../mazegen.h"
+#include "../cpp-utils.h"
+
+const std::string NAME = "heist_aisc_many_keys";
+
+const float COMPLETION_BONUS = 10.0f;
+
+const int LOCKED_DOOR = 1;
+const int KEY = 2;
+const int EXIT = 9;
+const int KEY_ON_RING = 11;
+
+class HeistGameAISC_ManyKeys : public BasicAbstractGame {
+  public:
+    std::shared_ptr<MazeGen> maze_gen_aisc;
+    int world_dim = 0;
+    int num_keys = 0;
+    std::vector<bool> has_keys;
+    int agent_keys = 0;
+    int env_chests = 0;
+    int total_chests = 0;
+
+    HeistGameAISC_ManyKeys()
+        : BasicAbstractGame(NAME) {
+        maze_gen_aisc = nullptr;
+        has_useful_vel_info = false;
+
+        main_width = 20;
+        main_height = 20;
+
+        out_of_bounds_object = WALL_OBJ;
+        visibility = 8.0;
+    }
+
+    void load_background_images() override {
+        main_bg_images_ptr = &topdown_backgrounds;
+    }
+
+    bool should_preserve_type_themes(int type) override {
+        return type == KEY || type == LOCKED_DOOR;
+    }
+
+    void asset_for_type(int type, std::vector<std::string> &names) override {
+        if (type == WALL_OBJ) {
+            names.push_back("kenney/Ground/Dirt/dirtCenter.png");
+        } else if (type == EXIT) {
+            names.push_back("misc_assets/gemYellow.png");
+        } else if (type == PLAYER) {
+            names.push_back("misc_assets/spaceAstronauts_008.png");
+        } else if (type == KEY) {
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+            names.push_back("misc_assets/keyGreen.png");
+        } else if (type == LOCKED_DOOR) {
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+            names.push_back("misc_assets/lock_blue.png");
+        }
+    }
+
+    bool use_block_asset(int type) override {
+        return BasicAbstractGame::use_block_asset(type) || (type == WALL_OBJ);
+    }
+
+    bool is_blocked_ents(const std::shared_ptr<Entity> &src, const std::shared_ptr<Entity> &target, bool is_horizontal) override {
+        if (target->type == LOCKED_DOOR)
+            // return !has_keys[target->image_theme];
+            return false; 
+            // agent_keys==0;
+
+        return BasicAbstractGame::is_blocked_ents(src, target, is_horizontal);
+    }
+
+    bool should_draw_entity(const std::shared_ptr<Entity> &entity) override {
+        if (entity->type == KEY_ON_RING)
+            return entity->image_theme < agent_keys;
+
+        return BasicAbstractGame::should_draw_entity(entity);
+    }
+
+    void handle_agent_collision(const std::shared_ptr<Entity> &obj) override {
+        BasicAbstractGame::handle_agent_collision(obj);
+
+        // if (obj->type == EXIT) {
+        //     step_data.done = true;
+        //     step_data.reward = COMPLETION_BONUS;
+        //     step_data.level_complete = true;
+            // comment out above
+        // } else 
+        if (obj->type == KEY) {
+            obj->will_erase = true;
+            // has_keys[obj->image_theme] = true;
+            step_data.reward -= options.key_penalty / 10.;  // small penalty for collecting key
+            agent_keys += 1;
+        } else if (obj->type == LOCKED_DOOR) {
+            if (agent_keys>0){
+                obj->will_erase = true;
+                agent_keys += -1;
+                env_chests += -1;
+                step_data.reward = 1;
+                // add reward/completion check here
+            }
+            if (env_chests==0){
+                step_data.done = true;
+                // step_data.reward = COMPLETION_BONUS;
+                step_data.level_complete = true;
+            }
+            if (total_chests-num_keys==env_chests){
+                step_data.done = true;
+                // step_data.reward = COMPLETION_BONUS;
+                step_data.level_complete = true;
+            }
+        }
+    }
+
+    void choose_world_dim() override {
+        int dist_diff = options.distribution_mode;
+
+        if (dist_diff == EasyMode) {
+            world_dim = 9;
+        } else if (dist_diff == HardMode) {
+            world_dim = 13;
+        } else if (dist_diff == MemoryMode) {
+            world_dim = 23;
+        }
+
+        maxspeed = .75;
+
+        main_width = world_dim;
+        main_height = world_dim;
+    }
+
+    void game_reset() override {
+        BasicAbstractGame::game_reset();
+
+        int min_maze_dim = 5;
+        int max_diff = (world_dim - min_maze_dim) / 2;
+        int difficulty = rand_gen.randn(max_diff + 1);
+        options.center_agent = options.distribution_mode == MemoryMode;
+
+        if (options.distribution_mode == MemoryMode) {
+            env_chests = rand_gen.randn(4) + 1;
+            num_keys = env_chests*2;
+        } else {
+            env_chests = difficulty + rand_gen.randn(2) + 1;
+            num_keys = env_chests*2;
+        }
+
+		agent_keys = 0;
+        total_chests = env_chests;
+
+        has_keys.clear();
+
+        for (int i = 0; i < num_keys; i++) {
+            has_keys.push_back(false);
+        }
+
+        int maze_dim = difficulty * 2 + min_maze_dim;
+        float maze_scale = main_height / (world_dim * 1.0);
+
+        agent->rx = .375 * maze_scale;
+        agent->ry = .375 * maze_scale;
+
+        float r_ent = maze_scale / 2;
+
+        maze_gen_aisc = std::make_shared<MazeGen>(&rand_gen, maze_dim);
+        maze_gen_aisc->generate_maze_with_doors_aisc(env_chests,num_keys);
+
+        // move agent out of the way for maze generation
+        agent->x = -1;
+        agent->y = -1;
+
+        int off_x = rand_gen.randn(world_dim - maze_dim + 1);
+        int off_y = rand_gen.randn(world_dim - maze_dim + 1);
+
+        for (int i = 0; i < grid_size; i++) {
+            set_obj(i, WALL_OBJ);
+        }
+
+        for (int i = 0; i < maze_dim; i++) {
+            for (int j = 0; j < maze_dim; j++) {
+                int x = off_x + i;
+                int y = off_y + j;
+
+                int obj = maze_gen_aisc->grid.get(i + MAZE_OFFSET, j + MAZE_OFFSET);
+
+                float obj_x = (x + .5) * maze_scale;
+                float obj_y = (y + .5) * maze_scale;
+
+                if (obj != WALL_OBJ) {
+                    set_obj(x, y, SPACE);
+                }
+                if (obj >= KEY_OBJ) {
+                    auto ent = spawn_entity(.375 * maze_scale, KEY, maze_scale * x, maze_scale * y, maze_scale, maze_scale);
+                    ent->image_theme = obj - KEY_OBJ - 1;
+                    match_aspect_ratio(ent);
+                } else if (obj >= DOOR_OBJ) {
+                    auto ent = add_entity(obj_x, obj_y, 0, 0, r_ent, LOCKED_DOOR);
+                    ent->image_theme = obj - DOOR_OBJ - 1;
+                } else if (obj == EXIT_OBJ) {
+                    auto ent = spawn_entity(.375 * maze_scale, EXIT, maze_scale * x, maze_scale * y, maze_scale, maze_scale);
+                    match_aspect_ratio(ent);
+                } else if (obj == AGENT_OBJ) {
+                    agent->x = obj_x;
+                    agent->y = obj_y;
+                }
+            }
+
+        }
+
+        float ring_key_r = 0.03f;
+
+        for (int i = 0; i < num_keys; i++) {
+            auto ent = add_entity(1 - ring_key_r * (2 * i + 1.25), ring_key_r * .75, 0, 0, ring_key_r, KEY_ON_RING);
+            ent->image_theme = i;
+            ent->image_type = KEY;
+            ent->rotation = PI / 2;
+            ent->render_z = 1;
+            ent->use_abs_coords = true;
+            match_aspect_ratio(ent);
+        }
+    }
+
+    void game_step() override {
+        BasicAbstractGame::game_step();
+
+        step_data.reward -= options.step_penalty / 1000.;  // time penalty
+        agent->face_direction(action_vx, action_vy);
+    }
+
+    void serialize(WriteBuffer *b) override {
+        BasicAbstractGame::serialize(b);
+        b->write_int(num_keys);
+        b->write_int(world_dim);
+        b->write_vector_bool(has_keys);
+    }
+
+    void deserialize(ReadBuffer *b) override {
+        BasicAbstractGame::deserialize(b);
+        num_keys = b->read_int();
+        world_dim = b->read_int();
+        has_keys = b->read_vector_bool();
+    }
+};
+
+REGISTER_GAME(NAME, HeistGameAISC_ManyKeys);
diff --git a/procgenAISC/procgen/src/games/jumper.cpp b/procgenAISC/procgen/src/games/jumper.cpp
new file mode 100644
index 0000000..7628065
--- /dev/null
+++ b/procgenAISC/procgen/src/games/jumper.cpp
@@ -0,0 +1,471 @@
+#include "../basic-abstract-game.h"
+#include "../assetgen.h"
+#include "../roomgen.h"
+#include "../mazegen.h"
+#include <set>
+#include <queue>
+#include <memory>
+
+const std::string NAME = "jumper";
+
+const float GOAL_REWARD = 10.0f;
+
+const int GOAL = 1;
+const int SPIKE = 2;
+const int CAVEWALL = 6;
+const int CAVEWALL_TOP = 7;
+
+const int PLAYER_JUMP = 9;
+const int PLAYER_LEFT1 = 10;
+const int PLAYER_LEFT2 = 11;
+const int PLAYER_RIGHT1 = 12;
+const int PLAYER_RIGHT2 = 13;
+
+const int MAZE_SCALE = 3;
+
+const int JUMP_COOLDOWN = 3;
+const int NUM_WALL_THEMES = 4;
+
+class Jumper : public BasicAbstractGame {
+  public:
+    std::shared_ptr<Entity> goal;
+    int jump_count = 0;
+    int jump_delta = 0;
+    int jump_time = 0;
+    bool has_support = false;
+    bool facing_right = false;
+    int wall_theme = 0;
+    float compass_dim = 0.0f;
+    std::unique_ptr<RoomGenerator> room_manager;
+
+    Jumper()
+        : BasicAbstractGame(NAME) {
+        room_manager = std::make_unique<RoomGenerator>(this);
+    }
+
+    void load_background_images() override {
+        main_bg_images_ptr = &platform_backgrounds;
+    }
+
+    void asset_for_type(int type, std::vector<std::string> &names) override {
+        if (type == PLAYER) {
+            names.push_back("misc_assets/bunny2_ready.png");
+        } else if (type == SPIKE) {
+            names.push_back("misc_assets/spikeMan_stand.png");
+        } else if (type == GOAL) {
+            names.push_back("misc_assets/carrot.png");
+        } else if (type == PLAYER_JUMP) {
+            names.push_back("misc_assets/bunny2_jump.png");
+        } else if (type == PLAYER_RIGHT1) {
+            names.push_back("misc_assets/bunny2_walk1.png");
+        } else if (type == PLAYER_RIGHT2) {
+            names.push_back("misc_assets/bunny2_walk2.png");
+        } else if (type == PLAYER_LEFT1) {
+            names.push_back("misc_assets/bunny2_walk1.png");
+        } else if (type == PLAYER_LEFT2) {
+            names.push_back("misc_assets/bunny2_walk2.png");
+        } else if (type == CAVEWALL_TOP) {
+            names.push_back("platformer/tileBlue_05.png");
+            names.push_back("platformer/tileGreen_05.png");
+            names.push_back("platformer/tileYellow_06.png");
+            names.push_back("platformer/tileBrown_06.png");
+        } else if (type == CAVEWALL) {
+            names.push_back("platformer/tileBlue_08.png");
+            names.push_back("platformer/tileGreen_08.png");
+            names.push_back("platformer/tileYellow_09.png");
+            names.push_back("platformer/tileBrown_09.png");
+        }
+    }
+
+    void handle_agent_collision(const std::shared_ptr<Entity> &obj) override {
+        BasicAbstractGame::handle_agent_collision(obj);
+
+        if (obj->type == GOAL) {
+            step_data.reward += GOAL_REWARD;
+            step_data.level_complete = true;
+            step_data.done = true;
+        } else if (obj->type == SPIKE) {
+            step_data.done = true;
+        }
+    }
+
+    void update_agent_velocity() override {
+        float v_scale = get_agent_acceleration_scale();
+
+        agent->vx = (1 - mixrate) * agent->vx + mixrate * maxspeed * action_vx * v_scale;
+        if (action_vy != 0)
+            agent->vy = maxspeed * action_vy * 2;
+    }
+
+    int theme_for_grid_obj(int type) override {
+        if (is_wall(type))
+            return wall_theme;
+
+        return 0;
+    }
+
+    bool use_block_asset(int type) override {
+        return BasicAbstractGame::use_block_asset(type) || is_wall(type);
+    }
+
+    bool is_blocked(const std::shared_ptr<Entity> &src, int target, bool is_horizontal) override {
+        if (BasicAbstractGame::is_blocked(src, target, is_horizontal))
+            return true;
+        if (src->type == PLAYER && is_wall(target))
+            return true;
+
+        return false;
+    }
+
+    int image_for_type(int type) override {
+        if (type == PLAYER) {
+            // if (jump_delta < 0) {
+            //     return PLAYER_JUMP;
+            // } else
+            if (fabs(agent->vx) < .01 && action_vx == 0 && has_support) {
+                return PLAYER;
+            } else if (facing_right) {
+                return (cur_time / 5 % 2 == 0 || !has_support) ? PLAYER_RIGHT1 : PLAYER_RIGHT2;
+            } else {
+                return (cur_time / 5 % 2 == 0 || !has_support) ? PLAYER_LEFT1 : PLAYER_LEFT2;
+            }
+        }
+
+        return BasicAbstractGame::image_for_type(type);
+    }
+
+    void draw_compass(QPainter &p, const QRect &rect) {
+        QRectF compass_rect = get_abs_rect(view_dim - compass_dim - .25, .25, compass_dim, compass_dim);
+        QColor clock_color = QColor(168, 166, 158);
+
+        set_pen_brush_color(p, clock_color);
+        p.drawEllipse(compass_rect);
+        QColor highlight_color = QColor(252, 186, 3);
+
+        float pen_thickness = rect.width() / (256.0 / compass_dim);
+
+        set_pen_brush_color(p, highlight_color, pen_thickness);
+        float cx = compass_rect.center().x();
+        float cy = compass_rect.center().y();
+        float cr = compass_rect.width() / 2 * .95;
+        float theta = get_theta(agent, goal);
+
+        p.drawLine(cx, cy, cx + cr * cos(theta), cy - cr * sin(theta));
+
+        float dist = get_distance(agent, goal);
+        float dist_pct = dist / (main_width * sqrt(2));
+
+        float bar_thickness = compass_dim / 8;
+
+        QRectF dist_rect = get_abs_rect(view_dim - compass_dim - .25, .25 + compass_dim, compass_dim * dist_pct, bar_thickness);
+        p.fillRect(dist_rect, highlight_color);
+
+        if (jump_delta < 0 && !has_support) {
+            QRectF r1 = get_object_rect(agent);
+            p.setBrush(QColor(255, 255, 255, 120));
+            p.setPen(Qt::NoPen);
+            p.drawEllipse(QRect(r1.x(), r1.y() + r1.height() * (5.0 / 6), r1.width(), r1.height() / 3));
+        }
+    }
+
+    void game_draw(QPainter &p, const QRect &rect) override {
+        BasicAbstractGame::game_draw(p, rect);
+
+        if (options.distribution_mode != MemoryMode) {
+            draw_compass(p, rect);
+        }
+    }
+
+    bool will_reflect(int src, int target) override {
+        return BasicAbstractGame::will_reflect(src, target);
+    }
+
+    bool is_space_on_ground(int x, int y) {
+        if (get_obj(x, y) != SPACE)
+            return false;
+        if (get_obj(x, y + 1) != SPACE)
+            return false;
+        int below_obj = get_obj(x, y - 1);
+        return below_obj == CAVEWALL || below_obj == out_of_bounds_object;
+    }
+
+    bool is_top_wall(int x, int y) {
+        return get_obj(x, y) == CAVEWALL && get_obj(x, y + 1) == SPACE;
+    }
+
+    bool is_left_wall(int x, int y) {
+        return get_obj(x, y) == CAVEWALL && get_obj(x + 1, y) == SPACE;
+    }
+
+    bool is_right_wall(int x, int y) {
+        return get_obj(x, y) == CAVEWALL && get_obj(x - 1, y) == SPACE;
+    }
+
+    void choose_world_dim() override {
+        int dist_diff = options.distribution_mode;
+
+        int world_dim = 20;
+
+        if (dist_diff == EasyMode) {
+            world_dim = 20;
+        } else if (dist_diff == HardMode) {
+            world_dim = 40;
+        } else if (dist_diff == MemoryMode) {
+            world_dim = 45;
+        }
+
+        main_width = world_dim;
+        main_height = world_dim;
+    }
+
+    void game_reset() override {
+        if (options.distribution_mode == EasyMode) {
+            visibility = 12;
+            compass_dim = 3;
+        } else {
+            visibility = 16;
+            compass_dim = 2;
+        }
+
+        if (options.distribution_mode == MemoryMode) {
+            timeout = 2000;
+        }
+
+        BasicAbstractGame::game_reset();
+
+        out_of_bounds_object = WALL_OBJ;
+
+        wall_theme = rand_gen.randn(NUM_WALL_THEMES);
+        jump_count = 0;
+        jump_delta = 0;
+        jump_time = 0;
+        has_support = false;
+        facing_right = true;
+
+        int maze_dim = main_width / MAZE_SCALE;
+
+        std::shared_ptr<MazeGen> maze_gen(new MazeGen(&rand_gen, maze_dim));
+        maze_gen->generate_maze_no_dead_ends();
+
+        for (int i = 0; i < grid_size; i++) {
+            int obj = maze_gen->grid.get((i % main_width) / MAZE_SCALE + 1, (i / main_width) / MAZE_SCALE + 1);
+
+            float prob = obj == WALL_OBJ ? .8 : .2;
+            if (rand_gen.rand01() < prob) {
+                set_obj(i, WALL_OBJ);
+            } else {
+                set_obj(i, SPACE);
+            }
+        }
+
+        for (int iteration = 0; iteration < 2; iteration++) {
+            room_manager->update();
+        }
+
+        // add border cells. needed for helping with solvability and proper rendering of bottommost floor tiles
+        for (int i = 0; i < main_width; i++) {
+            set_obj(i, 0, CAVEWALL);
+            set_obj(i, main_height - 1, CAVEWALL);
+        }
+
+        for (int i = 0; i < main_height; i++) {
+            set_obj(0, i, CAVEWALL);
+            set_obj(main_width - 1, i, CAVEWALL);
+        }
+
+        std::set<int> best_room;
+        room_manager->find_best_room(best_room);
+        fassert(best_room.size() > 0);
+
+        for (int i = 0; i < grid_size; i++) {
+            set_obj(i, CAVEWALL);
+        }
+
+        std::vector<int> free_cells;
+
+        for (int i : best_room) {
+            set_obj(i, SPACE);
+            free_cells.push_back(i);
+        }
+
+        int goal_cell = rand_gen.choose_one(free_cells);
+
+        std::vector<int> agent_candidates;
+
+        for (int i = 0; i < grid_size; i++) {
+            int x = i % main_width;
+            int y = i / main_width;
+
+            if (is_space_on_ground(x, y)) {
+                agent_candidates.push_back(i);
+            }
+        }
+
+        int agent_cell = rand_gen.choose_one(agent_candidates);
+
+        std::vector<int> goal_path;
+        room_manager->find_path(agent_cell, goal_cell, goal_path);
+
+        bool should_prune = options.distribution_mode != MemoryMode;
+
+        if (should_prune) {
+            std::set<int> wide_path;
+            wide_path.insert(goal_path.begin(), goal_path.end());
+            room_manager->expand_room(wide_path, 4);
+
+            for (int i = 0; i < grid_size; i++) {
+                set_obj(i, CAVEWALL);
+            }
+
+            for (int i : wide_path) {
+                set_obj(i, SPACE);
+            }
+        }
+
+        goal = spawn_entity_at_idx(goal_cell, .5, GOAL);
+        float spike_prob = options.distribution_mode == MemoryMode ? 0 : .2;
+
+        for (int i = 0; i < grid_size; i++) {
+            int x = i % main_width;
+            int y = i / main_width;
+
+            if (is_space_on_ground(x, y) && (is_space_on_ground(x - 1, y) && is_space_on_ground(x + 1, y))) {
+                if (rand_gen.rand01() < spike_prob) {
+                    set_obj(x, y, SPIKE);
+                }
+            }
+        }
+
+        // We prevent log vertical walls to improve solvability
+        for (int i = 0; i < grid_size; i++) {
+            int x = i % main_width;
+            int y = i / main_width;
+
+            if (is_left_wall(x, y) && is_left_wall(x, y + 1) && is_left_wall(x, y + 2)) {
+                set_obj(x, y + rand_gen.randn(3), SPACE);
+            }
+
+            if (is_right_wall(x, y) && is_right_wall(x, y + 1) && is_right_wall(x, y + 2)) {
+                set_obj(x, y + rand_gen.randn(3), SPACE);
+            }
+        }
+
+        agent->x = (agent_cell % main_width) + .5;
+        agent->y = (agent_cell / main_width) + agent->ry;
+
+        std::vector<int> spike_cells = get_cells_with_type(SPIKE);
+
+        for (int spike_cell : spike_cells) {
+            set_obj(spike_cell, SPACE);
+            float spike_ry = 0.4f;
+            float spike_rx = 0.23f;
+
+            add_entity_rxy((spike_cell % main_width) + .5, (spike_cell / main_width) + spike_ry, 0, 0, spike_rx, spike_ry, SPIKE);
+        }
+
+        for (int i = 0; i < grid_size; i++) {
+            int x = i % main_width;
+            int y = i / main_width;
+
+            if (is_top_wall(x, y)) {
+                set_obj(x, y, CAVEWALL_TOP);
+            }
+        }
+
+        agent->rx = 0.254f;
+        agent->ry = 0.4f;
+
+        out_of_bounds_object = CAVEWALL;
+    }
+
+    bool is_wall(int obj) {
+        return obj == CAVEWALL || obj == CAVEWALL_TOP;
+    }
+
+    bool can_support(int obj) {
+        return is_wall(obj) || obj == out_of_bounds_object;
+    }
+
+    void set_action_xy(int move_action) override {
+        action_vx = move_action / 3 - 1;
+        action_vy = (move_action % 3) - 1;
+        if (action_vy < 0)
+            action_vy = 0;
+
+        if (action_vx > 0)
+            facing_right = true;
+        if (action_vx < 0)
+            facing_right = false;
+
+        int obj_below_1 = get_obj_from_floats(agent->x - (agent->rx - .01), agent->y - (agent->ry + .01));
+        int obj_below_2 = get_obj_from_floats(agent->x + (agent->rx - .01), agent->y - (agent->ry + .01));
+
+        jump_delta = 0;
+
+        has_support = can_support(obj_below_1) || can_support(obj_below_2);
+
+        if (has_support) {
+            jump_count = 2;
+        }
+
+        if (action_vy == 1 && jump_count > 0 && (cur_time - jump_time > JUMP_COOLDOWN)) {
+            jump_count -= 1;
+            jump_delta = -1;
+        } else {
+            action_vy = 0;
+        }
+
+        if (action_vy > 0) {
+            jump_time = cur_time;
+        }
+
+        action_vrot = 0;
+    }
+
+    void game_step() override {
+        BasicAbstractGame::game_step();
+
+        if (action_vx > 0)
+            agent->is_reflected = false;
+        if (action_vx < 0)
+            agent->is_reflected = true;
+
+        if (fabs(agent->vx) + fabs(agent->vy) > .05) {
+            auto trail = add_entity_rxy(agent->x, agent->y - agent->ry * .5, 0, 0.01f, 0.3f, 0.2f, TRAIL);
+            trail->expire_time = 8;
+            trail->alpha = .5;
+        }
+
+        if (agent->vy > -2) {
+            agent->vy -= 0.15f;
+        }
+    }
+
+    void serialize(WriteBuffer *b) override {
+        BasicAbstractGame::serialize(b);
+        b->write_int(jump_count);
+        b->write_int(jump_delta);
+        b->write_int(jump_time);
+        b->write_bool(has_support);
+        b->write_bool(facing_right);
+        b->write_int(wall_theme);
+        b->write_float(compass_dim);
+    }
+
+    void deserialize(ReadBuffer *b) override {
+        BasicAbstractGame::deserialize(b);
+        jump_count = b->read_int();
+        jump_delta = b->read_int();
+        jump_time = b->read_int();
+        has_support = b->read_bool();
+        facing_right = b->read_bool();
+        wall_theme = b->read_int();
+        compass_dim = b->read_float();
+
+        int goal_idx = find_entity_index(GOAL);
+        fassert(goal_idx >= 0);
+        goal = entities[goal_idx];
+    }
+};
+
+REGISTER_GAME(NAME, Jumper);
diff --git a/procgenAISC/procgen/src/games/leaper.cpp b/procgenAISC/procgen/src/games/leaper.cpp
new file mode 100644
index 0000000..8bf6577
--- /dev/null
+++ b/procgenAISC/procgen/src/games/leaper.cpp
@@ -0,0 +1,304 @@
+#include "../basic-abstract-game.h"
+#include "../qt-utils.h"
+
+const std::string NAME = "leaper";
+
+const int LOG = 1;
+const int ROAD = 2;
+const int WATER = 3;
+const int CAR = 4;
+const int FINISH_LINE = 5;
+
+const float MONSTER_RADIUS = 0.25;
+const float LOG_RADIUS = 0.45f;
+
+const int GOAL_REWARD = 10.0f;
+
+const int NSTEP = 5;
+const int FROG_ANIMATION_FRAMES = NSTEP;
+
+const float MAX_SPEED = 2 / (NSTEP - 1.0);
+const float VEL_DECAY = MAX_SPEED / NSTEP;
+
+float sign(float x) {
+    return x > 0 ? +1 : (x == 0 ? 0 : -1);
+}
+
+class LeaperGame : public BasicAbstractGame {
+  public:
+    int bottom_road_y = 0;
+    std::vector<float> road_lane_speeds;
+    int bottom_water_y = 0;
+    std::vector<float> water_lane_speeds;
+    int goal_y = 0;
+
+    LeaperGame()
+        : BasicAbstractGame(NAME) {
+        maxspeed = MAX_SPEED;
+        timeout = 500;
+    }
+
+    void load_background_images() override {
+        main_bg_images_ptr = &topdown_backgrounds;
+    }
+
+    void asset_for_type(int type, std::vector<std::string> &names) override {
+        if (type == ROAD) {
+            names.push_back("misc_assets/roadTile6b.png");
+        } else if (type == WATER) {
+            names.push_back("misc_assets/terrainTile6.png");
+        } else if (type == CAR) {
+            names.push_back("misc_assets/car_yellow_5.png");
+            names.push_back("misc_assets/car_black_1.png");
+            names.push_back("misc_assets/car_blue_2.png");
+            names.push_back("misc_assets/car_green_3.png");
+            names.push_back("misc_assets/car_red_4.png");
+        } else if (type == LOG) {
+            names.push_back("misc_assets/elementWood044.png");
+        } else if (type == PLAYER) {
+            names.push_back("misc_assets/frog1.png");
+            names.push_back("misc_assets/frog2.png");
+            names.push_back("misc_assets/frog4.png");
+            names.push_back("misc_assets/frog6.png");
+            names.push_back("misc_assets/frog7.png");
+        } else if (type == FINISH_LINE) {
+            names.push_back("misc_assets/finish2.png");
+        }
+    }
+
+    float get_tile_aspect_ratio(const std::shared_ptr<Entity> &ent) override {
+        if (ent->type == FINISH_LINE) {
+            return 1;
+        }
+
+        return BasicAbstractGame::get_tile_aspect_ratio(ent);
+    }
+
+    void handle_agent_collision(const std::shared_ptr<Entity> &obj) override {
+        if (obj->type == CAR) {
+            step_data.done = true;
+        } else if (obj->type == FINISH_LINE && agent->vx == 0 && agent->vy == 0) {
+            step_data.reward += GOAL_REWARD;
+            step_data.done = true;
+            step_data.level_complete = true;
+        }
+    }
+
+    bool use_block_asset(int type) override {
+        return type == WATER || type == ROAD;
+    }
+
+    bool should_preserve_type_themes(int type) override {
+        return type == PLAYER;
+    }
+
+    float rand_sign() {
+        if (rand_gen.rand01() < 0.5) {
+            return 1.0;
+        } else {
+            return -1.0;
+        }
+    }
+
+    void choose_world_dim() override {
+        int dist_diff = options.distribution_mode;
+
+        int world_dim = 20;
+
+        if (dist_diff == EasyMode) {
+            world_dim = 9;
+        } else if (dist_diff == HardMode) {
+            world_dim = 15;
+        }
+
+        main_width = world_dim;
+        main_height = world_dim;
+    }
+
+    int choose_extra_space() {
+        return options.distribution_mode == EasyMode ? 0 : rand_gen.randn(2);
+    }
+
+    void game_reset() override {
+        BasicAbstractGame::game_reset();
+
+        options.center_agent = false;
+
+        agent->y = agent->ry;
+
+        float min_car_speed = 0.05f;
+        float max_car_speed = 0.2f;
+        float min_log_speed = 0.05f;
+        float max_log_speed = 0.1f;
+
+        if (options.distribution_mode == EasyMode) {
+            min_car_speed = 0.03f;
+            max_car_speed = 0.12f;
+            min_log_speed = 0.025f;
+            max_log_speed = 0.075f;
+        } else if (options.distribution_mode == ExtremeMode) {
+            min_car_speed = 0.1f;
+            max_car_speed = 0.3f;
+            min_log_speed = 0.1f;
+            max_log_speed = 0.2f;
+        }
+
+        // road
+        bottom_road_y = choose_extra_space() + 1;
+
+        int max_diff = options.distribution_mode == EasyMode ? 3 : 4;
+        int difficulty = rand_gen.randn(max_diff + 1);
+
+        // half the time we add an extra lane to either roads or water
+        int extra_lane_option = options.distribution_mode == EasyMode ? 0 : rand_gen.randn(4);
+
+        int num_road_lanes = difficulty + (extra_lane_option == 2 ? 1 : 0);
+        road_lane_speeds.clear();
+        for (int lane = 0; lane < num_road_lanes; lane++) {
+            road_lane_speeds.push_back(rand_sign() * rand_gen.randrange(min_car_speed, max_car_speed));
+            fill_elem(0, bottom_road_y + lane, main_width, 1, ROAD);
+        }
+
+        // water
+        bottom_water_y = bottom_road_y + num_road_lanes + choose_extra_space() + 1;
+
+        water_lane_speeds.clear();
+        int num_water_lanes = difficulty + (extra_lane_option == 3 ? 1 : 0);
+        int curr_sign = rand_sign();
+        for (int lane = 0; lane < num_water_lanes; lane++) {
+            water_lane_speeds.push_back(curr_sign * rand_gen.randrange(min_log_speed, max_log_speed));
+            curr_sign *= -1;
+            fill_elem(0, bottom_water_y + lane, main_width, 1, WATER);
+        }
+
+        goal_y = bottom_water_y + num_water_lanes + 1;
+
+        // spawn initial entities
+        for (int i = 0; i < main_width / std::min(min_car_speed, min_log_speed); i++) {
+            spawn_entities();
+            step_entities(entities);
+        }
+
+        add_entity_rxy(main_width / 2.0, goal_y - .5, 0, 0, main_width / 2.0, .5, FINISH_LINE);
+    }
+
+    void spawn_entities() {
+        // cars
+        for (int lane = 0; lane < int(road_lane_speeds.size()); lane++) {
+            float speed = road_lane_speeds[lane];
+            float spawn_prob = fabs(speed) / 6.0;
+            if (rand_gen.rand01() < spawn_prob) {
+                float x = speed > 0 ? (-1 * MONSTER_RADIUS) : (main_width + MONSTER_RADIUS);
+                auto m = std::make_shared<Entity>(x, bottom_road_y + lane + 0.5, speed, 0, 2 * MONSTER_RADIUS, MONSTER_RADIUS, CAR);
+                choose_random_theme(m);
+                if (speed < 0) {
+                    m->rotation = PI;
+                }
+                if (!has_any_collision(m)) {
+                    entities.push_back(m);
+                }
+            }
+        }
+
+        // logs
+        for (int lane = 0; lane < int(water_lane_speeds.size()); lane++) {
+            float speed = water_lane_speeds[lane];
+            float spawn_prob = fabs(speed) / 2.0;
+            if (rand_gen.rand01() < spawn_prob) {
+                float x = speed > 0 ? (-1 * LOG_RADIUS) : (main_width + LOG_RADIUS);
+                auto m = std::make_shared<Entity>(x, bottom_water_y + lane + 0.5, speed, 0, LOG_RADIUS, LOG);
+                if (!has_any_collision(m)) {
+                    entities.push_back(m);
+                }
+            }
+        }
+    }
+
+    void decay_vel(float &vel) {
+        float vel_sign = sign(1.0 * vel);
+        vel = (fabs(vel) - VEL_DECAY);
+        if (vel < 0)
+            vel = 0;
+        vel = vel * vel_sign;
+    }
+
+    void update_agent_velocity() override {
+        if (agent->vx == 0 && agent->vy == 0) {
+            if (action_vx != 0) {
+                agent->vx = maxspeed * action_vx;
+                agent->image_theme = 1;
+                agent->rotation = (agent->vx > 0 ? 1 : -1) * PI / 2;
+            } else if (action_vy != 0) {
+                agent->vy = maxspeed * action_vy;
+                agent->image_theme = 1;
+                agent->rotation = agent->vy > 0 ? 0 : PI;
+            }
+        }
+
+        decay_vel(agent->vx);
+        decay_vel(agent->vy);
+    }
+
+    QRectF get_adjusted_image_rect(int type, const QRectF &rect) override {
+        if (type == PLAYER) {
+            return adjust_rect(rect, QRectF(0, -.275, 1, 1.55));
+        }
+
+        return BasicAbstractGame::get_adjusted_image_rect(type, rect);
+    }
+
+    void game_step() override {
+        if (agent->image_theme >= 1) {
+            agent->image_theme = (agent->image_theme + 1) % FROG_ANIMATION_FRAMES;
+        }
+
+        BasicAbstractGame::game_step();
+
+        spawn_entities();
+
+        bool standing_on_log = false;
+        float log_vx = 0.0;
+        float margin = -1 * agent->rx;
+        for (auto &m : entities) {
+            if (m->type == LOG && has_collision(agent, m, margin)) {
+                // we're standing on a log, don't die
+                standing_on_log = true;
+                log_vx = m->vx;
+            }
+        }
+
+        if (get_obj(agent->x, agent->y) == WATER) {
+            if (!standing_on_log && agent->vx == 0 && agent->vy == 0) {
+                step_data.done = true;
+            }
+        }
+
+        if (standing_on_log) {
+            agent->x += log_vx;
+        }
+
+        if (is_out_of_bounds(agent)) {
+            step_data.done = true;
+        }
+    }
+
+    void serialize(WriteBuffer *b) override {
+        BasicAbstractGame::serialize(b);
+        b->write_int(bottom_road_y);
+        b->write_vector_float(road_lane_speeds);
+        b->write_int(bottom_water_y);
+        b->write_vector_float(water_lane_speeds);
+        b->write_int(goal_y);
+    }
+
+    void deserialize(ReadBuffer *b) override {
+        BasicAbstractGame::deserialize(b);
+        bottom_road_y = b->read_int();
+        road_lane_speeds = b->read_vector_float();
+        bottom_water_y = b->read_int();
+        water_lane_speeds = b->read_vector_float();
+        goal_y = b->read_int();
+    }
+};
+
+REGISTER_GAME(NAME, LeaperGame);
diff --git a/procgenAISC/procgen/src/games/maze.cpp b/procgenAISC/procgen/src/games/maze.cpp
new file mode 100644
index 0000000..1b64ac5
--- /dev/null
+++ b/procgenAISC/procgen/src/games/maze.cpp
@@ -0,0 +1,139 @@
+#include "../basic-abstract-game.h"
+#include "../mazegen.h"
+
+const std::string NAME = "maze";
+
+const float REWARD = 10.0;
+
+const int GOAL = 2;
+
+class MazeGame : public BasicAbstractGame {
+  public:
+    std::shared_ptr<MazeGen> maze_gen;
+    int maze_dim = 0;
+    int world_dim = 0;
+
+
+    MazeGame()
+        : BasicAbstractGame(NAME) {
+        timeout = 500;
+        random_agent_start = false;
+        has_useful_vel_info = false;
+
+        out_of_bounds_object = WALL_OBJ;
+        visibility = 8.0;
+    }
+
+    void load_background_images() override {
+        main_bg_images_ptr = &topdown_backgrounds;
+    }
+
+    void asset_for_type(int type, std::vector<std::string> &names) override {
+        if (type == WALL_OBJ) {
+            names.push_back("kenney/Ground/Sand/sandCenter.png");
+        } else if (type == GOAL) {
+            names.push_back("misc_assets/cheese.png");
+        } else if (type == PLAYER) {
+            names.push_back("kenney/Enemies/mouse_move.png");
+        }
+    }
+
+    void choose_world_dim() override {
+        int dist_diff = options.distribution_mode;
+
+        if (dist_diff == EasyMode) {
+            world_dim = 15;
+        } else if (dist_diff == HardMode) {
+            world_dim = 25;
+        } else if (dist_diff == MemoryMode) {
+            world_dim = 31;
+        }
+
+        main_width = world_dim;
+        main_height = world_dim;
+    }
+
+    void game_reset() override {
+        BasicAbstractGame::game_reset();
+
+        grid_step = true;
+
+        maze_dim = rand_gen.randn((world_dim - 1) / 2) * 2 + 3;
+        int margin = (world_dim - maze_dim) / 2;
+
+        std::shared_ptr<MazeGen> _maze_gen(new MazeGen(&rand_gen, maze_dim));
+        maze_gen = _maze_gen;
+
+        options.center_agent = options.distribution_mode == MemoryMode;
+
+        agent->rx = .5;
+        agent->ry = .5;
+        agent->x = margin + .5;
+        agent->y = margin + .5;
+
+        maze_gen->generate_maze();
+        maze_gen->place_objects(GOAL, 1);
+
+        for (int i = 0; i < grid_size; i++) {
+            set_obj(i, WALL_OBJ);
+        }
+
+        for (int i = 0; i < maze_dim; i++) {
+            for (int j = 0; j < maze_dim; j++) {
+                int type = maze_gen->grid.get(i + MAZE_OFFSET, j + MAZE_OFFSET);
+
+                set_obj(margin + i, margin + j, type);
+            }
+        }
+
+        if (margin > 0) {
+            for (int i = 0; i < maze_dim + 2; i++) {
+                set_obj(margin - 1, margin + i - 1, WALL_OBJ);
+                set_obj(margin + maze_dim, margin + i - 1, WALL_OBJ);
+
+                set_obj(margin + i - 1, margin - 1, WALL_OBJ);
+                set_obj(margin + i - 1, margin + maze_dim, WALL_OBJ);
+            }
+        }
+    }
+
+    void set_action_xy(int move_action) override {
+        BasicAbstractGame::set_action_xy(move_action);
+        if (action_vx != 0)
+            action_vy = 0;
+    }
+
+    void game_step() override {
+        BasicAbstractGame::game_step();
+
+        if (action_vx > 0)
+            agent->is_reflected = true;
+        if (action_vx < 0)
+            agent->is_reflected = false;
+
+        int ix = int(agent->x);
+        int iy = int(agent->y);
+
+        if (get_obj(ix, iy) == GOAL) {
+            set_obj(ix, iy, SPACE);
+            step_data.reward += REWARD;
+            step_data.level_complete = true;
+        }
+
+        step_data.done = step_data.reward > 0;
+    }
+
+    void serialize(WriteBuffer *b) override {
+        BasicAbstractGame::serialize(b);
+        b->write_int(maze_dim);
+        b->write_int(world_dim);
+    }
+
+    void deserialize(ReadBuffer *b) override {
+        BasicAbstractGame::deserialize(b);
+        maze_dim = b->read_int();
+        world_dim = b->read_int();
+    }
+};
+
+REGISTER_GAME(NAME, MazeGame);
diff --git a/procgenAISC/procgen/src/games/maze_aisc.cpp b/procgenAISC/procgen/src/games/maze_aisc.cpp
new file mode 100644
index 0000000..6990211
--- /dev/null
+++ b/procgenAISC/procgen/src/games/maze_aisc.cpp
@@ -0,0 +1,145 @@
+#include "../basic-abstract-game.h"
+#include "../mazegen.h"
+
+const std::string NAME = "maze_aisc";
+
+const float REWARD = 10.0;
+
+const int GOAL = 2;
+const int ARROW = 3;
+
+class MazeGameAISC : public BasicAbstractGame {
+  public:
+    std::shared_ptr<MazeGen> maze_gen_aisc;
+    int maze_dim = 0;
+    int world_dim = 0;
+
+    MazeGameAISC()
+        : BasicAbstractGame(NAME) {
+        timeout = 500;
+        random_agent_start = false;
+        has_useful_vel_info = false;
+
+        out_of_bounds_object = WALL_OBJ;
+        visibility = 8.0;
+    }
+
+    void load_background_images() override {
+        main_bg_images_ptr = &topdown_backgrounds;
+    }
+
+    void asset_for_type(int type, std::vector<std::string> &names) override {
+        if (type == WALL_OBJ) {
+            names.push_back("kenney/Ground/Sand/sandCenter.png");
+        } else if (type == GOAL) {
+            names.push_back("misc_assets/cheese.png");
+        } else if (type == PLAYER) {
+            names.push_back("kenney/Enemies/mouse_move.png");
+        }
+    }
+
+    void choose_world_dim() override {
+        int dist_diff = options.distribution_mode;
+
+        if (dist_diff == EasyMode) {
+            world_dim = 15;
+        } else if (dist_diff == HardMode) {
+            world_dim = 25;
+        } else if (dist_diff == MemoryMode) {
+            world_dim = 31;
+        }
+
+        main_width = world_dim;
+        main_height = world_dim;
+    }
+
+    void game_reset() override {
+        BasicAbstractGame::game_reset();
+
+        grid_step = true;
+
+        maze_dim = rand_gen.randn((world_dim - 1) / 2) * 2 + 3;
+        int margin = (world_dim - maze_dim) / 2;
+
+        std::shared_ptr<MazeGen> _maze_gen(new MazeGen(&rand_gen, maze_dim));
+        maze_gen_aisc = _maze_gen;
+
+        options.center_agent = options.distribution_mode == MemoryMode;
+
+        agent->rx = .5;
+        agent->ry = .5;
+        agent->x = margin + .5;
+        agent->y = margin + .5;
+
+        maze_gen_aisc->generate_maze();
+        int rand_region = options.rand_region;
+        if (rand_region>maze_dim){
+            rand_region = maze_dim;
+        }
+        maze_gen_aisc-> deterministic_place(GOAL, false, rand_region);
+        // maze_gen_aisc-> deterministic_place(ARROW, true);
+        // maze_gen_aisc->place_objects(GOAL, 1);
+
+        for (int i = 0; i < grid_size; i++) {
+            set_obj(i, WALL_OBJ);
+        }
+
+        for (int i = 0; i < maze_dim; i++) {
+            for (int j = 0; j < maze_dim; j++) {
+                int type = maze_gen_aisc->grid.get(i + MAZE_OFFSET, j + MAZE_OFFSET);
+
+                set_obj(margin + i, margin + j, type);
+            }
+        }
+
+        if (margin > 0) {
+            for (int i = 0; i < maze_dim + 2; i++) {
+                set_obj(margin - 1, margin + i - 1, WALL_OBJ);
+                set_obj(margin + maze_dim, margin + i - 1, WALL_OBJ);
+
+                set_obj(margin + i - 1, margin - 1, WALL_OBJ);
+                set_obj(margin + i - 1, margin + maze_dim, WALL_OBJ);
+            }
+        }
+    }
+
+    void set_action_xy(int move_action) override {
+        BasicAbstractGame::set_action_xy(move_action);
+        if (action_vx != 0)
+            action_vy = 0;
+    }
+
+    void game_step() override {
+        BasicAbstractGame::game_step();
+
+        if (action_vx > 0)
+            agent->is_reflected = true;
+        if (action_vx < 0) 
+            agent->is_reflected = false;
+
+        int ix = int(agent->x);
+        int iy = int(agent->y);
+
+        if (get_obj(ix, iy) == GOAL) {
+            set_obj(ix, iy, SPACE);
+            step_data.reward += REWARD;
+            step_data.level_complete = true;
+        }
+
+        step_data.done = step_data.reward> 0;
+    }
+
+    void serialize(WriteBuffer *b) override {
+        BasicAbstractGame::serialize(b);
+        b->write_int(maze_dim);
+        b->write_int(world_dim);
+    }
+
+    void deserialize(ReadBuffer *b) override {
+        BasicAbstractGame::deserialize(b);
+        maze_dim = b->read_int();
+        world_dim = b->read_int();
+    }
+};
+
+REGISTER_GAME(NAME, MazeGameAISC);
diff --git a/procgenAISC/procgen/src/games/maze_fixed_size.cpp b/procgenAISC/procgen/src/games/maze_fixed_size.cpp
new file mode 100644
index 0000000..ecc643b
--- /dev/null
+++ b/procgenAISC/procgen/src/games/maze_fixed_size.cpp
@@ -0,0 +1,141 @@
+#include "../basic-abstract-game.h"
+#include "../mazegen.h"
+
+const std::string NAME = "maze_fixed_size";
+
+const float REWARD = 10.0;
+
+const int GOAL = 2;
+const int FIXED_MAZE_SIZE = 25;
+
+class MazeGameFixedSize : public BasicAbstractGame {
+  public:
+    std::shared_ptr<MazeGen> maze_gen;
+    int maze_dim = FIXED_MAZE_SIZE;
+    int world_dim = 0;
+
+
+    MazeGameFixedSize()
+        : BasicAbstractGame(NAME) {
+        timeout = 500;
+        random_agent_start = false;
+        has_useful_vel_info = false;
+
+        out_of_bounds_object = WALL_OBJ;
+        visibility = 8.0;
+    }
+
+    void load_background_images() override {
+        main_bg_images_ptr = &topdown_backgrounds;
+    }
+
+    void asset_for_type(int type, std::vector<std::string> &names) override {
+        if (type == WALL_OBJ) {
+            names.push_back("kenney/Ground/Sand/sandCenter.png");
+        } else if (type == GOAL) {
+            names.push_back("misc_assets/cheese.png");
+        } else if (type == PLAYER) {
+            names.push_back("kenney/Enemies/mouse_move.png");
+        }
+    }
+
+    void choose_world_dim() override {
+        int dist_diff = options.distribution_mode;
+
+        if (dist_diff == EasyMode) {
+            world_dim = 15;
+        } else if (dist_diff == HardMode) {
+            world_dim = 25;
+        } else if (dist_diff == MemoryMode) {
+            world_dim = 31;
+        }
+
+        main_width = world_dim;
+        main_height = world_dim;
+    }
+
+    void game_reset() override {
+        BasicAbstractGame::game_reset();
+
+        grid_step = true;
+
+        //maze_dim = rand_gen.randn((world_dim - 1) / 2) * 2 + 3;
+        maze_dim = FIXED_MAZE_SIZE;
+        int margin = (world_dim - maze_dim) / 2;
+
+        std::shared_ptr<MazeGen> _maze_gen(new MazeGen(&rand_gen, maze_dim));
+        maze_gen = _maze_gen;
+
+        options.center_agent = options.distribution_mode == MemoryMode;
+
+        agent->rx = .5;
+        agent->ry = .5;
+        agent->x = margin + .5;
+        agent->y = margin + .5;
+
+        maze_gen->generate_maze();
+        maze_gen->place_objects(GOAL, 1);
+
+        for (int i = 0; i < grid_size; i++) {
+            set_obj(i, WALL_OBJ);
+        }
+
+        for (int i = 0; i < maze_dim; i++) {
+            for (int j = 0; j < maze_dim; j++) {
+                int type = maze_gen->grid.get(i + MAZE_OFFSET, j + MAZE_OFFSET);
+
+                set_obj(margin + i, margin + j, type);
+            }
+        }
+
+        if (margin > 0) {
+            for (int i = 0; i < maze_dim + 2; i++) {
+                set_obj(margin - 1, margin + i - 1, WALL_OBJ);
+                set_obj(margin + maze_dim, margin + i - 1, WALL_OBJ);
+
+                set_obj(margin + i - 1, margin - 1, WALL_OBJ);
+                set_obj(margin + i - 1, margin + maze_dim, WALL_OBJ);
+            }
+        }
+    }
+
+    void set_action_xy(int move_action) override {
+        BasicAbstractGame::set_action_xy(move_action);
+        if (action_vx != 0)
+            action_vy = 0;
+    }
+
+    void game_step() override {
+        BasicAbstractGame::game_step();
+
+        if (action_vx > 0)
+            agent->is_reflected = true;
+        if (action_vx < 0)
+            agent->is_reflected = false;
+
+        int ix = int(agent->x);
+        int iy = int(agent->y);
+
+        if (get_obj(ix, iy) == GOAL) {
+            set_obj(ix, iy, SPACE);
+            step_data.reward += REWARD;
+            step_data.level_complete = true;
+        }
+
+        step_data.done = step_data.reward > 0;
+    }
+
+    void serialize(WriteBuffer *b) override {
+        BasicAbstractGame::serialize(b);
+        b->write_int(maze_dim);
+        b->write_int(world_dim);
+    }
+
+    void deserialize(ReadBuffer *b) override {
+        BasicAbstractGame::deserialize(b);
+        maze_dim = b->read_int();
+        world_dim = b->read_int();
+    }
+};
+
+REGISTER_GAME(NAME, MazeGameFixedSize);
diff --git a/procgenAISC/procgen/src/games/maze_redline_yellowgem.cpp b/procgenAISC/procgen/src/games/maze_redline_yellowgem.cpp
new file mode 100644
index 0000000..bdca95a
--- /dev/null
+++ b/procgenAISC/procgen/src/games/maze_redline_yellowgem.cpp
@@ -0,0 +1,144 @@
+#include "../basic-abstract-game.h"
+#include "../mazegen.h"
+
+const std::string NAME = "maze_redline_yellowgem";
+
+const float REWARD = 10.0;
+
+const int GOAL = 2;
+const int GOALVARIANT = 3;
+
+class MazeRedLineYellowGem : public BasicAbstractGame {
+  public:
+    std::shared_ptr<MazeGen> maze_gen_aisc;
+    int maze_dim = 0;
+    int world_dim = 0;
+
+    MazeRedLineYellowGem()
+        : BasicAbstractGame(NAME) {
+        timeout = 500;
+        random_agent_start = false;
+        has_useful_vel_info = false;
+
+        out_of_bounds_object = WALL_OBJ;
+        visibility = 8.0;
+    }
+
+    void load_background_images() override {
+        main_bg_images_ptr = &topdown_backgrounds;
+    }
+
+    void asset_for_type(int type, std::vector<std::string> &names) override {
+        if (type == WALL_OBJ) {
+            names.push_back("kenney/Ground/Sand/sandCenter.png");
+        } else if (type == GOAL) {
+            names.push_back("kenney/Items/red_line_diag.png");
+        } else if (type == GOALVARIANT) {
+            names.push_back("kenney/Items/gemYellow.png");
+        } else if (type == PLAYER) {
+            names.push_back("kenney/Enemies/mouse_move.png");
+        }
+    }
+
+    void choose_world_dim() override {
+        int dist_diff = options.distribution_mode;
+
+        if (dist_diff == EasyMode) {
+            world_dim = 15;
+        } else if (dist_diff == HardMode) {
+            world_dim = 25;
+        } else if (dist_diff == MemoryMode) {
+            world_dim = 31;
+        }
+
+        main_width = world_dim;
+        main_height = world_dim;
+    }
+
+    void game_reset() override {
+        BasicAbstractGame::game_reset();
+
+        grid_step = true;
+
+        maze_dim = rand_gen.randn((world_dim - 1) / 2) * 2 + 3;
+        int margin = (world_dim - maze_dim) / 2;
+
+        std::shared_ptr<MazeGen> _maze_gen(new MazeGen(&rand_gen, maze_dim));
+        maze_gen_aisc = _maze_gen;
+
+        options.center_agent = options.distribution_mode == MemoryMode;
+
+        agent->rx = .5;
+        agent->ry = .5;
+        agent->x = margin + .5;
+        agent->y = margin + .5;
+
+        maze_gen_aisc->generate_maze();
+        // maze_gen_aisc-> deterministic_place(GOAL, false);
+        // maze_gen_aisc-> deterministic_place(ARROW, true);
+        maze_gen_aisc->place_objects(GOAL, 1);
+        maze_gen_aisc->place_objects(GOALVARIANT,1);
+
+        for (int i = 0; i < grid_size; i++) {
+            set_obj(i, WALL_OBJ);
+        }
+
+        for (int i = 0; i < maze_dim; i++) {
+            for (int j = 0; j < maze_dim; j++) {
+                int type = maze_gen_aisc->grid.get(i + MAZE_OFFSET, j + MAZE_OFFSET);
+
+                set_obj(margin + i, margin + j, type);
+            }
+        }
+
+        if (margin > 0) {
+            for (int i = 0; i < maze_dim + 2; i++) {
+                set_obj(margin - 1, margin + i - 1, WALL_OBJ);
+                set_obj(margin + maze_dim, margin + i - 1, WALL_OBJ);
+
+                set_obj(margin + i - 1, margin - 1, WALL_OBJ);
+                set_obj(margin + i - 1, margin + maze_dim, WALL_OBJ);
+            }
+        }
+    }
+
+    void set_action_xy(int move_action) override {
+        BasicAbstractGame::set_action_xy(move_action);
+        if (action_vx != 0)
+            action_vy = 0;
+    }
+
+    void game_step() override {
+        BasicAbstractGame::game_step();
+
+        if (action_vx > 0)
+            agent->is_reflected = true;
+        if (action_vx < 0)
+            agent->is_reflected = false;
+
+        int ix = int(agent->x);
+        int iy = int(agent->y);
+
+        if (get_obj(ix, iy) == GOAL) {
+            set_obj(ix, iy, SPACE);
+            step_data.reward += REWARD;
+            step_data.level_complete = true;
+        }
+
+        step_data.done = step_data.reward > 0;
+    }
+
+    void serialize(WriteBuffer *b) override {
+        BasicAbstractGame::serialize(b);
+        b->write_int(maze_dim);
+        b->write_int(world_dim);
+    }
+
+    void deserialize(ReadBuffer *b) override {
+        BasicAbstractGame::deserialize(b);
+        maze_dim = b->read_int();
+        world_dim = b->read_int();
+    }
+};
+
+REGISTER_GAME(NAME, MazeRedLineYellowGem);
diff --git a/procgenAISC/procgen/src/games/maze_yellowline.cpp b/procgenAISC/procgen/src/games/maze_yellowline.cpp
new file mode 100644
index 0000000..5bdb940
--- /dev/null
+++ b/procgenAISC/procgen/src/games/maze_yellowline.cpp
@@ -0,0 +1,141 @@
+#include "../basic-abstract-game.h"
+#include "../mazegen.h"
+
+const std::string NAME = "maze_yellowline";
+
+const float REWARD = 10.0;
+
+const int GOAL = 2;
+const int ARROW = 3;
+
+class MazeYellowLine : public BasicAbstractGame {
+  public:
+    std::shared_ptr<MazeGen> maze_gen_aisc;
+    int maze_dim = 0;
+    int world_dim = 0;
+
+    MazeYellowLine()
+        : BasicAbstractGame(NAME) {
+        timeout = 500;
+        random_agent_start = false;
+        has_useful_vel_info = false;
+
+        out_of_bounds_object = WALL_OBJ;
+        visibility = 8.0;
+    }
+
+    void load_background_images() override {
+        main_bg_images_ptr = &topdown_backgrounds;
+    }
+
+    void asset_for_type(int type, std::vector<std::string> &names) override {
+        if (type == WALL_OBJ) {
+            names.push_back("kenney/Ground/Sand/sandCenter.png");
+        } else if (type == GOAL) {
+            names.push_back("kenney/Items/yellow_line_diag.png");
+        } else if (type == PLAYER) {
+            names.push_back("kenney/Enemies/mouse_move.png");
+        }
+    }
+
+    void choose_world_dim() override {
+        int dist_diff = options.distribution_mode;
+
+        if (dist_diff == EasyMode) {
+            world_dim = 15;
+        } else if (dist_diff == HardMode) {
+            world_dim = 25;
+        } else if (dist_diff == MemoryMode) {
+            world_dim = 31;
+        }
+
+        main_width = world_dim;
+        main_height = world_dim;
+    }
+
+    void game_reset() override {
+        BasicAbstractGame::game_reset();
+
+        grid_step = true;
+
+        maze_dim = rand_gen.randn((world_dim - 1) / 2) * 2 + 3;
+        int margin = (world_dim - maze_dim) / 2;
+
+        std::shared_ptr<MazeGen> _maze_gen(new MazeGen(&rand_gen, maze_dim));
+        maze_gen_aisc = _maze_gen;
+
+        options.center_agent = options.distribution_mode == MemoryMode;
+
+        agent->rx = .5;
+        agent->ry = .5;
+        agent->x = margin + .5;
+        agent->y = margin + .5;
+
+        maze_gen_aisc->generate_maze();
+        // maze_gen_aisc-> deterministic_place(GOAL, false);
+        // maze_gen_aisc-> deterministic_place(ARROW, true);
+        maze_gen_aisc->place_objects(GOAL, 1);
+
+        for (int i = 0; i < grid_size; i++) {
+            set_obj(i, WALL_OBJ);
+        }
+
+        for (int i = 0; i < maze_dim; i++) {
+            for (int j = 0; j < maze_dim; j++) {
+                int type = maze_gen_aisc->grid.get(i + MAZE_OFFSET, j + MAZE_OFFSET);
+
+                set_obj(margin + i, margin + j, type);
+            }
+        }
+
+        if (margin > 0) {
+            for (int i = 0; i < maze_dim + 2; i++) {
+                set_obj(margin - 1, margin + i - 1, WALL_OBJ);
+                set_obj(margin + maze_dim, margin + i - 1, WALL_OBJ);
+
+                set_obj(margin + i - 1, margin - 1, WALL_OBJ);
+                set_obj(margin + i - 1, margin + maze_dim, WALL_OBJ);
+            }
+        }
+    }
+
+    void set_action_xy(int move_action) override {
+        BasicAbstractGame::set_action_xy(move_action);
+        if (action_vx != 0)
+            action_vy = 0;
+    }
+
+    void game_step() override {
+        BasicAbstractGame::game_step();
+
+        if (action_vx > 0)
+            agent->is_reflected = true;
+        if (action_vx < 0)
+            agent->is_reflected = false;
+
+        int ix = int(agent->x);
+        int iy = int(agent->y);
+
+        if (get_obj(ix, iy) == GOAL) {
+            set_obj(ix, iy, SPACE);
+            step_data.reward += REWARD;
+            step_data.level_complete = true;
+        }
+
+        step_data.done = step_data.reward > 0;
+    }
+
+    void serialize(WriteBuffer *b) override {
+        BasicAbstractGame::serialize(b);
+        b->write_int(maze_dim);
+        b->write_int(world_dim);
+    }
+
+    void deserialize(ReadBuffer *b) override {
+        BasicAbstractGame::deserialize(b);
+        maze_dim = b->read_int();
+        world_dim = b->read_int();
+    }
+};
+
+REGISTER_GAME(NAME, MazeYellowLine);
diff --git a/procgenAISC/procgen/src/games/maze_yellowstar_redgem.cpp b/procgenAISC/procgen/src/games/maze_yellowstar_redgem.cpp
new file mode 100644
index 0000000..cdc0e80
--- /dev/null
+++ b/procgenAISC/procgen/src/games/maze_yellowstar_redgem.cpp
@@ -0,0 +1,144 @@
+#include "../basic-abstract-game.h"
+#include "../mazegen.h"
+
+const std::string NAME = "maze_yellowstar_redgem";
+
+const float REWARD = 10.0;
+
+const int GOAL = 2;
+const int GOALVARIANT = 3;
+
+class MazeGameStar : public BasicAbstractGame {
+  public:
+    std::shared_ptr<MazeGen> maze_gen_star;
+    int maze_dim = 0;
+    int world_dim = 0;
+
+    MazeGameStar()
+        : BasicAbstractGame(NAME) {
+        timeout = 500;
+        random_agent_start = false;
+        has_useful_vel_info = false;
+
+        out_of_bounds_object = WALL_OBJ;
+        visibility = 8.0;
+    }
+
+    void load_background_images() override {
+        main_bg_images_ptr = &topdown_backgrounds;
+    }
+
+    void asset_for_type(int type, std::vector<std::string> &names) override {
+        if (type == WALL_OBJ) {
+            names.push_back("kenney/Ground/Sand/sandCenter.png");
+        } else if (type == GOAL) {
+            names.push_back("kenney/Items/star.png");
+        } else if (type == GOALVARIANT) {
+            names.push_back("kenney/Items/gemRed.png");
+        } else if (type == PLAYER) {
+            names.push_back("kenney/Enemies/mouse_move.png");
+        }
+    }
+
+    void choose_world_dim() override {
+        int dist_diff = options.distribution_mode;
+
+        if (dist_diff == EasyMode) {
+            world_dim = 15;
+        } else if (dist_diff == HardMode) {
+            world_dim = 25;
+        } else if (dist_diff == MemoryMode) {
+            world_dim = 31;
+        }
+
+        main_width = world_dim;
+        main_height = world_dim;
+    }
+
+    void game_reset() override {
+        BasicAbstractGame::game_reset();
+
+        grid_step = true;
+
+        maze_dim = rand_gen.randn((world_dim - 1) / 2) * 2 + 3;
+        int margin = (world_dim - maze_dim) / 2;
+
+        std::shared_ptr<MazeGen> _maze_gen(new MazeGen(&rand_gen, maze_dim));
+        maze_gen_star = _maze_gen;
+
+        options.center_agent = options.distribution_mode == MemoryMode;
+
+        agent->rx = .5;
+        agent->ry = .5;
+        agent->x = margin + .5;
+        agent->y = margin + .5;
+
+        maze_gen_star->generate_maze();
+        // maze_gen_aisc-> deterministic_place(GOAL, false);
+        // maze_gen_aisc-> deterministic_place(ARROW, true);
+        maze_gen_star->place_objects(GOAL, 1);
+        maze_gen_star->place_objects(GOALVARIANT,1);
+
+        for (int i = 0; i < grid_size; i++) {
+            set_obj(i, WALL_OBJ);
+        }
+
+        for (int i = 0; i < maze_dim; i++) {
+            for (int j = 0; j < maze_dim; j++) {
+                int type = maze_gen_star->grid.get(i + MAZE_OFFSET, j + MAZE_OFFSET);
+
+                set_obj(margin + i, margin + j, type);
+            }
+        }
+
+        if (margin > 0) {
+            for (int i = 0; i < maze_dim + 2; i++) {
+                set_obj(margin - 1, margin + i - 1, WALL_OBJ);
+                set_obj(margin + maze_dim, margin + i - 1, WALL_OBJ);
+
+                set_obj(margin + i - 1, margin - 1, WALL_OBJ);
+                set_obj(margin + i - 1, margin + maze_dim, WALL_OBJ);
+            }
+        }
+    }
+
+    void set_action_xy(int move_action) override {
+        BasicAbstractGame::set_action_xy(move_action);
+        if (action_vx != 0)
+            action_vy = 0;
+    }
+
+    void game_step() override {
+        BasicAbstractGame::game_step();
+
+        if (action_vx > 0)
+            agent->is_reflected = true;
+        if (action_vx < 0)
+            agent->is_reflected = false;
+
+        int ix = int(agent->x);
+        int iy = int(agent->y);
+
+        if (get_obj(ix, iy) == GOAL) {
+            set_obj(ix, iy, SPACE);
+            step_data.reward += REWARD;
+            step_data.level_complete = true;
+        }
+
+        step_data.done = step_data.reward > 0;
+    }
+
+    void serialize(WriteBuffer *b) override {
+        BasicAbstractGame::serialize(b);
+        b->write_int(maze_dim);
+        b->write_int(world_dim);
+    }
+
+    void deserialize(ReadBuffer *b) override {
+        BasicAbstractGame::deserialize(b);
+        maze_dim = b->read_int();
+        world_dim = b->read_int();
+    }
+};
+
+REGISTER_GAME(NAME, MazeGameStar);
diff --git a/procgenAISC/procgen/src/games/miner.cpp b/procgenAISC/procgen/src/games/miner.cpp
new file mode 100644
index 0000000..332b781
--- /dev/null
+++ b/procgenAISC/procgen/src/games/miner.cpp
@@ -0,0 +1,327 @@
+#include "../basic-abstract-game.h"
+#include "../assetgen.h"
+#include <set>
+#include <queue>
+
+const std::string NAME = "miner";
+
+const float COMPLETION_BONUS = 10.0;
+const int DIAMOND_REWARD = 1.0;
+
+const int BOULDER = 1;
+const int DIAMOND = 2;
+const int MOVING_BOULDER = 3;
+const int MOVING_DIAMOND = 4;
+const int ENEMY = 5;
+const int EXIT = 6;
+const int DIRT = 9;
+
+const int OOB_WALL = 10;
+
+class MinerGame : public BasicAbstractGame {
+  public:
+    int diamonds_remaining = 0;
+
+    MinerGame()
+        : BasicAbstractGame(NAME) {
+        main_width = 20;
+        main_height = 20;
+
+        mixrate = .5;
+        maxspeed = .5;
+        has_useful_vel_info = false;
+
+        out_of_bounds_object = OOB_WALL;
+        visibility = 8.0;
+    }
+
+    void load_background_images() override {
+        main_bg_images_ptr = &platform_backgrounds;
+    }
+
+    void asset_for_type(int type, std::vector<std::string> &names) override {
+        if (type == PLAYER) {
+            names.push_back("misc_assets/robot_greenDrive1.png");
+        } else if (type == BOULDER) {
+            names.push_back("misc_assets/elementStone007.png");
+        } else if (type == DIAMOND) {
+            names.push_back("misc_assets/gemBlue.png");
+        } else if (type == EXIT) {
+            names.push_back("misc_assets/window.png");
+        } else if (type == DIRT) {
+            names.push_back("misc_assets/dirt.png");
+        } else if (type == OOB_WALL) {
+            names.push_back("misc_assets/tile_bricksGrey.png");
+        }
+    }
+
+    bool is_blocked(const std::shared_ptr<Entity> &src, int target, bool is_horizontal) override {
+        if (BasicAbstractGame::is_blocked(src, target, is_horizontal))
+            return true;
+        if (src->type == PLAYER && (target == BOULDER || target == MOVING_BOULDER || target == OOB_WALL))
+            return true;
+
+        return false;
+    }
+
+    bool will_reflect(int src, int target) override {
+        return BasicAbstractGame::will_reflect(src, target) || (src == ENEMY && (target == BOULDER || target == DIAMOND || target == MOVING_BOULDER || target == MOVING_DIAMOND || target == out_of_bounds_object));
+    }
+
+    void handle_agent_collision(const std::shared_ptr<Entity> &obj) override {
+        BasicAbstractGame::handle_agent_collision(obj);
+
+        if (obj->type == ENEMY) {
+            step_data.done = true;
+        } else if (obj->type == EXIT) {
+            if (diamonds_remaining == 0) {
+                step_data.reward += COMPLETION_BONUS;
+                step_data.level_complete = true;
+                step_data.done = true;
+            }
+        }
+    }
+
+    int image_for_type(int type) override {
+        if (type == MOVING_BOULDER) {
+            return BOULDER;
+        } else if (type == MOVING_DIAMOND) {
+            return DIAMOND;
+        }
+
+        return BasicAbstractGame::image_for_type(type);
+    }
+
+    int get_agent_index() {
+        return int(agent->y) * main_width + int(agent->x);
+    }
+
+    void set_action_xy(int move_action) override {
+        BasicAbstractGame::set_action_xy(move_action);
+        if (action_vx != 0)
+            action_vy = 0;
+    }
+
+    void choose_new_vel(const std::shared_ptr<Entity> &ent) {
+        int is_horizontal = rand_gen.randbool();
+        int vel = rand_gen.randn(2) * 2 - 1;
+        if (is_horizontal) {
+            ent->vx = vel;
+            ent->vy = 0;
+        } else {
+            ent->vx = 0;
+            ent->vy = vel;
+        }
+    }
+
+    void choose_world_dim() override {
+        int dist_diff = options.distribution_mode;
+
+        if (dist_diff == EasyMode) {
+            main_width = 10;
+            main_height = 10;
+        } else if (dist_diff == HardMode) {
+            main_width = 20;
+            main_height = 20;
+        } else if (dist_diff == MemoryMode) {
+            main_width = 35;
+            main_height = 35;
+        }
+    }
+
+    void game_reset() override {
+        BasicAbstractGame::game_reset();
+
+        agent->rx = .5;
+        agent->ry = .5;
+
+        int main_area = main_height * main_width;
+
+        options.center_agent = options.distribution_mode == MemoryMode;
+        grid_step = true;
+
+        float diamond_pct = 12 / 400.0f;
+        float boulder_pct = 80 / 400.0f;
+
+        int num_diamonds = (int)(diamond_pct * grid_size);
+        int num_boulders = (int)(boulder_pct * grid_size);
+
+        std::vector<int> obj_idxs = rand_gen.simple_choose(main_area, num_diamonds + num_boulders + 1);
+
+        int agent_x = obj_idxs[0] % main_width;
+        int agent_y = obj_idxs[0] / main_width;
+
+        agent->x = agent_x + .5;
+        agent->y = agent_y + .5;
+
+        for (int i = 0; i < main_area; i++) {
+            set_obj(i, DIRT);
+        }
+
+        for (int i = 0; i < num_diamonds; i++) {
+            int cell = obj_idxs[i + 1];
+            set_obj(cell, DIAMOND);
+        }
+
+        for (int i = 0; i < num_boulders; i++) {
+            int cell = obj_idxs[i + 1 + num_diamonds];
+            set_obj(cell, BOULDER);
+        }
+
+        std::vector<int> dirt_cells = get_cells_with_type(DIRT);
+
+        set_obj(int(agent->x), int(agent->y), SPACE);
+
+        for (int i = -1; i <= 1; i++) {
+            for (int j = -1; j <= 1; j++) {
+                int ox = agent_x + i;
+                int oy = agent_y + j;
+                if (get_obj(ox, oy) == BOULDER) {
+                    set_obj(ox, oy, DIRT);
+                }
+            }
+        }
+
+        std::vector<int> exit_candidates;
+
+        for (int cell : dirt_cells) {
+            int above_obj = get_obj(cell + main_width);
+            if (above_obj == DIRT || above_obj == out_of_bounds_object) {
+                exit_candidates.push_back(cell);
+            }
+        }
+
+        fassert(exit_candidates.size() > 0);
+
+        int exit_cell = exit_candidates[rand_gen.randn((int)(exit_candidates.size()))];
+        set_obj(exit_cell, SPACE);
+        auto exit = add_entity((exit_cell % main_width) + .5, (exit_cell / main_width) + .5, 0, 0, .5, EXIT);
+        exit->render_z = -1;
+    }
+
+    int get_moving_type(int type) {
+        if (type == DIAMOND)
+            return MOVING_DIAMOND;
+        if (type == BOULDER)
+            return MOVING_BOULDER;
+
+        return type;
+    }
+
+    bool is_moving(int type) {
+        return type == MOVING_BOULDER || type == MOVING_DIAMOND;
+    }
+
+    int get_stationary_type(int type) {
+        if (type == MOVING_DIAMOND)
+            return DIAMOND;
+        if (type == MOVING_BOULDER)
+            return BOULDER;
+
+        return type;
+    }
+
+    bool is_free(int idx) {
+        return get_obj(idx) == SPACE && (get_agent_index() != idx);
+    }
+
+    bool is_round(int type) {
+        return type == BOULDER || type == MOVING_BOULDER || type == DIAMOND || type == MOVING_DIAMOND;
+    }
+
+    void handle_push() {
+        int agent_idx = get_agent_index();
+        int agentx = agent_idx % main_width;
+
+        if (action_vx == 1 && (agent->vx == 0) && (agentx < main_width - 2) && get_obj(agent_idx + 1) == BOULDER && get_obj(agent_idx + 2) == SPACE) {
+            set_obj(agent_idx + 1, SPACE);
+            set_obj(agent_idx + 2, BOULDER);
+            agent->x += 1;
+        } else if (action_vx == -1 && (agent->vx == 0) && (agentx > 1) && get_obj(agent_idx - 1) == BOULDER && get_obj(agent_idx - 2) == SPACE) {
+            set_obj(agent_idx - 1, SPACE);
+            set_obj(agent_idx - 2, BOULDER);
+            agent->x -= 1;
+        }
+    }
+
+    void game_step() override {
+        BasicAbstractGame::game_step();
+
+        if (action_vx > 0)
+            agent->is_reflected = false;
+        if (action_vx < 0)
+            agent->is_reflected = true;
+
+        handle_push();
+
+        int agent_obj = get_obj(int(agent->x), int(agent->y));
+
+        if (agent_obj == DIAMOND) {
+            step_data.reward += DIAMOND_REWARD;
+        }
+
+        if (agent_obj == DIRT || agent_obj == DIAMOND) {
+            set_obj(int(agent->x), int(agent->y), SPACE);
+        }
+
+        int main_area = main_width * main_height;
+
+        int diamonds_count = 0;
+
+        for (int idx = 0; idx < main_area; idx++) {
+            int obj = get_obj(idx);
+
+            int obj_x = idx % main_width;
+            int agent_idx = (agent->y - .5) * main_width + (agent->x - .5);
+
+            int stat_type = get_stationary_type(obj);
+
+            if (stat_type == DIAMOND) {
+                diamonds_count++;
+            }
+
+            if (obj == BOULDER || obj == MOVING_BOULDER || obj == DIAMOND || obj == MOVING_DIAMOND) {
+                int below_idx = idx - main_width;
+                int obj2 = get_obj(below_idx);
+                bool agent_is_below = agent_idx == below_idx;
+
+                if (obj2 == SPACE && !agent_is_below) {
+                    set_obj(idx, SPACE);
+                    set_obj(below_idx, get_moving_type(obj));
+                } else if (agent_is_below && is_moving(obj)) {
+                    step_data.done = true;
+                } else if (is_round(obj2) && obj_x > 0 && is_free(idx - 1) && is_free(idx - main_width - 1)) {
+                    set_obj(idx, SPACE);
+                    set_obj(idx - 1, get_stationary_type(obj));
+                } else if (is_round(obj2) && obj_x < main_width - 1 && is_free(idx + 1) && is_free(idx - main_width + 1)) {
+                    set_obj(idx, SPACE);
+                    set_obj(idx + 1, stat_type);
+                } else {
+                    set_obj(idx, stat_type);
+                }
+            }
+        }
+
+        diamonds_remaining = diamonds_count;
+
+        for (auto ent : entities) {
+            if (ent->type == ENEMY) {
+                if (rand_gen.randn(6) == 0) {
+                    choose_new_vel(ent);
+                }
+            }
+        }
+    }
+
+    void serialize(WriteBuffer *b) override {
+        BasicAbstractGame::serialize(b);
+        b->write_int(diamonds_remaining);
+    }
+
+    void deserialize(ReadBuffer *b) override {
+        BasicAbstractGame::deserialize(b);
+        diamonds_remaining = b->read_int();
+    }
+};
+
+REGISTER_GAME(NAME, MinerGame);
\ No newline at end of file
diff --git a/procgenAISC/procgen/src/games/ninja.cpp b/procgenAISC/procgen/src/games/ninja.cpp
new file mode 100644
index 0000000..df1f78b
--- /dev/null
+++ b/procgenAISC/procgen/src/games/ninja.cpp
@@ -0,0 +1,438 @@
+#include "../basic-abstract-game.h"
+#include "../assetgen.h"
+#include <set>
+#include <queue>
+#include "../mazegen.h"
+
+const std::string NAME = "ninja";
+
+const float GOAL_REWARD = 10.0f;
+
+const int GOAL = 1;
+const int BOMB = 6;
+const int THROWING_STAR = 7;
+
+const int PLAYER_JUMP = 9;
+const int PLAYER_RIGHT1 = 12;
+const int PLAYER_RIGHT2 = 13;
+const int FIRE = 14;
+
+const int WALL_MID = 20;
+const int NUM_WALL_THEMES = 3;
+
+class Ninja : public BasicAbstractGame {
+  public:
+    bool has_support = false;
+    bool facing_right = false;
+    int last_fire_time = 0;
+    int wall_theme = 0;
+    float gravity = 0.0f;
+    float air_control = 0.0f;
+    float jump_charge = 0.0f;
+    float jump_charge_inc = 0.0f;
+
+    Ninja()
+        : BasicAbstractGame(NAME) {
+        main_width = 64;
+        main_height = 64;
+
+        out_of_bounds_object = WALL_MID;
+    }
+
+    void load_background_images() override {
+        main_bg_images_ptr = &platform_backgrounds;
+    }
+
+    void asset_for_type(int type, std::vector<std::string> &names) override {
+        std::shared_ptr<QImage> asset_ptr = nullptr;
+
+        if (type == WALL_MID) {
+            names.push_back("misc_assets/tile_bricksGrey.png");
+            names.push_back("misc_assets/tile_bricksGrown.png");
+            names.push_back("misc_assets/tile_bricksRed.png");
+        } else if (type == GOAL) {
+            names.push_back("platformer/shroom1.png");
+            names.push_back("platformer/shroom2.png");
+            names.push_back("platformer/shroom3.png");
+            names.push_back("platformer/shroom4.png");
+            names.push_back("platformer/shroom5.png");
+            names.push_back("platformer/shroom6.png");
+        } else if (type == PLAYER) {
+            names.push_back("platformer/zombie_idle.png");
+        } else if (type == PLAYER_JUMP) {
+            names.push_back("platformer/zombie_jump.png");
+        } else if (type == PLAYER_RIGHT1) {
+            names.push_back("platformer/zombie_walk1.png");
+        } else if (type == PLAYER_RIGHT2) {
+            names.push_back("platformer/zombie_walk2.png");
+        } else if (type == BOMB) {
+            names.push_back("misc_assets/bomb.png");
+        } else if (type == THROWING_STAR) {
+            names.push_back("misc_assets/saw.png");
+        } else if (type == FIRE) {
+            names.push_back("misc_assets/bomb.png");
+        }
+    }
+
+    void handle_agent_collision(const std::shared_ptr<Entity> &obj) override {
+        BasicAbstractGame::handle_agent_collision(obj);
+
+        if (obj->type == EXPLOSION) {
+            step_data.done = true;
+        } else if (obj->type == GOAL) {
+            step_data.reward += GOAL_REWARD;
+            step_data.level_complete = true;
+            step_data.done = true;
+        }
+    }
+
+    void handle_grid_collision(const std::shared_ptr<Entity> &obj, int type, int i, int j) override {
+        if (obj->type == PLAYER) {
+            if (type == FIRE) {
+                step_data.done = true;
+            } else if (type == BOMB) {
+                step_data.done = true;
+            }
+        } else if (obj->type == THROWING_STAR) {
+            if (type == BOMB) {
+                obj->will_erase = true;
+                set_obj(i, j, SPACE);
+                add_entity(i + .5, j + .5, 0, 0, .5, EXPLOSION);
+            }
+            if (is_wall(type)) {
+                obj->will_erase = true;
+            }
+        }
+    }
+
+    void update_agent_velocity() override {
+        float mixrate_x = has_support ? mixrate : (mixrate * air_control);
+        agent->vx = (1 - mixrate_x) * agent->vx + mixrate_x * maxspeed * action_vx;
+
+        if (action_vy < 1 && jump_charge > 0) {
+            agent->vy = jump_charge * max_jump;
+            jump_charge = 0;
+        }
+
+        if (!has_support) {
+            if (agent->vy > -2) {
+                agent->vy -= gravity;
+            }
+        }
+    }
+
+    bool is_wall(int type) {
+        return type == WALL_MID;
+    }
+
+    int theme_for_grid_obj(int type) override {
+        if (is_wall(type))
+            return wall_theme;
+
+        return 0;
+    }
+
+    bool use_block_asset(int type) override {
+        return BasicAbstractGame::use_block_asset(type) || is_wall(type);
+    }
+
+    bool is_blocked(const std::shared_ptr<Entity> &src, int target, bool is_horizontal) override {
+        if (is_wall(target)) {
+            if (src->type == PLAYER) {
+                return true;
+            } else if (src->type == THROWING_STAR) {
+                // throwing stars stick to walls
+                src->vx = 0;
+                src->vy = 0;
+                return true;
+            }
+        }
+
+        return BasicAbstractGame::is_blocked(src, target, is_horizontal);
+    }
+
+    int image_for_type(int type) override {
+        if (type == PLAYER) {
+            if (fabs(agent->vx) < .01 && action_vx == 0 && has_support) {
+                return PLAYER;
+            } else {
+                return (cur_time / 5 % 2 == 0 || !has_support) ? PLAYER_RIGHT1 : PLAYER_RIGHT2;
+            }
+        }
+
+        return BasicAbstractGame::image_for_type(type);
+    }
+
+    void game_draw(QPainter &p, const QRect &rect) override {
+        BasicAbstractGame::game_draw(p, rect);
+
+        QColor charge_color = QColor(66, 245, 135);
+
+        float bar_height = 3 * jump_charge;
+
+        QRectF dist_rect2 = get_abs_rect(.25, visibility - .5 - bar_height, .5, bar_height);
+        p.fillRect(dist_rect2, charge_color);
+    }
+
+    void fill_block_top(int x, int y, int dx, int dy, char fill, char top) {
+        if (dy <= 0)
+            return;
+        fill_elem(x, y, dx, dy - 1, fill);
+        fill_elem(x, y + dy - 1, dx, 1, top);
+    }
+
+    void fill_ground_block(int x, int y, int dx, int dy) {
+        fill_block_top(x, y, dx, dy, WALL_MID, WALL_MID);
+    }
+
+    void init_floor_and_walls() {
+        fill_elem(0, 0, main_width, 1, WALL_MID);
+        fill_elem(0, 0, 1, main_height, WALL_MID);
+        fill_elem(main_width - 1, 0, 1, main_height, WALL_MID);
+        fill_elem(0, main_height - 1, main_width, 1, WALL_MID);
+    }
+
+    void generate_coin_to_the_right(int difficulty) {
+        int min_gap = difficulty - 1;
+        int min_plat_w = 1;
+        int inc_dy = 4;
+
+        if (options.distribution_mode == EasyMode) {
+            min_gap -= 1;
+            if (min_gap < 0)
+                min_gap = 0;
+            min_plat_w = 3;
+            inc_dy = 2;
+        }
+
+        float bomb_prob = .25 * (difficulty - 1);
+        int max_gap_inc = difficulty == 1 ? 1 : 2;
+
+        int num_sections = rand_gen.randn(difficulty) + difficulty;
+        int start_x = 5;
+        int curr_x = start_x;
+        int curr_y = main_height / 2;
+        int min_y = curr_y;
+
+        int w = main_width;
+
+        float _max_dy = max_jump * max_jump / (2 * gravity);
+
+        int max_dy = (_max_dy - .5);
+
+        int prev_x;
+        int prev_y;
+
+        fill_ground_block(0, 0, start_x, curr_y);
+        fill_elem(0, curr_y + 8, start_x, main_height - curr_y - 8, WALL_MID);
+
+        for (int i = 0; i < num_sections; i++) {
+            prev_x = curr_x;
+            prev_y = curr_y;
+            int num_edges = rand_gen.randn(2) + 1;
+            int max_y = -1;
+            int last_edge_y = -1;
+
+            for (int j = 0; j < num_edges; j++) {
+                curr_x = prev_x + j;
+
+                if (curr_x + 15 >= w) {
+                    break;
+                }
+
+                curr_y = prev_y;
+
+                int dy = rand_gen.randn(inc_dy) + 1 + int(difficulty / 3);
+
+                if (dy > max_dy) {
+                    dy = max_dy;
+                }
+
+                if (curr_y >= main_height - 15) {
+                    dy *= -1;
+                } else if (curr_y >= 5 && rand_gen.rand01() < .4) {
+                    dy *= -1;
+                }
+
+                curr_y += dy;
+
+                if (curr_y < 3) {
+                    curr_y = 3;
+                }
+
+                if (abs(curr_y - last_edge_y) <= 1) {
+                    curr_y = last_edge_y + 2;
+                }
+
+                int dx = min_plat_w + rand_gen.randn(3);
+
+                fill_ground_block(curr_x, curr_y - 1, dx, 1);
+
+                curr_x += dx;
+                curr_x += min_gap + rand_gen.randn(max_gap_inc + 1);
+
+                if (curr_y > max_y)
+                    max_y = curr_y;
+                if (curr_y < min_y)
+                    min_y = curr_y;
+
+                last_edge_y = curr_y;
+            }
+
+            if (rand_gen.rand01() < bomb_prob) {
+                set_obj(rand_gen.randn(curr_x - prev_x + 1) + prev_x, max_y + 2, BOMB);
+            }
+
+            int ceiling_height = 11;
+            int ceiling_start = max_y - 1 + ceiling_height;
+
+            fill_ground_block(prev_x, ceiling_start, curr_x - prev_x, main_height - ceiling_start);
+        }
+
+        auto ent = add_entity(curr_x + .5, curr_y + .5, 0, 0, .5, GOAL);
+        choose_random_theme(ent);
+
+        fill_ground_block(curr_x, curr_y - 1, 1, 1);
+        fill_elem(curr_x, curr_y + 6, 1, main_height - curr_y - 6, WALL_MID);
+
+        int fire_y = min_y - 2;
+        if (fire_y < 1)
+            fire_y = 1;
+
+        fill_ground_block(start_x, 0, main_width - start_x, fire_y);
+        fill_elem(start_x, fire_y, main_width - start_x, 1, FIRE);
+        fill_elem(curr_x + 1, 0, main_width - curr_x - 1, main_height, WALL_MID);
+    }
+
+    void game_reset() override {
+        BasicAbstractGame::game_reset();
+
+        gravity = 0.2f;
+        max_jump = 1.5;
+        air_control = 0.15f;
+        maxspeed = .5;
+        has_support = false;
+        facing_right = true;
+        jump_charge = 0;
+        jump_charge_inc = .25;
+        visibility = 16;
+
+        agent->rx = .5;
+        agent->ry = .5;
+
+        agent->x = 1 + agent->rx;
+        agent->y = main_height / 2 + agent->ry;
+
+        if (options.distribution_mode == EasyMode) {
+            max_jump = 1.25;
+            jump_charge_inc = 1;
+            visibility = 10;
+        }
+
+        int max_difficulty = 3;
+        int difficulty = rand_gen.randn(max_difficulty) + 1;
+
+        last_fire_time = 0;
+
+        wall_theme = rand_gen.randn(NUM_WALL_THEMES);
+
+        init_floor_and_walls();
+        generate_coin_to_the_right(difficulty);
+    }
+
+    bool can_support(int obj) {
+        return is_wall(obj) || obj == out_of_bounds_object;
+    }
+
+    void set_action_xy(int move_action) override {
+        action_vx = move_action / 3 - 1;
+        action_vy = (move_action % 3) - 1;
+        if (action_vy < 0)
+            action_vy = 0;
+
+        if (action_vx > 0)
+            facing_right = true;
+        if (action_vx < 0)
+            facing_right = false;
+
+        int obj_below_1 = get_obj_from_floats(agent->x - (agent->rx - .01), agent->y - (agent->ry + .01));
+        int obj_below_2 = get_obj_from_floats(agent->x + (agent->rx - .01), agent->y - (agent->ry + .01));
+
+        has_support = can_support(obj_below_1) || can_support(obj_below_2);
+
+        if (has_support && action_vy == 1) {
+            action_vy = 1;
+            jump_charge += jump_charge_inc;
+
+            if (jump_charge > 1) {
+                jump_charge = 1;
+            }
+        } else {
+            action_vy = 0;
+        }
+
+        if (!has_support) {
+            jump_charge = 0;
+        }
+    }
+
+    void game_step() override {
+        BasicAbstractGame::game_step();
+
+        if (action_vx > 0)
+            agent->is_reflected = false;
+        if (action_vx < 0)
+            agent->is_reflected = true;
+
+        if (special_action > 0 && (cur_time - last_fire_time) >= 3) {
+            float theta = 0;
+            float bullet_vel = 1;
+
+            if (special_action == 1) {
+                theta = 0;
+            } else if (special_action == 2) {
+                theta = PI / 4;
+            } else if (special_action == 3) {
+                theta = PI / 2;
+            } else if (special_action == 4) {
+                theta = -1 * PI / 4;
+            }
+
+            if (agent->is_reflected) {
+                theta = PI - theta;
+            }
+
+            auto new_bullet = add_entity(agent->x, agent->y, bullet_vel * cos(theta), bullet_vel * sin(theta), .25, THROWING_STAR);
+            new_bullet->collides_with_entities = true;
+            new_bullet->expire_time = 15;
+            new_bullet->smart_step = true;
+            last_fire_time = cur_time;
+        }
+    }
+
+    void serialize(WriteBuffer *b) override {
+        BasicAbstractGame::serialize(b);
+        b->write_bool(has_support);
+        b->write_bool(facing_right);
+        b->write_int(last_fire_time);
+        b->write_int(wall_theme);
+        b->write_float(gravity);
+        b->write_float(air_control);
+        b->write_float(jump_charge);
+        b->write_float(jump_charge_inc);
+    }
+
+    void deserialize(ReadBuffer *b) override {
+        BasicAbstractGame::deserialize(b);
+        has_support = b->read_bool();
+        facing_right = b->read_bool();
+        last_fire_time = b->read_int();
+        wall_theme = b->read_int();
+        gravity = b->read_float();
+        air_control = b->read_float();
+        jump_charge = b->read_float();
+        jump_charge_inc = b->read_float();
+    }
+};
+
+REGISTER_GAME(NAME, Ninja);
diff --git a/procgenAISC/procgen/src/games/plunder.cpp b/procgenAISC/procgen/src/games/plunder.cpp
new file mode 100644
index 0000000..200752f
--- /dev/null
+++ b/procgenAISC/procgen/src/games/plunder.cpp
@@ -0,0 +1,280 @@
+#include "../basic-abstract-game.h"
+#include "../assetgen.h"
+#include <set>
+#include <queue>
+
+const std::string NAME = "plunder";
+
+const float COMPLETION_BONUS = 10.0f;
+const float POSITIVE_REWARD = 1.0f;
+
+const int PLAYER_BULLET = 1;
+const int TARGET_LEGEND = 2;
+const int TARGET_BACKGROUND = 3;
+const int PANEL = 6;
+const int SHIP = 7;
+
+class PlunderGame : public BasicAbstractGame {
+  public:
+    int last_fire_time = 0;
+    std::vector<bool> lane_directions, target_bools;
+    std::vector<int> image_permutation;
+    std::vector<float> lane_vels;
+    int num_lanes = 0;
+    int num_current_ship_types = 0;
+    int targets_hit = 0;
+    int target_quota = 0;
+    float juice_left = 0.0f;
+    float r_scale = 0.0f;
+    float spawn_prob = 0.0f;
+    float legend_r = 0.0f;
+    float min_agent_x = 0.0f;
+
+    PlunderGame()
+        : BasicAbstractGame(NAME) {
+        timeout = 4000;
+
+        main_width = 20;
+        main_height = 20;
+
+        mixrate = .5;
+        maxspeed = 0.85f;
+        has_useful_vel_info = false;
+    }
+
+    void load_background_images() override {
+        main_bg_images_ptr = &water_surface_backgrounds;
+    }
+
+    void asset_for_type(int type, std::vector<std::string> &names) override {
+        if (type == SHIP) {
+            names.push_back("misc_assets/ship_1.png");
+            names.push_back("misc_assets/ship_2.png");
+            names.push_back("misc_assets/ship_3.png");
+            names.push_back("misc_assets/ship_4.png");
+            names.push_back("misc_assets/ship_5.png");
+            names.push_back("misc_assets/ship_6.png");
+        } else if (type == PLAYER_BULLET) {
+            names.push_back("misc_assets/cannonBall.png");
+        } else if (type == PANEL) {
+            names.push_back("misc_assets/panel_wood.png");
+        } else if (type == TARGET_BACKGROUND) {
+            names.push_back("misc_assets/target_red2.png");
+        }
+    }
+
+    void game_draw(QPainter &p, const QRect &rect) override {
+        BasicAbstractGame::game_draw(p, rect);
+
+        QColor juice_color = QColor(66, 245, 135);
+        QColor progress_color = QColor(245, 66, 144);
+
+        QRectF dist_rect1 = get_abs_rect(.25, .25, main_width * juice_left, .5);
+        p.fillRect(dist_rect1, juice_color);
+
+        QRectF dist_rect2 = get_abs_rect(.25, .75, main_width * (targets_hit * 1.0 / target_quota), .5);
+        p.fillRect(dist_rect2, progress_color);
+    }
+
+    bool is_target(int theme_num) {
+        return target_bools[theme_num];
+    }
+
+    bool should_preserve_type_themes(int type) override {
+        return type == SHIP;
+    }
+
+    void handle_collision(const std::shared_ptr<Entity> &src, const std::shared_ptr<Entity> &target) override {
+        if (src->type == PLAYER_BULLET) {
+            if (target->type == SHIP) {
+                target->will_erase = true;
+                src->will_erase = true;
+
+                if (is_target(target->image_theme)) {
+                    targets_hit += 1;
+                    step_data.reward += POSITIVE_REWARD;
+                    juice_left += 0.1f;
+                } else {
+                    juice_left -= 0.1f;
+                }
+            } else if (target->type == PANEL) {
+                src->will_erase = true;
+            }
+
+            if (target->will_erase) {
+                add_entity(target->x, target->y, target->vx / 2, target->vy / 2, .5 * target->rx, EXPLOSION);
+            }
+        }
+    }
+
+    void set_action_xy(int move_action) override {
+        action_vx = move_action / 3 - 1;
+        action_vy = 0;
+        action_vrot = 0;
+    }
+
+    void game_reset() override {
+        BasicAbstractGame::game_reset();
+
+        agent->image_type = SHIP;
+
+        juice_left = 1;
+        targets_hit = 0;
+        target_quota = 20;
+        spawn_prob = 0.06f;
+        r_scale = options.distribution_mode == EasyMode ? 1.5f : 1.0f;
+        int num_total_ship_types = 6;
+
+        num_lanes = 5;
+        lane_directions.clear();
+        lane_vels.clear();
+        target_bools.clear();
+
+        std::vector<int> image_idxs;
+
+        for (int i = 0; i < num_total_ship_types; i++) {
+            image_idxs.push_back(i);
+        }
+
+        image_permutation = rand_gen.choose_n(image_idxs, num_total_ship_types);
+
+        num_current_ship_types = 2;
+
+        for (int i = 0; i < num_total_ship_types; i++) {
+            target_bools.push_back(false);
+        }
+
+        for (int i = 0; i < num_current_ship_types / 2; i++) {
+            target_bools[image_permutation[i]] = true;
+        }
+
+        for (int i = 0; i < num_lanes; i++) {
+            lane_directions.push_back(rand_gen.rand01() < .5);
+            lane_vels.push_back(.15 + .1 * rand_gen.rand01());
+        }
+
+        int num_panels = options.distribution_mode == EasyMode ? 0 : rand_gen.randn(4);
+        float panel_width = 1.2f;
+
+        if (panel_width > 0) {
+            for (int i = 0; i < num_panels; i++) {
+                spawn_entity_rxy(panel_width, .5, PANEL, 0, .25 * main_height, main_width, .25 * main_height);
+            }
+        }
+
+        float key_scale = 1.5;
+        legend_r = 2;
+
+        add_entity(legend_r, legend_r, 0, 0, legend_r, TARGET_BACKGROUND);
+
+        auto ent = add_entity(legend_r, legend_r, 0, 0, r_scale * key_scale, TARGET_LEGEND);
+        ent->image_theme = image_permutation[0];
+        ent->image_type = SHIP;
+        match_aspect_ratio(ent);
+        ent->rotation = PI / 2;
+
+        last_fire_time = 0;
+
+        options.center_agent = false;
+
+        agent->rx = r_scale;
+        agent->rotation = -1 * PI / 2;
+        agent->image_theme = image_permutation[rand_gen.randn(num_current_ship_types / 2) + num_current_ship_types / 2];
+        match_aspect_ratio(agent);
+        reposition_agent();
+        agent->y = 1 + agent->ry;
+
+        min_agent_x = 2 * legend_r + agent->rx;
+
+        if (agent->x < min_agent_x) {
+            agent->x = min_agent_x;
+        }
+    }
+
+    void game_step() override {
+        BasicAbstractGame::game_step();
+
+        juice_left -= 0.0015f;
+
+        if (rand_gen.rand01() < spawn_prob) {
+            float ent_r = r_scale;
+            int lane = rand_gen.randn(num_lanes);
+            float ent_y = (lane * .11 + .4) * (main_height / 2 - ent_r) + main_height / 2;
+            float moves_right = lane_directions[lane];
+            float ent_vx = lane_vels[lane] * (moves_right ? 1 : -1);
+            auto ent = std::make_shared<Entity>(0, ent_y, ent_vx, 0, ent_r, SHIP);
+            ent->image_type = SHIP;
+            ent->image_theme = image_permutation[rand_gen.randn(num_current_ship_types)];
+            match_aspect_ratio(ent);
+            ent->x = moves_right ? -1 * ent_r : (main_width + ent_r);
+            ent->is_reflected = !moves_right;
+
+            if (!has_any_collision(ent)) {
+                entities.push_back(ent);
+            }
+        }
+
+        if (special_action == 1 && (cur_time - last_fire_time) >= 3) {
+            auto new_bullet = add_entity(agent->x, agent->y, 0, 1, .25, PLAYER_BULLET);
+            new_bullet->collides_with_entities = true;
+            new_bullet->expire_time = 50;
+            last_fire_time = cur_time;
+            juice_left -= 0.02f;
+        }
+
+        if (juice_left <= 0) {
+            step_data.done = true;
+        } else if (juice_left >= 1) {
+            juice_left = 1;
+        }
+
+        if (targets_hit >= target_quota) {
+            step_data.done = true;
+            step_data.reward += COMPLETION_BONUS;
+            step_data.level_complete = true;
+        }
+
+        // don't collide with legend
+        if (agent->x < min_agent_x) {
+            agent->x = min_agent_x;
+        }
+    }
+
+    void serialize(WriteBuffer *b) override {
+        BasicAbstractGame::serialize(b);
+        b->write_int(last_fire_time);
+        b->write_vector_bool(lane_directions);
+        b->write_vector_bool(target_bools);
+        b->write_vector_int(image_permutation);
+        b->write_vector_float(lane_vels);
+        b->write_int(num_lanes);
+        b->write_int(num_current_ship_types);
+        b->write_int(targets_hit);
+        b->write_int(target_quota);
+        b->write_float(juice_left);
+        b->write_float(r_scale);
+        b->write_float(spawn_prob);
+        b->write_float(legend_r);
+        b->write_float(min_agent_x);
+    }
+
+    void deserialize(ReadBuffer *b) override {
+        BasicAbstractGame::deserialize(b);
+        last_fire_time = b->read_int();
+        lane_directions = b->read_vector_bool();
+        target_bools = b->read_vector_bool();
+        image_permutation = b->read_vector_int();
+        lane_vels = b->read_vector_float();
+        num_lanes = b->read_int();
+        num_current_ship_types = b->read_int();
+        targets_hit = b->read_int();
+        target_quota = b->read_int();
+        juice_left = b->read_float();
+        r_scale = b->read_float();
+        spawn_prob = b->read_float();
+        legend_r = b->read_float();
+        min_agent_x = b->read_float();
+    }
+};
+
+REGISTER_GAME(NAME, PlunderGame);
diff --git a/procgenAISC/procgen/src/games/starpilot.cpp b/procgenAISC/procgen/src/games/starpilot.cpp
new file mode 100644
index 0000000..9ea93e0
--- /dev/null
+++ b/procgenAISC/procgen/src/games/starpilot.cpp
@@ -0,0 +1,445 @@
+#include "../basic-abstract-game.h"
+#include "../assetgen.h"
+
+const std::string NAME = "starpilot";
+
+const float V_SCALE = 2.0f / 5.0f;
+
+const float BG_RATIO = 18;
+const float ENEMY_REWARD = 1.0;
+const float COMPLETION_BONUS = 10.0;
+
+const int BULLET_PLAYER = 1;
+const int BULLET2 = 2;
+const int BULLET3 = 3;
+const int FLYER = 4;
+const int METEOR = 5;
+const int CLOUD = 6;
+const int TURRET = 7;
+const int FAST_FLYER = 8;
+
+const int FINISH_LINE = 9;
+
+const int SHOOTER_WIN_TIME = 500;
+
+const int NUM_BASIC_OBJECTS = 9;
+const int NUM_SHIP_THEMES = 7;
+
+bool spawn_cmp(const std::shared_ptr<Entity> &x, const std::shared_ptr<Entity> &y) {
+    return (x->spawn_time > y->spawn_time);
+}
+
+class StarPilotGame : public BasicAbstractGame {
+  public:
+    std::vector<std::shared_ptr<Entity>> spawners;
+
+    float hp_vs[NUM_BASIC_OBJECTS] = {};
+    float hp_healths[NUM_BASIC_OBJECTS] = {};
+    float hp_bullet_r[NUM_BASIC_OBJECTS] = {};
+    float hp_object_r[NUM_BASIC_OBJECTS] = {};
+    float hp_object_prob_weight[NUM_BASIC_OBJECTS] = {};
+    float total_prob_weight = 0.0f;
+    float hp_slow_v = 0.0f;
+    float hp_weapon_bullet_dist = 0.0f;
+    float hp_spawn_right_threshold = 0.0f;
+
+    int hp_min_enemy_delta_t = 0;
+    int hp_max_group_size = 0;
+    int hp_max_enemy_delta_t = 0;
+
+    StarPilotGame()
+        : BasicAbstractGame(NAME) {
+        main_width = 16;
+        main_height = 16;
+    }
+
+    void load_background_images() override {
+        main_bg_images_ptr = &space_backgrounds;
+    }
+
+    void asset_for_type(int type, std::vector<std::string> &names) override {
+        if (type == PLAYER) {
+            names.push_back("misc_assets/playerShip2_blue.png");
+        } else if (type == BULLET_PLAYER) {
+            names.push_back("misc_assets/towerDefense_tile295.png");
+        } else if (type == BULLET2) {
+            names.push_back("misc_assets/towerDefense_tile296.png");
+        } else if (type == BULLET3) {
+            names.push_back("misc_assets/towerDefense_tile297.png");
+        } else if (type == FLYER || type == FAST_FLYER) {
+            names.push_back("misc_assets/spaceShips_001.png");
+            names.push_back("misc_assets/spaceShips_002.png");
+            names.push_back("misc_assets/spaceShips_003.png");
+            names.push_back("misc_assets/spaceShips_004.png");
+            names.push_back("misc_assets/spaceShips_005.png");
+            names.push_back("misc_assets/spaceShips_006.png");
+            names.push_back("misc_assets/spaceShips_007.png");
+        } else if (type == METEOR) {
+            names.push_back("misc_assets/spaceMeteors_001.png");
+            names.push_back("misc_assets/spaceMeteors_002.png");
+            names.push_back("misc_assets/spaceMeteors_003.png");
+            names.push_back("misc_assets/spaceMeteors_004.png");
+            names.push_back("misc_assets/meteorGrey_big1.png");
+            names.push_back("misc_assets/meteorGrey_big2.png");
+            names.push_back("misc_assets/meteorGrey_big3.png");
+            names.push_back("misc_assets/meteorGrey_big4.png");
+        } else if (type == CLOUD) {
+            names.push_back("misc_assets/spaceEffect1.png");
+            names.push_back("misc_assets/spaceEffect2.png");
+            names.push_back("misc_assets/spaceEffect3.png");
+            names.push_back("misc_assets/spaceEffect4.png");
+            names.push_back("misc_assets/spaceEffect5.png");
+            names.push_back("misc_assets/spaceEffect6.png");
+            names.push_back("misc_assets/spaceEffect7.png");
+            names.push_back("misc_assets/spaceEffect8.png");
+            names.push_back("misc_assets/spaceEffect9.png");
+        } else if (type == TURRET) {
+            names.push_back("misc_assets/spaceStation_018.png");
+            names.push_back("misc_assets/spaceStation_019.png");
+        } else if (type == FINISH_LINE) {
+            names.push_back("misc_assets/spaceRockets_001.png");
+            names.push_back("misc_assets/spaceRockets_002.png");
+            names.push_back("misc_assets/spaceRockets_003.png");
+            names.push_back("misc_assets/spaceRockets_004.png");
+        }
+    }
+
+    void game_draw(QPainter &p, const QRect &rect) override {
+        float scale = rect.height() / main_height;
+
+        QColor bg_color = QColor(0, 0, 0);
+
+        p.fillRect(rect, bg_color);
+
+        if (options.use_backgrounds) {
+            float bg_k = 3;
+            float t = cur_time;
+            float x_off = -t * scale * hp_slow_v * 2 / char_dim;
+
+            QRectF r_bg = QRectF(x_off, -rect.height() * (bg_k - 1) / 2, rect.height() * bg_k * BG_RATIO, rect.height() * bg_k);
+            tile_image(p, main_bg_images_ptr->at(background_index).get(), r_bg, 1);
+        }
+
+        draw_foreground(p, rect);
+    }
+
+    void handle_agent_collision(const std::shared_ptr<Entity> &obj) override {
+        BasicAbstractGame::handle_agent_collision(obj);
+
+        if (obj->type == FINISH_LINE) {
+            step_data.done = true;
+            step_data.reward += COMPLETION_BONUS;
+            step_data.level_complete = true;
+        } else if (is_lethal(obj)) {
+            step_data.done = true;
+        }
+    }
+
+    void handle_collision(const std::shared_ptr<Entity> &src, const std::shared_ptr<Entity> &target) override {
+        if (src->type == BULLET_PLAYER && target->type != CLOUD && is_destructible(target->type)) {
+            src->will_erase = true;
+            target->health -= 1;
+
+            add_entity(src->x, src->y, target->vx, target->vy, .5 * src->rx, EXPLOSION);
+        }
+    }
+
+    void init_hps() {
+        float scale = 1;
+
+        for (int i = 0; i < NUM_BASIC_OBJECTS; i++) {
+            hp_vs[i] = 1;
+            hp_healths[i] = 0;
+            hp_object_prob_weight[i] = 1;
+            hp_object_r[i] = scale / 2;
+        }
+
+        float default_bullet_r = scale / 2.5;
+
+        if (options.distribution_mode == EasyMode) {
+            hp_object_prob_weight[METEOR] = 0;
+            hp_object_prob_weight[CLOUD] = 0;
+            hp_object_prob_weight[TURRET] = 0;
+            hp_object_prob_weight[FAST_FLYER] = 0;
+            hp_vs[FLYER] = .75;
+            hp_vs[BULLET2] = 1.25;
+            hp_healths[TURRET] = 5;
+            hp_healths[FLYER] = 2;
+            hp_healths[FAST_FLYER] = 1;
+            maxspeed = 0.75;
+        } else if (options.distribution_mode == HardMode) {
+            hp_vs[BULLET2] = 2;
+
+            hp_healths[TURRET] = 5;
+            hp_healths[FLYER] = 2;
+            hp_healths[FAST_FLYER] = 1;
+            maxspeed = 0.75;
+        } else if (options.distribution_mode == ExtremeMode) {
+            hp_vs[BULLET2] = 2;
+            hp_healths[TURRET] = 10;
+            hp_healths[FLYER] = 5;
+            hp_healths[FAST_FLYER] = 2;
+            maxspeed = 0.5;
+            default_bullet_r = scale / 5;
+        } else {
+            fassert(false);
+        }
+
+        for (int i = 0; i < NUM_BASIC_OBJECTS; i++) {
+            hp_bullet_r[i] = default_bullet_r;
+        }
+
+        hp_healths[METEOR] = 500;
+
+        hp_vs[FAST_FLYER] = 1.5;
+
+        hp_vs[BULLET_PLAYER] = 2;
+
+        hp_vs[BULLET3] = 2;
+        hp_object_r[TURRET] = scale * 2;
+        hp_object_r[METEOR] = scale * 2;
+        hp_object_r[CLOUD] = scale * 2;
+
+        hp_object_prob_weight[FLYER] = 3;
+
+        hp_slow_v = .5;
+        hp_max_group_size = 5;
+
+        hp_weapon_bullet_dist = 3;
+
+        hp_min_enemy_delta_t = 10;
+        hp_max_enemy_delta_t = hp_min_enemy_delta_t + 20;
+
+        hp_spawn_right_threshold = 0.9f;
+
+        hp_object_prob_weight[BULLET_PLAYER] = 0;
+        hp_object_prob_weight[BULLET2] = 0;
+        hp_object_prob_weight[BULLET3] = 0;
+
+        total_prob_weight = 0;
+
+        for (int i = 2; i < NUM_BASIC_OBJECTS; i++) {
+            total_prob_weight += hp_object_prob_weight[i];
+        }
+    }
+
+    void add_spawners() {
+        int t = 1 + rand_gen.randint(hp_min_enemy_delta_t, hp_max_enemy_delta_t);
+
+        bool can_spawn_left = options.distribution_mode != EasyMode;
+
+        for (int i = 0; t <= SHOOTER_WIN_TIME; i++) {
+            int group_size = 1;
+            float start_weight = rand_gen.rand01() * total_prob_weight;
+            float curr_weight = start_weight;
+            int type;
+
+            for (type = 2; type < NUM_BASIC_OBJECTS; type++) {
+                curr_weight -= hp_object_prob_weight[type];
+
+                if (curr_weight <= 0) {
+                    break;
+                }
+            }
+
+            if (type >= NUM_BASIC_OBJECTS) {
+                type = NUM_BASIC_OBJECTS - 1;
+            }
+
+            float r = hp_object_r[type];
+            int flyer_theme = 0;
+
+            if (type == FLYER || type == FAST_FLYER) {
+                group_size = rand_gen.randint(0, hp_max_group_size) + 1;
+                flyer_theme = rand_gen.randn(NUM_SHIP_THEMES);
+            }
+
+            float y_pos = rand_pos(r, main_height);
+
+            for (int j = 0; j < group_size; j++) {
+                int spawn_time = t + j * 5;
+                int fire_time = rand_gen.randint(10, 100);
+
+                float k = 2 * PI / 4;
+                float theta = (rand_gen.rand01() - .5) * k;
+                float v_scale = hp_vs[type];
+
+                if (rand_gen.randint(0, 2) == 1) {
+                    theta = 0;
+                }
+
+                float health = hp_healths[type];
+
+                if (type == METEOR || type == CLOUD) {
+                    theta = 0;
+                    v_scale = hp_slow_v;
+                    fire_time = -1;
+                } else if (type == TURRET) {
+                    theta = 0;
+                    v_scale = hp_slow_v;
+                    fire_time = rand_gen.randint(20, 30);
+                }
+
+                v_scale *= V_SCALE;
+
+                float vx = -1 * cos(theta) * v_scale;
+                float vy = sin(theta) * v_scale;
+
+                bool spawn_right = true;
+                float x_pos;
+
+                if (type == FLYER || type == FAST_FLYER) {
+                    if (rand_gen.rand01() > hp_spawn_right_threshold && can_spawn_left) {
+                        spawn_right = false;
+                    }
+                }
+
+                if (spawn_right) {
+                    x_pos = main_width + r;
+                } else {
+                    x_pos = -r;
+                    vx *= -1;
+                }
+
+                auto spawner = std::make_shared<Entity>(x_pos, y_pos, vx, vy, r, type);
+                spawner->fire_time = fire_time;
+                spawner->spawn_time = spawn_time;
+                spawner->health = health;
+
+                if (type == CLOUD) {
+                    spawner->render_z = 1;
+                    choose_random_theme(spawner);
+                } else if (type == METEOR) {
+                    choose_random_theme(spawner);
+                } else if (type == FLYER || type == FAST_FLYER) {
+                    spawner->image_theme = flyer_theme;
+                    spawner->rotation = ((vx > 0) ? -1 : 1) * PI / 2;
+                } else if (type == TURRET) {
+                    choose_random_theme(spawner);
+                    match_aspect_ratio(spawner);
+                }
+
+                spawners.push_back(spawner);
+            }
+
+            t += rand_gen.randint(hp_min_enemy_delta_t, hp_max_enemy_delta_t);
+        }
+    }
+
+    void game_reset() override {
+        BasicAbstractGame::game_reset();
+
+        options.center_agent = false;
+
+        init_hps();
+
+        spawners.clear();
+
+        add_spawners();
+
+        std::sort(spawners.begin(), spawners.end(), spawn_cmp);
+
+        agent->rotation = PI / 2;
+        choose_random_theme(agent);
+    }
+
+    bool is_lethal(const std::shared_ptr<Entity> &e1) {
+        int type = e1->type;
+
+        return type == FLYER || type == FAST_FLYER || type == BULLET2 || type == BULLET3 || type == TURRET || type == METEOR;
+    }
+
+    bool is_destructible(int type) {
+        return type == FLYER || type == FAST_FLYER || type == TURRET || type == METEOR;
+    }
+
+    bool should_fire(const std::shared_ptr<Entity> &e1, int cur_time) {
+        if (e1->fire_time <= 0) {
+            return false;
+        }
+
+        if (e1->type == TURRET) {
+            return (cur_time - e1->spawn_time) % e1->fire_time == 0;
+        }
+
+        return cur_time - e1->spawn_time == e1->fire_time;
+    }
+
+    void game_step() override {
+        BasicAbstractGame::game_step();
+
+        bool is_firing = special_action != 0;
+
+        for (int i = (int)(entities.size()) - 1; i >= 0; i--) {
+            auto m = entities[i];
+
+            if (m->type == PLAYER)
+                continue;
+
+            if (should_fire(m, cur_time)) {
+                int bullet_type = m->type == TURRET ? BULLET3 : BULLET2;
+                float bullet_r = hp_bullet_r[m->type];
+                float b_vx = agent->x - m->x;
+                float b_vy = agent->y - m->y;
+                float bv_scale = hp_vs[bullet_type] * V_SCALE / sqrt(b_vx * b_vx + b_vy * b_vy);
+                b_vx = b_vx * bv_scale;
+                b_vy = b_vy * bv_scale;
+
+                std::shared_ptr<Entity> new_bullet(new Entity(m->x, m->y, b_vx, b_vy, bullet_r, bullet_type));
+                new_bullet->face_direction(b_vx, b_vy, -1 * PI / 2);
+                entities.push_back(new_bullet);
+            }
+
+            if (m->health <= 0 && is_destructible(m->type) && !m->will_erase) {
+                spawn_child(m, EXPLOSION, .5 * m->rx, true);
+
+                step_data.reward += ENEMY_REWARD;
+                m->will_erase = true;
+            }
+        }
+
+        while (spawners.size() > 0 && cur_time == spawners[int(spawners.size()) - 1]->spawn_time) {
+            entities.push_back(spawners[int(spawners.size()) - 1]);
+            spawners.pop_back();
+        }
+
+        float bullet_r = hp_bullet_r[PLAYER];
+
+        if (is_firing) {
+            float theta = special_action == 2 ? PI : 0;
+            float v_scale = hp_vs[BULLET_PLAYER] * V_SCALE;
+
+            float vx = cos(theta) * v_scale;
+            float vy = sin(theta) * v_scale;
+            float x_off = agent->rx * cos(theta);
+
+            auto bullet = std::make_shared<Entity>(agent->x + x_off, agent->y, vx, vy, bullet_r, BULLET_PLAYER);
+            bullet->collides_with_entities = true;
+            bullet->face_direction(vx, vy);
+            bullet->rotation -= PI / 2;
+            entities.push_back(bullet);
+        }
+
+        if (cur_time == SHOOTER_WIN_TIME) {
+            auto finish = std::make_shared<Entity>(main_width, main_height / 2, -1 * hp_slow_v * V_SCALE, 0, 2, main_height / 2, FINISH_LINE);
+            choose_random_theme(finish);
+            match_aspect_ratio(finish, false);
+            finish->x = main_width + finish->rx;
+            entities.push_back(finish);
+        }
+    }
+
+    void serialize(WriteBuffer *b) override {
+        BasicAbstractGame::serialize(b);
+        write_entities(b, spawners);
+    }
+
+    void deserialize(ReadBuffer *b) override {
+        BasicAbstractGame::deserialize(b);
+        read_entities(b, spawners);
+
+        init_hps();
+    }
+};
+
+REGISTER_GAME(NAME, StarPilotGame);
diff --git a/procgenAISC/procgen/src/grid.h b/procgenAISC/procgen/src/grid.h
new file mode 100644
index 0000000..9dcb033
--- /dev/null
+++ b/procgenAISC/procgen/src/grid.h
@@ -0,0 +1,80 @@
+#pragma once
+
+/*
+
+Simple utility class for managing a grid of objects
+
+*/
+
+#include <vector>
+#include "cpp-utils.h"
+#include "buffer.h"
+
+template <typename T>
+class Grid {
+  public:
+    int w;
+    int h;
+    std::vector<T> data;
+
+    Grid() {
+        w = 0;
+        h = 0;
+    }
+
+    void resize(int width, int height) {
+        w = width;
+        h = height;
+        data.clear();
+        data.resize(width * height);
+    }
+
+    bool contains(int x, int y) const {
+        return 0 <= y && y < h && 0 <= x && x < w;
+    };
+
+    bool contains_index(int idx) const {
+        return 0 <= idx && idx < w * h;
+    };
+
+    T get(int x, int y) const {
+        fassert(contains(x, y));
+        return data[y * w + x];
+    };
+
+    T get_index(int index) const {
+        fassert(0 <= index && index < w * h);
+        return data[index];
+    };
+
+    int to_index(int x, int y) const {
+        return y * w + x;
+    };
+
+    void to_xy(int idx, int *x, int *y) const {
+        *x = idx % w;
+        *y = idx / w;
+    };
+
+    void set(int x, int y, T v) {
+        fassert(contains(x, y));
+        data[y * w + x] = v;
+    };
+
+    void set_index(int index, T v) {
+        fassert(index < w * h);
+        data[index] = v;
+    };
+
+    void serialize(WriteBuffer *b) {
+        b->write_int(w);
+        b->write_int(h);
+        b->write_vector_int(data);
+    };
+
+    void deserialize(ReadBuffer *b) {
+        w = b->read_int();
+        h = b->read_int();
+        data = b->read_vector_int();
+    };
+};
diff --git a/procgenAISC/procgen/src/mazegen.cpp b/procgenAISC/procgen/src/mazegen.cpp
new file mode 100644
index 0000000..386a5ce
--- /dev/null
+++ b/procgenAISC/procgen/src/mazegen.cpp
@@ -0,0 +1,389 @@
+#include "mazegen.h"
+#include "object-ids.h"
+#include "cpp-utils.h"
+#include "math.h"
+
+struct Wall {
+    int x1;
+    int y1;
+    int x2;
+    int y2;
+};
+
+MazeGen::MazeGen(RandGen *_rand_gen, int _maze_dim) {
+    rand_gen = _rand_gen;
+    maze_dim = _maze_dim;
+    array_dim = maze_dim + 2;
+    cell_sets.resize(array_dim * array_dim);
+    cell_sets_idxs.resize(array_dim * array_dim);
+    free_cells.resize(array_dim * array_dim);
+    grid.resize(array_dim, array_dim);
+}
+
+int MazeGen::lookup(int x, int y) {
+    return cell_sets_idxs[maze_dim * y + x];
+}
+
+void MazeGen::set_free_cell(int x, int y) {
+    grid.set(x + MAZE_OFFSET, y + MAZE_OFFSET, SPACE);
+    int cell = maze_dim * y + x;
+    if (free_cell_set.find(cell) == free_cell_set.end()) {
+        free_cells[num_free_cells] = cell;
+        free_cell_set.insert(cell);
+        num_free_cells += 1;
+    }
+}
+
+int MazeGen::get_obj(int idx) {
+    int x = idx % array_dim;
+    int y = idx / array_dim;
+
+    if (x <= 0 || x >= array_dim - 1)
+        return INVALID_OBJ;
+    if (y <= 0 || y >= array_dim - 1)
+        return INVALID_OBJ;
+
+    return grid.get(x, y);
+}
+
+void MazeGen::get_neighbors(int idx, int type, std::vector<int> &neighbors) {
+    int x = idx % array_dim;
+    int y = idx / array_dim;
+
+    neighbors.clear();
+
+    for (int dx = -1; dx <= 1; dx++) {
+        for (int dy = -1; dy <= 1; dy++) {
+            if (dx == 0 && dy == 0)
+                continue;
+            if (dx != 0 && dy != 0)
+                continue;
+
+            int n_idx = grid.to_index(x + dx, y + dy);
+            if (get_obj(n_idx) == type) {
+                neighbors.push_back(n_idx);
+            }
+        }
+    }
+}
+
+int MazeGen::expand_to_type(std::set<int> &s0, std::set<int> &s1, int type) {
+    std::set<int> curr = s0;
+
+    std::vector<int> target_elems;
+    std::vector<int> adj_space;
+
+    while (curr.size() > 0) {
+        std::set<int> next;
+
+        for (int elem : curr) {
+            get_neighbors(elem, type, target_elems);
+            get_neighbors(elem, SPACE, adj_space);
+
+            for (int j : adj_space) {
+                if (!set_contains(s0, j) && !set_contains(s1, j)) {
+                    next.insert(j);
+                    s1.insert(j);
+                }
+            }
+
+            if (target_elems.size() > 0) {
+                return target_elems[0];
+            }
+        }
+
+        curr = next;
+    }
+
+    return -1;
+}
+
+std::vector<int> MazeGen::filter_cells(int type) {
+    std::vector<int> found;
+
+    for (int i = 0; i < array_dim * array_dim; i++) {
+        if (get_obj(i) == type) {
+            found.push_back(i);
+        }
+    }
+
+    return found;
+}
+
+void MazeGen::generate_maze() {
+    for (int i = 0; i < array_dim; i++) {
+        for (int j = 0; j < array_dim; j++) {
+            grid.set(i, j, WALL_OBJ);
+        }
+    }
+
+    grid.set(MAZE_OFFSET, MAZE_OFFSET, 0);
+
+    std::vector<Wall> walls;
+
+    num_free_cells = 0;
+    free_cell_set.clear();
+
+    std::set<int> *s0 = &cell_sets[0];
+    s0->clear();
+    s0->insert(0);
+    cell_sets_idxs[0] = 0;
+
+    for (int i = 1; i < maze_dim * maze_dim; i++) {
+        std::set<int> *s1 = &cell_sets[i];
+        s1->clear();
+        s1->insert(i);
+        cell_sets_idxs[i] = i;
+    }
+
+    for (int i = 1; i < maze_dim; i += 2) {
+        for (int j = 0; j < maze_dim; j += 2) {
+            if (i > 0 && i < maze_dim - 1) {
+                walls.push_back(Wall({i - 1, j, i + 1, j}));
+            }
+        }
+    }
+
+    for (int i = 0; i < maze_dim; i += 2) {
+        for (int j = 1; j < maze_dim; j += 2) {
+            if (j > 0 && j < maze_dim - 1) {
+                walls.push_back(Wall({i, j - 1, i, j + 1}));
+            }
+        }
+    }
+
+    while (walls.size() > 0) {
+        int n = rand_gen->randn((int)(walls.size()));
+        Wall wall = walls[n];
+
+        int s0_idx = lookup(wall.x1, wall.y1);
+        s0 = &cell_sets[s0_idx];
+        int s1_idx = lookup(wall.x2, wall.y2);
+        std::set<int> *s1 = &cell_sets[s1_idx];
+
+        int x0 = (wall.x1 + wall.x2) / 2;
+        int y0 = (wall.y1 + wall.y2) / 2;
+        int center = maze_dim * y0 + x0;
+
+        bool can_remove =
+            (grid.get(x0 + MAZE_OFFSET, y0 + MAZE_OFFSET) == WALL_OBJ) &&
+            (s0_idx != s1_idx);
+
+        if (can_remove) {
+            set_free_cell(wall.x1, wall.y1);
+            set_free_cell(x0, y0);
+            set_free_cell(wall.x2, wall.y2);
+
+            s1->insert(s0->begin(), s0->end());
+            s1->insert(center);
+
+            std::set<int>::iterator it;
+            for (it = s1->begin(); it != s1->end(); ++it) {
+                cell_sets_idxs[*it] = s1_idx;
+            }
+        }
+
+        walls.erase(walls.begin() + n);
+    }
+}
+
+// Generate a maze that has no dead ends. Approximates a MsPacman style maze.
+void MazeGen::generate_maze_no_dead_ends() {
+    generate_maze();
+
+    std::vector<int> adj_space;
+    std::vector<int> adj_wall;
+
+    for (int i = 0; i < array_dim * array_dim; i++) {
+        if (get_obj(i) == SPACE) {
+            get_neighbors(i, SPACE, adj_space);
+
+            if (adj_space.size() == 1) {
+                get_neighbors(i, WALL_OBJ, adj_wall);
+
+                if (adj_wall.size() > 0) {
+                    int n = rand_gen->randn((int)(adj_wall.size()));
+                    grid.set_index(adj_wall[n], SPACE);
+                }
+            }
+        }
+    }
+}
+
+
+// Generate a maze with doors
+void MazeGen::generate_maze_with_doors(int num_doors) {
+    generate_maze();
+
+    std::vector<int> forks;
+
+    std::vector<int> adj_space;
+    std::vector<int> adj_wall;
+
+    for (int i = 0; i < array_dim * array_dim; i++) {
+        if (get_obj(i) == SPACE) {
+            get_neighbors(i, SPACE, adj_space);
+            get_neighbors(i, WALL_OBJ, adj_wall);
+
+            if (adj_space.size() > 2) {
+                forks.push_back(i);
+            }
+        }
+    }
+
+    std::vector<int> chosen = rand_gen->choose_n(forks, num_doors);
+
+    num_doors = (int)(chosen.size());
+
+    for (int i : chosen) {
+        grid.set_index(i, DOOR_OBJ);
+    }
+
+    int agent_cell;
+    {
+        std::vector<int> space_cells = filter_cells(SPACE);
+        std::vector<int> door_neighbors;
+
+        // don't let the agent spawn next to a door, as there might not be room
+        // for the key
+        do {
+            agent_cell = rand_gen->choose_one(space_cells);
+            door_neighbors.clear();
+            get_neighbors(agent_cell, DOOR_OBJ, door_neighbors);
+        } while (door_neighbors.size() > 0);
+
+        grid.set_index(agent_cell, AGENT_OBJ);
+    }
+
+    std::set<int> s0;
+    s0.insert(agent_cell);
+
+    for (int door_num = 0; door_num < num_doors + 1; door_num++) {
+        std::set<int> s1;
+        int found_door = -1;
+
+        if (door_num < num_doors) {
+            found_door = expand_to_type(s0, s1, DOOR_OBJ);
+            grid.set_index(found_door, DOOR_OBJ + door_num + 1);
+            s0.insert(s1.begin(), s1.end());
+        }
+
+        expand_to_type(s0, s1, -999);
+
+        std::vector<int> space_cells;
+
+        for (int x : s1) {
+            space_cells.push_back(x);
+        }
+
+        fassert(space_cells.size() > 0);
+
+        int key_cell = rand_gen->choose_one(space_cells);
+        grid.set_index(key_cell, door_num == num_doors
+                                     ? EXIT_OBJ
+                                     : (KEY_OBJ + door_num + 1));
+
+        s0.insert(s1.begin(), s1.end());
+
+        if (found_door >= 0) {
+            s0.insert(found_door);
+        }
+    }
+}
+
+// Generate a maze with doors
+void MazeGen::generate_maze_with_doors_aisc(int num_doors, int num_keys) {
+    generate_maze();
+
+    std::vector<int> forks;
+
+    std::vector<int> adj_space;
+    std::vector<int> adj_wall;
+
+    for (int i = 0; i < array_dim * array_dim; i++) {
+        if (get_obj(i) == SPACE) {
+            get_neighbors(i, SPACE, adj_space);
+            get_neighbors(i, WALL_OBJ, adj_wall);
+
+            if (adj_space.size() > 1) {
+                forks.push_back(i);
+            }
+        }
+    }
+
+    std::vector<int> chosen = rand_gen->choose_n(forks, num_doors+num_keys);
+
+    int counter = 0;
+    for (int i : chosen) {
+        if (counter<num_doors){
+            grid.set_index(i, DOOR_OBJ+counter+1);
+        }
+        else{
+            grid.set_index(i, KEY_OBJ+counter-num_doors+1);
+        }
+        counter+=1;
+    }
+
+    int agent_cell;
+    {
+        std::vector<int> space_cells = filter_cells(SPACE);
+        std::vector<int> door_neighbors;
+
+        // don't let the agent spawn next to a door, as there might not be room
+        // for the key
+        do {
+            agent_cell = rand_gen->choose_one(space_cells);
+            door_neighbors.clear();
+            get_neighbors(agent_cell, DOOR_OBJ, door_neighbors);
+        } while (door_neighbors.size() > 0);
+
+        grid.set_index(agent_cell, AGENT_OBJ);
+    }
+
+}
+
+void MazeGen::deterministic_place(int start_obj, bool arrow, int rand_region) {
+    if (!arrow){
+        if (rand_region > 0){
+            int m = rand_gen->randn(num_free_cells);
+
+            for (int j = 0; j < maze_dim*100; j++) {
+                m = rand_gen->randn(num_free_cells);
+                if(free_cells[m] != -1 && free_cells[m] != 0){
+                    int x_val = free_cells[m] % maze_dim;
+                    int y_val = free_cells[m] / maze_dim;
+                    if (x_val >= maze_dim-rand_region && y_val >= maze_dim-rand_region){
+                        int coin_cell = free_cells[m];
+                        free_cells[m] = -1;
+                        grid.set(coin_cell % maze_dim + MAZE_OFFSET,
+                            coin_cell / maze_dim + MAZE_OFFSET, start_obj);
+                        j=maze_dim*100+1;
+                    }
+                }
+            }
+        }
+        else {
+            grid.set(maze_dim+MAZE_OFFSET-1, maze_dim+MAZE_OFFSET-1, start_obj);
+        }
+    }
+    if (arrow){
+        grid.set(maze_dim+MAZE_OFFSET-2, maze_dim+MAZE_OFFSET-2, start_obj);
+        // grid.set(maze_dim+MAZE_OFFSET-1, maze_dim+MAZE_OFFSET-2, start_obj);
+    }
+}
+
+void MazeGen::place_objects(int start_obj, int num_objs) {
+    for (int j = 0; j < num_objs; j++) {
+        int m = rand_gen->randn(num_free_cells);
+
+        while (free_cells[m] == -1 || free_cells[m] == 0) {
+            m = rand_gen->randn(num_free_cells);
+        }
+
+        int coin_cell = free_cells[m];
+        free_cells[m] = -1;
+
+        grid.set(coin_cell % maze_dim + MAZE_OFFSET,
+                 coin_cell / maze_dim + MAZE_OFFSET, start_obj + j);
+    }
+}
diff --git a/procgenAISC/procgen/src/mazegen.h b/procgenAISC/procgen/src/mazegen.h
new file mode 100644
index 0000000..08e69fd
--- /dev/null
+++ b/procgenAISC/procgen/src/mazegen.h
@@ -0,0 +1,47 @@
+#pragma once
+
+/*
+
+Generate a maze using kruskal's algorithm
+
+*/
+
+#include <memory>
+#include <set>
+#include "grid.h"
+#include "randgen.h"
+
+const int MAZE_OFFSET = 1;
+
+class MazeGen {
+  public:
+    Grid<int> grid;
+
+    MazeGen(RandGen *_rand_gen, int _maze_dim);
+    void generate_maze();
+    void generate_maze_no_dead_ends();
+    void generate_maze_with_doors(int num_doors);
+    void generate_maze_with_doors_aisc(int num_doors, int num_keys);
+    void place_objects(int start_obj, int num_objs);
+    void deterministic_place(int start_obj, bool arrow, int rand_region);
+
+  private:
+    RandGen *rand_gen;
+    int maze_dim;
+    int array_dim;
+
+    int num_free_cells;
+    std::vector<std::set<int>> cell_sets;
+    std::vector<int> cell_sets_idxs;
+    std::set<int> free_cell_set;
+    std::vector<int> free_cells;
+
+    void get_neighbors(int idx, int type, std::vector<int> &neighbors);
+    int lookup(int x, int y);
+    void set_free_cell(int x, int y);
+    void set_obj(int idx, int type);
+    int to_index(int x, int y);
+    int get_obj(int idx);
+    std::vector<int> filter_cells(int type);
+    int expand_to_type(std::set<int> &s0, std::set<int> &s1, int type);
+};
diff --git a/procgenAISC/procgen/src/object-ids.h b/procgenAISC/procgen/src/object-ids.h
new file mode 100644
index 0000000..b7f1a0e
--- /dev/null
+++ b/procgenAISC/procgen/src/object-ids.h
@@ -0,0 +1,27 @@
+#pragma once
+
+/*
+
+Commonly used constant object ids
+
+*/
+
+const int INVALID_OBJ = -1;
+const int INVALID_IDX = -2;
+const int PLAYER = 0;
+
+const int SPACE = 100;
+
+const int WALL_OBJ = 51;
+const int EXIT_OBJ = 52;
+const int AGENT_OBJ = 53;
+
+const int EXPLOSION = 54;
+const int EXPLOSION2 = 55;
+const int EXPLOSION3 = 56;
+const int EXPLOSION4 = 57;
+const int EXPLOSION5 = 58;
+const int TRAIL = 59;
+
+const int DOOR_OBJ = 200;
+const int KEY_OBJ = 300;
\ No newline at end of file
diff --git a/procgenAISC/procgen/src/qt-utils.h b/procgenAISC/procgen/src/qt-utils.h
new file mode 100644
index 0000000..1c870a9
--- /dev/null
+++ b/procgenAISC/procgen/src/qt-utils.h
@@ -0,0 +1,28 @@
+#pragma once
+
+/*
+
+Qt utility functions
+
+*/
+
+#include <QRect>
+#include <QColor>
+
+inline QRectF adjust_rect(const QRectF &base_rect, const QRectF &adjusting_rect) {
+    QRectF rect = QRectF(base_rect.x() + base_rect.width() * adjusting_rect.x(),
+                         base_rect.y() + base_rect.height() * adjusting_rect.y(),
+                         base_rect.width() * adjusting_rect.width(),
+                         base_rect.height() * adjusting_rect.height());
+
+    return rect;
+}
+
+inline int to_shade(float f) {
+    int shade = int(f * 255);
+    if (shade < 0)
+        shade = 0;
+    if (shade > 255)
+        shade = 255;
+    return shade;
+}
\ No newline at end of file
diff --git a/procgenAISC/procgen/src/randgen.cpp b/procgenAISC/procgen/src/randgen.cpp
new file mode 100644
index 0000000..30b3f1d
--- /dev/null
+++ b/procgenAISC/procgen/src/randgen.cpp
@@ -0,0 +1,114 @@
+#include "randgen.h"
+#include "cpp-utils.h"
+#include <set>
+#include <sstream>
+
+int RandGen::randint(int low, int high) {
+    fassert(is_seeded);
+    uint32_t x = stdgen();
+    uint32_t range = high - low;
+    return low + (x % range);
+}
+
+int RandGen::randn(int high) { // generate random integer in {0, ..., high - 1}
+    fassert(is_seeded);
+    uint32_t x = stdgen();
+    return (x % high);
+}
+
+float RandGen::rand01() {
+    fassert(is_seeded);
+    uint32_t x = stdgen();
+    return (float)((double)(x) / ((double)(stdgen.max()) + 1));
+}
+
+bool RandGen::randbool() {
+    return rand01() > .5;
+}
+
+float RandGen::randrange(float low, float high) {
+    return rand01() * (high - low) + low;
+}
+
+std::vector<int> RandGen::partition(int x, int n) {
+    std::vector<int> partition(n, 0);
+
+    for (int i = 0; i < x; i++) {
+        partition[randn(n)] += 1;
+    }
+
+    return partition;
+}
+
+int RandGen::choose_one(std::vector<int> &elems) {
+    fassert(elems.size() > 0);
+
+    return elems[randn((int)(elems.size()))];
+}
+
+std::vector<int> RandGen::choose_n(const std::vector<int> &elems, int n) {
+    std::vector<int> chosen;
+    std::vector<int> rem_elems;
+
+    for (int elem : elems) {
+        rem_elems.push_back(elem);
+    }
+
+    if (n > (int)(elems.size())) {
+        return rem_elems;
+    }
+
+    while (int(chosen.size()) < n) {
+        int next_elem_idx = randn((int)(rem_elems.size()));
+        chosen.push_back(rem_elems[next_elem_idx]);
+        rem_elems.erase(rem_elems.begin() + next_elem_idx);
+    }
+
+    return chosen;
+}
+
+std::vector<int> RandGen::simple_choose(int n, int k) {
+    std::vector<int> chosen(k, 0);
+    std::set<int> set;
+
+    fassert(k <= n);
+
+    for (int i = 0; i < k; i++) {
+        int next = randn(n);
+
+        while (set.find(next) != set.end()) {
+            next = randn(n);
+        }
+
+        chosen[i] = next;
+        set.insert(next);
+    }
+
+    return chosen;
+}
+
+int RandGen::randint() {
+    fassert(is_seeded);
+    return stdgen();
+}
+
+void RandGen::seed(int seed) {
+    stdgen.seed(seed);
+    is_seeded = true;
+}
+
+void RandGen::serialize(WriteBuffer *b) {
+    b->write_int(is_seeded);
+    std::ostringstream ostream;
+    ostream << stdgen;
+    auto str = ostream.str();
+    b->write_string(str);
+}
+
+void RandGen::deserialize(ReadBuffer *b) {
+    is_seeded = b->read_int();
+    auto str = b->read_string();
+    std::istringstream istream;
+    istream.str(str);
+    istream >> stdgen;
+}
diff --git a/procgenAISC/procgen/src/randgen.h b/procgenAISC/procgen/src/randgen.h
new file mode 100644
index 0000000..61d1f7c
--- /dev/null
+++ b/procgenAISC/procgen/src/randgen.h
@@ -0,0 +1,30 @@
+#pragma once
+
+/*
+
+Random number generator with consistent behavior across platforms
+
+*/
+
+#include "buffer.h"
+#include <random>
+
+class RandGen {
+  public:
+    std::mt19937 stdgen; // mersenne twister. calling stdgen() generates numbers like 4257284220
+    int randint(int low, int high);
+    int randn(int high);
+    float rand01();
+    float randrange(float low, float high);
+    int randint();
+    bool randbool();
+    std::vector<int> partition(int x, int n);
+    int choose_one(std::vector<int> &elems);
+    std::vector<int> choose_n(const std::vector<int> &elems, int n);
+    std::vector<int> simple_choose(int n, int k);
+    void seed(int seed);
+    void serialize(WriteBuffer *b);
+    void deserialize(ReadBuffer *b);
+  private:
+    bool is_seeded = false;
+};
diff --git a/procgenAISC/procgen/src/resources.cpp b/procgenAISC/procgen/src/resources.cpp
new file mode 100644
index 0000000..6661d13
--- /dev/null
+++ b/procgenAISC/procgen/src/resources.cpp
@@ -0,0 +1,959 @@
+#include "resources.h"
+#include "cpp-utils.h"
+
+std::string global_resource_root;
+
+std::vector<std::shared_ptr<QImage>> topdown_backgrounds;
+std::vector<std::shared_ptr<QImage>> topdown_simple_backgrounds;
+std::vector<std::shared_ptr<QImage>> platform_backgrounds;
+std::vector<std::shared_ptr<QImage>> space_backgrounds;
+std::vector<std::shared_ptr<QImage>> water_backgrounds;
+std::vector<std::shared_ptr<QImage>> water_surface_backgrounds;
+
+std::map<std::string, std::shared_ptr<QImage>> sprites;
+
+std::shared_ptr<QImage> get_asset_ptr(std::string relpath) {
+    return sprites.at(relpath);
+}
+
+std::shared_ptr<QImage> load_resource_ptr(std::string relpath, QImage::Format format) {
+    auto path = global_resource_root + relpath;
+    auto asset = QImage(QString(path.c_str())).convertToFormat(format);
+    auto asset_ptr = std::make_shared<QImage>(asset);
+
+    if (asset_ptr->width() == 0) {
+        fatal("failed to load image %s\n", path.c_str());
+    }
+    return asset_ptr;
+}
+
+void images_load() {
+    auto sprite_paths = std::vector<std::string>{
+        // "misc_assets/base.png",
+        // "misc_assets/ru.png",
+        // "misc_assets/gl.png",
+        "kenney/Ground/Planet/planetCorner_left.png",
+        "kenney/Ground/Planet/planetHill_left.png",
+        "kenney/Ground/Planet/planetHalf_right.png",
+        "kenney/Ground/Planet/planet.png",
+        "kenney/Ground/Planet/planetHalf_mid.png",
+        "kenney/Ground/Planet/planetHalf_left.png",
+        "kenney/Ground/Planet/planetCorner_right.png",
+        "kenney/Ground/Planet/planetRight.png",
+        "kenney/Ground/Planet/planetCliff_right.png",
+        "kenney/Ground/Planet/planetCenter_rounded.png",
+        "kenney/Ground/Planet/planetCenter.png",
+        "kenney/Ground/Planet/planetHalf.png",
+        "kenney/Ground/Planet/planetCliffAlt_left.png",
+        "kenney/Ground/Planet/planetLeft.png",
+        "kenney/Ground/Planet/planetMid.png",
+        "kenney/Ground/Planet/planetCliffAlt_right.png",
+        "kenney/Ground/Planet/planetCliff_left.png",
+        "kenney/Ground/Planet/planetHill_right.png",
+        "kenney/Ground/Grass/grassHill_left.png",
+        "kenney/Ground/Grass/grassHill_right.png",
+        "kenney/Ground/Grass/grassCliffAlt_right.png",
+        "kenney/Ground/Grass/grassCliff_left.png",
+        "kenney/Ground/Grass/grassHalf_left.png",
+        "kenney/Ground/Grass/grassCliff_right.png",
+        "kenney/Ground/Grass/grassCorner_right.png",
+        "kenney/Ground/Grass/grassHalf_mid.png",
+        "kenney/Ground/Grass/grassRight.png",
+        "kenney/Ground/Grass/grassCenter_round.png",
+        "kenney/Ground/Grass/grass.png",
+        "kenney/Ground/Grass/grassHalf.png",
+        "kenney/Ground/Grass/grassCenter.png",
+        "kenney/Ground/Grass/grassLeft.png",
+        "kenney/Ground/Grass/grassHalf_right.png",
+        "kenney/Ground/Grass/grassCorner_left.png",
+        "kenney/Ground/Grass/grassCliffAlt_left.png",
+        "kenney/Ground/Grass/grassMid.png",
+        "kenney/Ground/Stone/stoneCliffAlt_left.png",
+        "kenney/Ground/Stone/stoneCliffAlt_right.png",
+        "kenney/Ground/Stone/stoneMid.png",
+        "kenney/Ground/Stone/stoneCorner_left.png",
+        "kenney/Ground/Stone/stoneHalf_left.png",
+        "kenney/Ground/Stone/stoneHalf_right.png",
+        "kenney/Ground/Stone/stoneHill_left.png",
+        "kenney/Ground/Stone/stoneCenter_rounded.png",
+        "kenney/Ground/Stone/stoneHalf_mid.png",
+        "kenney/Ground/Stone/stoneCorner_right.png",
+        "kenney/Ground/Stone/stone.png",
+        "kenney/Ground/Stone/stoneHalf.png",
+        "kenney/Ground/Stone/stoneCliff_left.png",
+        "kenney/Ground/Stone/stoneLeft.png",
+        "kenney/Ground/Stone/stoneHill_right.png",
+        "kenney/Ground/Stone/stoneCenter.png",
+        "kenney/Ground/Stone/stoneCliff_right.png",
+        "kenney/Ground/Stone/stoneRight.png",
+        "kenney/Ground/Snow/snowCliff_left.png",
+        "kenney/Ground/Snow/snowRight.png",
+        "kenney/Ground/Snow/snowHill_right.png",
+        "kenney/Ground/Snow/snowCliff_right.png",
+        "kenney/Ground/Snow/snow.png",
+        "kenney/Ground/Snow/snowCenter.png",
+        "kenney/Ground/Snow/snowMid.png",
+        "kenney/Ground/Snow/snowCliffAlt_left.png",
+        "kenney/Ground/Snow/snowCorner_right.png",
+        "kenney/Ground/Snow/snowCenter_rounded.png",
+        "kenney/Ground/Snow/snowCorner_left.png",
+        "kenney/Ground/Snow/snowLeft.png",
+        "kenney/Ground/Snow/snowHalf_left.png",
+        "kenney/Ground/Snow/snowHalf.png",
+        "kenney/Ground/Snow/snowHill_left.png",
+        "kenney/Ground/Snow/snowHalf_mid.png",
+        "kenney/Ground/Snow/snowCliffAlt_right.png",
+        "kenney/Ground/Snow/snowHalf_right.png",
+        "kenney/Ground/Dirt/dirtCliff_left.png",
+        "kenney/Ground/Dirt/dirt.png",
+        "kenney/Ground/Dirt/dirtHill_right.png",
+        "kenney/Ground/Dirt/dirtCliff_right.png",
+        "kenney/Ground/Dirt/dirtHill_left.png",
+        "kenney/Ground/Dirt/dirtHalf_left.png",
+        "kenney/Ground/Dirt/dirtCenter_rounded.png",
+        "kenney/Ground/Dirt/dirtCorner_left.png",
+        "kenney/Ground/Dirt/dirtCliffAlt_left.png",
+        "kenney/Ground/Dirt/dirtRight.png",
+        "kenney/Ground/Dirt/dirtCorner_right.png",
+        "kenney/Ground/Dirt/dirtCenter.png",
+        "kenney/Ground/Dirt/dirtHalf.png",
+        "kenney/Ground/Dirt/dirtHalf_right.png",
+        "kenney/Ground/Dirt/dirtCliffAlt_right.png",
+        "kenney/Ground/Dirt/dirtMid.png",
+        "kenney/Ground/Dirt/dirtLeft.png",
+        "kenney/Ground/Dirt/dirtHalf_mid.png",
+        "kenney/Ground/Sand/sandHalf_right.png",
+        "kenney/Ground/Sand/sandCorner_right.png",
+        "kenney/Ground/Sand/sandHill_left.png",
+        "kenney/Ground/Sand/sandCenter.png",
+        "kenney/Ground/Sand/sandHalf_mid.png",
+        "kenney/Ground/Sand/sandHalf_left.png",
+        "kenney/Ground/Sand/sandRight.png",
+        "kenney/Ground/Sand/sandCorner_leftg.png",
+        "kenney/Ground/Sand/sandMid.png",
+        "kenney/Ground/Sand/sandCliffAlt_right.png",
+        "kenney/Ground/Sand/sandCliffAlt_left.png",
+        "kenney/Ground/Sand/sandHill_right.png",
+        "kenney/Ground/Sand/sandHalf.png",
+        "kenney/Ground/Sand/sand.png",
+        "kenney/Ground/Sand/sandCliff_right.png",
+        "kenney/Ground/Sand/sandCenter_rounded.png",
+        "kenney/Ground/Sand/sandCliff_left.png",
+        "kenney/Ground/Sand/sandLeft.png",
+        "kenney/Players/Variable sizes/Green/alienGreen_climb1.png",
+        "kenney/Players/Variable sizes/Green/alienGreen_stand.png",
+        "kenney/Players/Variable sizes/Green/alienGreen_climb2.png",
+        "kenney/Players/Variable sizes/Green/alienGreen_duck.png",
+        "kenney/Players/Variable sizes/Green/alienGreen_jump.png",
+        "kenney/Players/Variable sizes/Green/alienGreen_hit.png",
+        "kenney/Players/Variable sizes/Green/alienGreen_walk1.png",
+        "kenney/Players/Variable sizes/Green/alienGreen_walk2.png",
+        "kenney/Players/Variable sizes/Green/alienGreen_swim1.png",
+        "kenney/Players/Variable sizes/Green/alienGreen_swim2.png",
+        "kenney/Players/Variable sizes/Green/alienGreen_front.png",
+        "kenney/Players/Variable sizes/Blue/alienBlue_stand.png",
+        "kenney/Players/Variable sizes/Blue/alienBlue_climb2.png",
+        "kenney/Players/Variable sizes/Blue/alienBlue_walk2.png",
+        "kenney/Players/Variable sizes/Blue/alienBlue_climb1.png",
+        "kenney/Players/Variable sizes/Blue/alienBlue_hit.png",
+        "kenney/Players/Variable sizes/Blue/alienBlue_walk1.png",
+        "kenney/Players/Variable sizes/Blue/alienBlue_swim2.png",
+        "kenney/Players/Variable sizes/Blue/alienBlue_front.png",
+        "kenney/Players/Variable sizes/Blue/alienBlue_swim1.png",
+        "kenney/Players/Variable sizes/Blue/alienBlue_jump.png",
+        "kenney/Players/Variable sizes/Blue/alienBlue_duck.png",
+        "kenney/Players/Variable sizes/Pink/alienPink_swim1.png",
+        "kenney/Players/Variable sizes/Pink/alienPink_front.png",
+        "kenney/Players/Variable sizes/Pink/alienPink_swim2.png",
+        "kenney/Players/Variable sizes/Pink/alienPink_hit.png",
+        "kenney/Players/Variable sizes/Pink/alienPink_duck.png",
+        "kenney/Players/Variable sizes/Pink/alienPink_jump.png",
+        "kenney/Players/Variable sizes/Pink/alienPink_stand.png",
+        "kenney/Players/Variable sizes/Pink/alienPink_walk1.png",
+        "kenney/Players/Variable sizes/Pink/alienPink_climb1.png",
+        "kenney/Players/Variable sizes/Pink/alienPink_walk2.png",
+        "kenney/Players/Variable sizes/Pink/alienPink_climb2.png",
+        "kenney/Players/Variable sizes/Beige/alienBiege_walk1.png",
+        "kenney/Players/Variable sizes/Beige/alienBiege_climb1.png",
+        "kenney/Players/Variable sizes/Beige/alienBiege_walk2.png",
+        "kenney/Players/Variable sizes/Beige/alienBiege_climb2.png",
+        "kenney/Players/Variable sizes/Beige/alienBiege_stand.png",
+        "kenney/Players/Variable sizes/Beige/alienBiege_hit.png",
+        "kenney/Players/Variable sizes/Beige/alienBiege_jump.png",
+        "kenney/Players/Variable sizes/Beige/alienBiege_swim1.png",
+        "kenney/Players/Variable sizes/Beige/alienBiege_front.png",
+        "kenney/Players/Variable sizes/Beige/alienBiege_swim2.png",
+        "kenney/Players/Variable sizes/Beige/alienBiege_duck.png",
+        "kenney/Players/Variable sizes/Yellow/alienYellow_jump.png",
+        "kenney/Players/Variable sizes/Yellow/alienYellow_hit.png",
+        "kenney/Players/Variable sizes/Yellow/alienYellow_duck.png",
+        "kenney/Players/Variable sizes/Yellow/alienYellow_climb1.png",
+        "kenney/Players/Variable sizes/Yellow/alienYellow_swim1.png",
+        "kenney/Players/Variable sizes/Yellow/alienYellow_front.png",
+        "kenney/Players/Variable sizes/Yellow/alienYellow_climb2.png",
+        "kenney/Players/Variable sizes/Yellow/alienYellow_swim2.png",
+        "kenney/Players/Variable sizes/Yellow/alienYellow_walk1.png",
+        "kenney/Players/Variable sizes/Yellow/alienYellow_walk2.png",
+        "kenney/Players/Variable sizes/Yellow/alienYellow_stand.png",
+        "kenney/Players/128x256/Green/alienGreen_climb1.png",
+        "kenney/Players/128x256/Green/alienGreen_stand.png",
+        "kenney/Players/128x256/Green/alienGreen_climb2.png",
+        "kenney/Players/128x256/Green/alienGreen_duck.png",
+        "kenney/Players/128x256/Green/alienGreen_jump.png",
+        "kenney/Players/128x256/Green/alienGreen_hit.png",
+        "kenney/Players/128x256/Green/alienGreen_walk1.png",
+        "kenney/Players/128x256/Green/alienGreen_walk2.png",
+        "kenney/Players/128x256/Green/alienGreen_swim1.png",
+        "kenney/Players/128x256/Green/alienGreen_swim2.png",
+        "kenney/Players/128x256/Green/alienGreen_front.png",
+        "kenney/Players/128x256/Blue/alienBlue_stand.png",
+        "kenney/Players/128x256/Blue/alienBlue_climb2.png",
+        "kenney/Players/128x256/Blue/alienBlue_walk2.png",
+        "kenney/Players/128x256/Blue/alienBlue_climb1.png",
+        "kenney/Players/128x256/Blue/alienBlue_hit.png",
+        "kenney/Players/128x256/Blue/alienBlue_walk1.png",
+        "kenney/Players/128x256/Blue/alienBlue_swim2.png",
+        "kenney/Players/128x256/Blue/alienBlue_front.png",
+        "kenney/Players/128x256/Blue/alienBlue_swim1.png",
+        "kenney/Players/128x256/Blue/alienBlue_jump.png",
+        "kenney/Players/128x256/Blue/alienBlue_duck.png",
+        "kenney/Players/128x256/Pink/alienPink_swim1.png",
+        "kenney/Players/128x256/Pink/alienPink_front.png",
+        "kenney/Players/128x256/Pink/alienPink_swim2.png",
+        "kenney/Players/128x256/Pink/alienPink_hit.png",
+        "kenney/Players/128x256/Pink/alienPink_duck.png",
+        "kenney/Players/128x256/Pink/alienPink_jump.png",
+        "kenney/Players/128x256/Pink/alienPink_stand.png",
+        "kenney/Players/128x256/Pink/alienPink_walk1.png",
+        "kenney/Players/128x256/Pink/alienPink_climb1.png",
+        "kenney/Players/128x256/Pink/alienPink_walk2.png",
+        "kenney/Players/128x256/Pink/alienPink_climb2.png",
+        "kenney/Players/128x256/Beige/alienBeige_stand.png",
+        "kenney/Players/128x256/Beige/alienBeige_duck.png",
+        "kenney/Players/128x256/Beige/alienBeige_jump.png",
+        "kenney/Players/128x256/Beige/alienBeige_walk2.png",
+        "kenney/Players/128x256/Beige/alienBeige_hit.png",
+        "kenney/Players/128x256/Beige/alienBeige_walk1.png",
+        "kenney/Players/128x256/Beige/alienBeige_front.png",
+        "kenney/Players/128x256/Beige/alienBeige_swim2.png",
+        "kenney/Players/128x256/Beige/alienBeige_swim1.png",
+        "kenney/Players/128x256/Beige/alienBeige_climb2.png",
+        "kenney/Players/128x256/Beige/alienBeige_climb1.png",
+        "kenney/Players/128x256/Yellow/alienYellow_jump.png",
+        "kenney/Players/128x256/Yellow/alienYellow_hit.png",
+        "kenney/Players/128x256/Yellow/alienYellow_duck.png",
+        "kenney/Players/128x256/Yellow/alienYellow_climb1.png",
+        "kenney/Players/128x256/Yellow/alienYellow_swim1.png",
+        "kenney/Players/128x256/Yellow/alienYellow_front.png",
+        "kenney/Players/128x256/Yellow/alienYellow_climb2.png",
+        "kenney/Players/128x256/Yellow/alienYellow_swim2.png",
+        "kenney/Players/128x256/Yellow/alienYellow_walk1.png",
+        "kenney/Players/128x256/Yellow/alienYellow_walk2.png",
+        "kenney/Players/128x256/Yellow/alienYellow_stand.png",
+        "kenney/Particles/brickBrown.png",
+        "kenney/Particles/brickGrey.png",
+        "kenney/Particles/fireball.png",
+        "kenney/Tiles/lava.png",
+        "kenney/Tiles/boxExplosive_used.png",
+        "kenney/Tiles/ladderMid.png",
+        "kenney/Tiles/fence.png",
+        "kenney/Tiles/sprung.png",
+        "kenney/Tiles/bomb.png",
+        "kenney/Tiles/bridgeA.png",
+        "kenney/Tiles/brickBrown.png",
+        "kenney/Tiles/boxExplosive_disabled.png",
+        "kenney/Tiles/bridgeB.png",
+        "kenney/Tiles/waterTop_low.png",
+        "kenney/Tiles/lavaTop_high.png",
+        "kenney/Tiles/boxCoin_boxed.png",
+        "kenney/Tiles/lockGreen.png",
+        "kenney/Tiles/chain.png",
+        "kenney/Tiles/boxCrate_double.png",
+        "kenney/Tiles/boxCrate_warning.png",
+        "kenney/Tiles/lockRed.png",
+        "kenney/Tiles/boxCrate.png",
+        "kenney/Tiles/ladderTop.png",
+        "kenney/Tiles/cactus.png",
+        "kenney/Tiles/brickGrey.png",
+        "kenney/Tiles/rock.png",
+        "kenney/Tiles/snow.png",
+        "kenney/Tiles/switchGreen_pressed.png",
+        "kenney/Tiles/switchRed_pressed.png",
+        "kenney/Tiles/sign.png",
+        "kenney/Tiles/switchRed.png",
+        "kenney/Tiles/spring.png",
+        "kenney/Tiles/weight.png",
+        "kenney/Tiles/mushroomRed.png",
+        "kenney/Tiles/plantPurple.png",
+        "kenney/Tiles/boxCoin_disabled_boxed.png",
+        "kenney/Tiles/waterTop_high.png",
+        "kenney/Tiles/grass.png",
+        "kenney/Tiles/boxCoin.png",
+        "kenney/Tiles/weightAttached.png",
+        "kenney/Tiles/lockBlue.png",
+        "kenney/Tiles/boxItem_disabled.png",
+        "kenney/Tiles/switchGreen.png",
+        "kenney/Tiles/switchYellow.png",
+        "kenney/Tiles/window.png",
+        "kenney/Tiles/doorOpen_top.png",
+        "kenney/Tiles/doorClosed_top.png",
+        "kenney/Tiles/switchYellow_pressed.png",
+        "kenney/Tiles/water.png",
+        "kenney/Tiles/spikes.png",
+        "kenney/Tiles/fenceBroken.png",
+        "kenney/Tiles/boxItem_boxed.png",
+        "kenney/Tiles/boxCrate_single.png",
+        "kenney/Tiles/doorOpen_mid.png",
+        "kenney/Tiles/leverRight.png",
+        "kenney/Tiles/lockYellow.png",
+        "kenney/Tiles/torch2.png",
+        "kenney/Tiles/torchOff.png",
+        "kenney/Tiles/leverLeft.png",
+        "kenney/Tiles/boxItem_disabled_boxed.png",
+        "kenney/Tiles/leverMid.png",
+        "kenney/Tiles/lavaTop_low.png",
+        "kenney/Tiles/boxItem.png",
+        "kenney/Tiles/bombWhite.png",
+        "kenney/Tiles/mushroomBrown.png",
+        "kenney/Tiles/torch1.png",
+        "kenney/Tiles/signExit.png",
+        "kenney/Tiles/boxExplosive.png",
+        "kenney/Tiles/signLeft.png",
+        "kenney/Tiles/switchBlue_pressed.png",
+        "kenney/Tiles/bush.png",
+        "kenney/Tiles/switchBlue.png",
+        "kenney/Tiles/boxCoin_disabled.png",
+        "kenney/Tiles/signRight.png",
+        "kenney/Tiles/doorClosed_mid.png",
+        "kenney/Backgrounds/colored_shroom.png",
+        "kenney/Backgrounds/colored_grass.png",
+        "kenney/Backgrounds/colored_land.png",
+        "kenney/Backgrounds/colored_desert.png",
+        "kenney/Backgrounds/blue_desert.png",
+        "kenney/Backgrounds/blue_grass.png",
+        "kenney/Backgrounds/blue_shroom.png",
+        "kenney/Backgrounds/blue_land.png",
+        "kenney/Items/flagRed2.png",
+        "kenney/Items/coinSilver.png",
+        "kenney/Items/flagBlue_down.png",
+        "kenney/Items/flagRed1.png",
+        "kenney/Items/keyGreen.png",
+        "kenney/Items/gemYellow.png",
+        "kenney/Items/flagGreen_down.png",
+        "kenney/Items/flagYellow_down.png",
+        "kenney/Items/flagYellow2.png",
+        "kenney/Items/flagYellow1.png",
+        "kenney/Items/keyYellow.png",
+        "kenney/Items/coinGold.png",
+        "kenney/Items/keyRed.png",
+        "kenney/Items/gemGreen.png",
+        "kenney/Items/flagBlue1.png",
+        "kenney/Items/flagBlue2.png",
+        "kenney/Items/keyBlue.png",
+        "kenney/Items/star.png",
+        "kenney/Items/coinBronze.png",
+        "kenney/Items/gemBlue.png",
+        "kenney/Items/flagGreen2.png",
+        "kenney/Items/flagRed_down.png",
+        "kenney/Items/flagGreen1.png",
+        "kenney/Items/gemRed.png",
+        "kenney/Items/yellow_line_diag.png",
+        "kenney/Items/red_line_diag.png",
+        "kenney/Enemies/snail_shell.png",
+        "kenney/Enemies/fly_move.png",
+        "kenney/Enemies/ladybug_fly.png",
+        "kenney/Enemies/slimePurple_dead.png",
+        "kenney/Enemies/mouse_dead.png",
+        "kenney/Enemies/slimeBlue_hit.png",
+        "kenney/Enemies/saw.png",
+        "kenney/Enemies/sawHalf.png",
+        "kenney/Enemies/saw_move.png",
+        "kenney/Enemies/slimeGreen_move.png",
+        "kenney/Enemies/slimeGreen_hit.png",
+        "kenney/Enemies/barnacle_dead.png",
+        "kenney/Enemies/slimeBlue_dead.png",
+        "kenney/Enemies/slimeBlue.png",
+        "kenney/Enemies/frog_move.png",
+        "kenney/Enemies/fly.png",
+        "kenney/Enemies/slimePurple_hit.png",
+        "kenney/Enemies/slimeBlock_dead.png",
+        "kenney/Enemies/wormPink_dead.png",
+        "kenney/Enemies/snail_move.png",
+        "kenney/Enemies/fishBlue_dead.png",
+        "kenney/Enemies/ladybug_move.png",
+        "kenney/Enemies/bee_dead.png",
+        "kenney/Enemies/slimePurple.png",
+        "kenney/Enemies/fishGreen_dead.png",
+        "kenney/Enemies/fishPink_move.png",
+        "kenney/Enemies/slimeGreen.png",
+        "kenney/Enemies/wormGreen.png",
+        "kenney/Enemies/ladybug.png",
+        "kenney/Enemies/wormGreen_move.png",
+        "kenney/Enemies/sawHalf_dead.png",
+        "kenney/Enemies/bee.png",
+        "kenney/Enemies/slimeBlock.png",
+        "kenney/Enemies/fishBlue.png",
+        "kenney/Enemies/fishPink.png",
+        "kenney/Enemies/fishGreen_move.png",
+        "kenney/Enemies/mouse.png",
+        "kenney/Enemies/fishPink_dead.png",
+        "kenney/Enemies/wormGreen_dead.png",
+        "kenney/Enemies/sawHalf_move.png",
+        "kenney/Enemies/frog.png",
+        "kenney/Enemies/bee_move.png",
+        "kenney/Enemies/barnacle.png",
+        "kenney/Enemies/frog_dead.png",
+        "kenney/Enemies/slimeBlue_move.png",
+        "kenney/Enemies/fishBlue_fall.png",
+        "kenney/Enemies/wormPink_move.png",
+        "kenney/Enemies/fishGreen.png",
+        "kenney/Enemies/slimeBlock_move.png",
+        "kenney/Enemies/slimePurple_move.png",
+        "kenney/Enemies/fly_dead.png",
+        "kenney/Enemies/mouse_move.png",
+        "kenney/Enemies/barnacle_attack.png",
+        "kenney/Enemies/saw_dead.png",
+        "kenney/Enemies/slimeGreen_dead.png",
+        "kenney/Enemies/snail.png",
+        "kenney/Enemies/wormPink.png",
+        "kenney/HUD/hudHeart_half.png",
+        "kenney/HUD/hudJewel_red_empty.png",
+        "kenney/HUD/hudJewel_yellow_empty.png",
+        "kenney/HUD/hudCoin.png",
+        "kenney/HUD/hudHeart_empty.png",
+        "kenney/HUD/hudPlayer_beige.png",
+        "kenney/HUD/hudKey_green_empty.png",
+        "kenney/HUD/hudKey_blue.png",
+        "kenney/HUD/hudHeart_full.png",
+        "kenney/HUD/hudX.png",
+        "kenney/HUD/hud9.png",
+        "kenney/HUD/hud8.png",
+        "kenney/HUD/hudKey_red.png",
+        "kenney/HUD/hud3.png",
+        "kenney/HUD/hud2.png",
+        "kenney/HUD/hudKey_green.png",
+        "kenney/HUD/hud0.png",
+        "kenney/HUD/hud1.png",
+        "kenney/HUD/hudPlayer_green.png",
+        "kenney/HUD/hudPlayer_yellow.png",
+        "kenney/HUD/hud5.png",
+        "kenney/HUD/hud4.png",
+        "kenney/HUD/hudJewel_green.png",
+        "kenney/HUD/hudKey_blue_empty.png",
+        "kenney/HUD/hud6.png",
+        "kenney/HUD/hudJewel_yellow.png",
+        "kenney/HUD/hud7.png",
+        "kenney/HUD/hudJewel_green_empty.png",
+        "kenney/HUD/hudKey_red_empty.png",
+        "kenney/HUD/hudKey_yellow_empty.png",
+        "kenney/HUD/hudPlayer_blue.png",
+        "kenney/HUD/hudPlayer_pink.png",
+        "kenney/HUD/hudJewel_blue.png",
+        "kenney/HUD/hudJewel_blue_empty.png",
+        "kenney/HUD/hudJewel_red.png",
+        "kenney/HUD/hudKey_yellow.png",
+        "misc_assets/car_green_2.png",
+        "misc_assets/enemyShipBlack4.png",
+        "misc_assets/tank_sand.png",
+        "misc_assets/towerDefense_tile297.png",
+        "misc_assets/fire_5.png",
+        "misc_assets/car_black_4.png",
+        "misc_assets/spaceRockets_001.png",
+        "misc_assets/enemyFlying_2.png",
+        "misc_assets/fruit3.png",
+        "misc_assets/tank_green.png",
+        "misc_assets/spaceAstronauts_008.png",
+        "misc_assets/fruit2.png",
+        "misc_assets/enemyFlying_3.png",
+        "misc_assets/car_black_5.png",
+        "misc_assets/fire_4.png",
+        "misc_assets/towerDefense_tile296.png",
+        "misc_assets/ufoRed2.png",
+        "misc_assets/saw.png",
+        "misc_assets/blockGreen.png",
+        "misc_assets/enemyShipBlack5.png",
+        "misc_assets/car_green_3.png",
+        "misc_assets/bomb.png",
+        "misc_assets/car_green_1.png",
+        "misc_assets/robot_3Dblue.png",
+        "misc_assets/fire_6.png",
+        "misc_assets/spaceRockets_002.png",
+        "misc_assets/enemyFlying_1.png",
+        "misc_assets/keyGreen.png",
+        "misc_assets/enemyShipRed4.png",
+        "misc_assets/enemyShipRed5.png",
+        "misc_assets/playerShip2_orange.png",
+        "misc_assets/tank_bigRed.png",
+        "misc_assets/fruit1.png",
+        "misc_assets/spaceRockets_003.png",
+        "misc_assets/towerDefense_tile295.png",
+        "misc_assets/gemYellow.png",
+        "misc_assets/enemyShipBlack2.png",
+        "misc_assets/car_green_4.png",
+        "misc_assets/car_black_2.png",
+        "misc_assets/fire_3.png",
+        "misc_assets/enemyFlying_4.png",
+        "misc_assets/groundC.png",
+        "misc_assets/fruit5.png",
+        "misc_assets/enemyShipRed1.png",
+        "misc_assets/spikeMan_stand.png",
+        "misc_assets/fruit4.png",
+        "misc_assets/ladder_small.png",
+        "misc_assets/groundB.png",
+        "misc_assets/fire_2.png",
+        "misc_assets/car_black_3.png",
+        "misc_assets/playerShip1_green.png",
+        "misc_assets/car_green_5.png",
+        "misc_assets/enemyShipBlack3.png",
+        "misc_assets/dirt.png",
+        "misc_assets/enemyShipBlack1.png",
+        "misc_assets/spaceStation_019.png",
+        "misc_assets/car_black_1.png",
+        "misc_assets/fire1.png",
+        "misc_assets/spaceRockets_004.png",
+        "misc_assets/fruit6.png",
+        "misc_assets/laserBlue02.png",
+        "misc_assets/tile_318.png",
+        "misc_assets/enemyShipRed2.png",
+        "misc_assets/enemyShipRed3.png",
+        "misc_assets/yellowCrystal.png",
+        "misc_assets/cannonBall.png",
+        "misc_assets/groundA.png",
+        "misc_assets/fire_1.png",
+        "misc_assets/spaceStation_018.png",
+        "misc_assets/enemyWalking_4.png",
+        "misc_assets/enemySpikey_3.png",
+        "misc_assets/frog5.png",
+        "misc_assets/character10.png",
+        "misc_assets/character5.png",
+        "misc_assets/ball_soccer2.png",
+        "misc_assets/spaceEffect8.png",
+        "misc_assets/enemyShipGreen5.png",
+        "misc_assets/spaceMeteors_003.png",
+        "misc_assets/dirt_2.png",
+        "misc_assets/enemyWalking_1b.png",
+        "misc_assets/food4.png",
+        "misc_assets/meteorBrown_big3.png",
+        "misc_assets/meteorBrown_big2.png",
+        "misc_assets/ufoGreen.png",
+        "misc_assets/food5.png",
+        "misc_assets/spaceMeteors_002.png",
+        "misc_assets/carrot.png",
+        "misc_assets/enemyShipGreen4.png",
+        "misc_assets/ship_6.png",
+        "misc_assets/spaceEffect9.png",
+        "misc_assets/fenceYellow.png",
+        "misc_assets/character4.png",
+        "misc_assets/character11.png",
+        "misc_assets/frog4.png",
+        "misc_assets/enemySpikey_2.png",
+        "misc_assets/powerupRed_star.png",
+        "misc_assets/car_red_4.png",
+        "misc_assets/character13.png",
+        "misc_assets/frog6.png",
+        "misc_assets/ball_soccer1.png",
+        "misc_assets/character6.png",
+        "misc_assets/ship_4.png",
+        "misc_assets/meteorBrown_big1.png",
+        "misc_assets/food6.png",
+        "misc_assets/spaceMeteors_001.png",
+        "misc_assets/ship_5.png",
+        "misc_assets/character7.png",
+        "misc_assets/frog7.png",
+        "misc_assets/fishTile_078.png",
+        "misc_assets/character12.png",
+        "misc_assets/enemySpikey_1.png",
+        "misc_assets/car_red_5.png",
+        "misc_assets/enemyWalking_2.png",
+        "misc_assets/car_red_1.png",
+        "misc_assets/character3.png",
+        "misc_assets/frog3.png",
+        "misc_assets/ship_1.png",
+        "misc_assets/enemyShipGreen3.png",
+        "misc_assets/zombie2_silencer.png",
+        "misc_assets/food2.png",
+        "misc_assets/meteorBrown_big4.png",
+        "misc_assets/food3.png",
+        "misc_assets/spaceMeteors_004.png",
+        "misc_assets/present1.png",
+        "misc_assets/enemyShipGreen2.png",
+        "misc_assets/playerShip1_blue.png",
+        "misc_assets/frog2.png",
+        "misc_assets/character2.png",
+        "misc_assets/enemyWalking_3.png",
+        "misc_assets/enemySpikey_4.png",
+        "misc_assets/fishTile_080.png",
+        "misc_assets/robot_greenDrive1.png",
+        "misc_assets/car_red_2.png",
+        "misc_assets/enemyWalking_1.png",
+        "misc_assets/tile_bricksRed.png",
+        "misc_assets/ship_2.png",
+        "misc_assets/present3.png",
+        "misc_assets/food1.png",
+        "misc_assets/spaceShips_009.png",
+        "misc_assets/spaceShips_008.png",
+        "misc_assets/shield2.png",
+        "misc_assets/present2.png",
+        "misc_assets/enemyShipGreen1.png",
+        "misc_assets/ship_3.png",
+        "misc_assets/frog1.png",
+        "misc_assets/tank_darkLarge.png",
+        "misc_assets/character1.png",
+        "misc_assets/car_red_3.png",
+        "misc_assets/enemySpikey_1b.png",
+        "misc_assets/spaceEffect1.png",
+        "misc_assets/genericItem_color_001.png",
+        "misc_assets/playerShip2_red.png",
+        "misc_assets/spaceShips_005.png",
+        "misc_assets/spaceShips_004.png",
+        "misc_assets/keyRed.png",
+        "misc_assets/iconCircle_white.png",
+        "misc_assets/tank_blue.png",
+        "misc_assets/bunny2_stand.png",
+        "misc_assets/panel_wood.png",
+        "misc_assets/towerDefense_tile203.png",
+        "misc_assets/enemyFloating_1.png",
+        "misc_assets/fishTile_072.png",
+        "misc_assets/enemyFloating_3.png",
+        "misc_assets/spaceEffect2.png",
+        "misc_assets/genericItem_color_002.png",
+        "misc_assets/laserGreen14.png",
+        "misc_assets/spaceShips_006.png",
+        "misc_assets/enemyShipBlue4.png",
+        "misc_assets/enemyShipBlue5.png",
+        "misc_assets/spaceShips_007.png",
+        "misc_assets/lock_blue.png",
+        "misc_assets/genericItem_color_003.png",
+        "misc_assets/cheese.png",
+        "misc_assets/spaceEffect3.png",
+        "misc_assets/window.png",
+        "misc_assets/tileStone_slope2.png",
+        "misc_assets/enemyFloating_2.png",
+        "misc_assets/doorOpen_top.png",
+        "misc_assets/elementWood044.png",
+        "misc_assets/tank_red.png",
+        "misc_assets/spaceEffect7.png",
+        "misc_assets/spaceShips_003.png",
+        "misc_assets/playerShip3_green.png",
+        "misc_assets/enemyShipBlue1.png",
+        "misc_assets/ball_tennis1.png",
+        "misc_assets/spaceShips_002.png",
+        "misc_assets/tank_huge.png",
+        "misc_assets/genericItem_color_006.png",
+        "misc_assets/spaceEffect6.png",
+        "misc_assets/fishTile_074.png",
+        "misc_assets/bunny2_jump.png",
+        "misc_assets/fishTile_076.png",
+        "misc_assets/character9.png",
+        "misc_assets/spaceEffect4.png",
+        "misc_assets/genericItem_color_004.png",
+        "misc_assets/keyBlue.png",
+        "misc_assets/roadTile6.png",
+        "misc_assets/enemyShipBlue2.png",
+        "misc_assets/playerShip3_red.png",
+        "misc_assets/finish.png",
+        "misc_assets/enemyShipBlue3.png",
+        "misc_assets/spaceShips_001.png",
+        "misc_assets/genericItem_color_005.png",
+        "misc_assets/playerShip3_orange.png",
+        "misc_assets/enemyFloating_4.png",
+        "misc_assets/spaceEffect5.png",
+        "misc_assets/character8.png",
+        "misc_assets/car_yellow_1.png",
+        "misc_assets/explosion1.png",
+        "misc_assets/doorOpen_mid.png",
+        "misc_assets/enemyFloating_1b.png",
+        "misc_assets/finish2.png",
+        "misc_assets/laserRed11.png",
+        "misc_assets/meteorGrey_big2.png",
+        "misc_assets/meteorGrey_big3.png",
+        "misc_assets/ball_volley2.png",
+        "misc_assets/tileStone_slope.png",
+        "misc_assets/bunny2_walk1.png",
+        "misc_assets/blockRed.png",
+        "misc_assets/car_yellow_2.png",
+        "misc_assets/explosion2.png",
+        "misc_assets/terrainTile6.png",
+        "misc_assets/fence_single.png",
+        "misc_assets/playerShip1_red.png",
+        "misc_assets/fireball.png",
+        "misc_assets/bunny2_ready.png",
+        "misc_assets/car_blue_5.png",
+        "misc_assets/gemBlue.png",
+        "misc_assets/ufoGreen2.png",
+        "misc_assets/meteorGrey_big1.png",
+        "misc_assets/tile_316.png",
+        "misc_assets/car_blue_4.png",
+        "misc_assets/bunny2_walk2.png",
+        "misc_assets/ufoRed.png",
+        "misc_assets/lock_red.png",
+        "misc_assets/playerShip3_blue.png",
+        "misc_assets/playerShip2_blue.png",
+        "misc_assets/explosion3.png",
+        "misc_assets/car_yellow_3.png",
+        "misc_assets/keyRed2.png",
+        "misc_assets/elementStone007.png",
+        "misc_assets/towerDefense_tile298.png",
+        "misc_assets/playerShip2_green.png",
+        "misc_assets/lock_green.png",
+        "misc_assets/meteorGrey_big4.png",
+        "misc_assets/laserBlue09.png",
+        "misc_assets/car_blue_1.png",
+        "misc_assets/explosion4.png",
+        "misc_assets/car_yellow_4.png",
+        "misc_assets/target_red2.png",
+        "misc_assets/towerDefense_tile270.png",
+        "misc_assets/tile_bricksGrey.png",
+        "misc_assets/car_blue_3.png",
+        "misc_assets/playerShip1_orange.png",
+        "misc_assets/roadTile6b.png",
+        "misc_assets/manBlue_silencer.png",
+        "misc_assets/tile_bricksGrown.png",
+        "misc_assets/car_blue_2.png",
+        "misc_assets/tank_dark.png",
+        "misc_assets/lockRed2.png",
+        "misc_assets/car_yellow_5.png",
+        "misc_assets/explosion5.png",
+        "platformer/playerBlue_dead.png",
+        "platformer/playerBlue_roll.png",
+        "platformer/playerRed_walk4.png",
+        "platformer/playerRed_walk5.png",
+        "platformer/tileYellow_06.png",
+        "platformer/playerRed_duck.png",
+        "platformer/tileGreen_08.png",
+        "platformer/playerGreen_switch2.png",
+        "platformer/playerGreen_up2.png",
+        "platformer/playerRed_walk2.png",
+        "platformer/blueCrystal.png",
+        "platformer/playerRed_walk3.png",
+        "platformer/playerGreen_up3.png",
+        "platformer/playerGreen_up1.png",
+        "platformer/playerGreen_switch1.png",
+        "platformer/playerRed_walk1.png",
+        "platformer/playerGreen_hit.png",
+        "platformer/yellowCrystal.png",
+        "platformer/tileBlue_05.png",
+        "platformer/shroom1.png",
+        "platformer/playerGreen_roll.png",
+        "platformer/playerGreen_dead.png",
+        "platformer/playerRed_hit.png",
+        "platformer/tileBrown_06.png",
+        "platformer/playerRed_up1.png",
+        "platformer/shroom2.png",
+        "platformer/playerRed_up3.png",
+        "platformer/playerRed_fall.png",
+        "platformer/playerGrey_roll.png",
+        "platformer/playerGrey_dead.png",
+        "platformer/shroom3.png",
+        "platformer/playerRed_up2.png",
+        "platformer/playerBlue_swim2.png",
+        "platformer/playerGrey_up3.png",
+        "platformer/playerGrey_swim1.png",
+        "platformer/playerGreen_swim2.png",
+        "platformer/playerGrey_up2.png",
+        "platformer/shroom6.png",
+        "platformer/playerBlue_swim1.png",
+        "platformer/shroom4.png",
+        "platformer/playerRed_stand.png",
+        "platformer/playerGrey_swim2.png",
+        "platformer/playerGrey_hit.png",
+        "platformer/playerGreen_swim1.png",
+        "platformer/playerGrey_up1.png",
+        "platformer/shroom5.png",
+        "platformer/enemySwimming_4.png",
+        "platformer/zombie_jump.png",
+        "platformer/playerBlue_walk5.png",
+        "platformer/playerBlue_up2.png",
+        "platformer/playerGreen_walk4.png",
+        "platformer/playerGreen_walk5.png",
+        "platformer/playerBlue_up3.png",
+        "platformer/playerBlue_walk4.png",
+        "platformer/playerGrey_walk4.png",
+        "platformer/playerBlue_hit.png",
+        "platformer/playerBlue_up1.png",
+        "platformer/playerGrey_walk5.png",
+        "platformer/playerBlue_duck.png",
+        "platformer/enemySwimming_2.png",
+        "platformer/playerGrey_walk1.png",
+        "platformer/playerBlue_walk3.png",
+        "platformer/playerGreen_walk2.png",
+        "platformer/playerGreen_walk3.png",
+        "platformer/playerGreen_fall.png",
+        "platformer/tileBrown_09.png",
+        "platformer/playerBlue_walk2.png",
+        "platformer/enemySwimming_3.png",
+        "platformer/playerGrey_walk2.png",
+        "platformer/enemySwimming_1.png",
+        "platformer/playerGrey_fall.png",
+        "platformer/greenCrystal.png",
+        "platformer/redCrystal.png",
+        "platformer/playerGreen_walk1.png",
+        "platformer/playerRed_dead.png",
+        "platformer/playerBlue_walk1.png",
+        "platformer/playerRed_roll.png",
+        "platformer/playerGrey_walk3.png",
+        "platformer/tileBlue_08.png",
+        "platformer/zombie_walk1.png",
+        "platformer/fireball.png",
+        "platformer/zombie_walk2.png",
+        "platformer/zombie_idle.png",
+        "platformer/playerGrey_switch2.png",
+        "platformer/tileGreen_05.png",
+        "platformer/playerGrey_stand.png",
+        "platformer/playerBlue_switch1.png",
+        "platformer/playerGreen_duck.png",
+        "platformer/playerBlue_fall.png",
+        "platformer/playerRed_switch1.png",
+        "platformer/playerRed_swim2.png",
+        "platformer/playerGrey_switch1.png",
+        "platformer/playerBlue_switch2.png",
+        "platformer/tileYellow_09.png",
+        "platformer/playerGreen_stand.png",
+        "platformer/playerBlue_stand.png",
+        "platformer/playerRed_switch2.png",
+        "platformer/playerRed_swim1.png",
+        "platformer/playerGrey_duck.png",
+    };
+
+    for (const auto& sprite_path : sprite_paths) {
+        sprites[sprite_path] = load_resource_ptr(sprite_path, QImage::Format_ARGB32_Premultiplied);
+    }
+
+    auto group_to_vector = std::map<std::string, std::vector<std::shared_ptr<QImage>> *>{
+        {"space_backgrounds", &space_backgrounds},
+        {"platform_backgrounds", &platform_backgrounds},
+        {"topdown_backgrounds", &topdown_backgrounds},
+        {"topdown_simple_backgrounds", &topdown_simple_backgrounds},
+        {"water_backgrounds", &water_backgrounds},
+        {"water_surface_backgrounds", &water_surface_backgrounds},
+    };
+
+    auto group_to_paths = std::map<std::string, std::vector<std::string>>{
+        {
+            "space_backgrounds",
+            {
+                "space_backgrounds/deep_space_01.png",
+                "space_backgrounds/spacegen_01.png",
+                "space_backgrounds/milky_way_01.png",
+                "space_backgrounds/ez_space_lite_01.png",
+                "space_backgrounds/meyespace_v1_01.png",
+                "space_backgrounds/eye_nebula_01.png",
+                "space_backgrounds/deep_sky_01.png",
+                "space_backgrounds/space_nebula_01.png",
+                "space_backgrounds/Background-1.png",
+                "space_backgrounds/Background-2.png",
+                "space_backgrounds/Background-3.png",
+                "space_backgrounds/Background-4.png",
+                "space_backgrounds/parallax-space-backgound.png",
+            },
+        },
+        {
+            "platform_backgrounds",
+            {
+                "platform_backgrounds/alien_bg.png",
+                "platform_backgrounds/another_world_bg.png",
+                "platform_backgrounds/back_cave.png",
+                "platform_backgrounds/caverns.png",
+                "platform_backgrounds/cyberpunk_bg.png",
+                "platform_backgrounds/parallax_forest.png",
+                "platform_backgrounds/scifi_bg.png",
+                "platform_backgrounds/scifi2_bg.png",
+                "platform_backgrounds/living_tissue_bg.png",
+                "platform_backgrounds/airadventurelevel1.png",
+                "platform_backgrounds/airadventurelevel2.png",
+                "platform_backgrounds/airadventurelevel3.png",
+                "platform_backgrounds/airadventurelevel4.png",
+                "platform_backgrounds/cave_background.png",
+                "platform_backgrounds/blue_desert.png",
+                "platform_backgrounds/blue_grass.png",
+                "platform_backgrounds/blue_land.png",
+                "platform_backgrounds/blue_shroom.png",
+                "platform_backgrounds/colored_desert.png",
+                "platform_backgrounds/colored_grass.png",
+                "platform_backgrounds/colored_land.png",
+                "platform_backgrounds/colored_shroom.png",
+                "platform_backgrounds/landscape1.png",
+                "platform_backgrounds/landscape2.png",
+                "platform_backgrounds/landscape3.png",
+                "platform_backgrounds/landscape4.png",
+                "platform_backgrounds/battleback1.png",
+                "platform_backgrounds/battleback2.png",
+                "platform_backgrounds/battleback3.png",
+                "platform_backgrounds/battleback4.png",
+                "platform_backgrounds/battleback5.png",
+                "platform_backgrounds/battleback6.png",
+                "platform_backgrounds/battleback7.png",
+                "platform_backgrounds/battleback8.png",
+                "platform_backgrounds/battleback9.png",
+                "platform_backgrounds/battleback10.png",
+                "platform_backgrounds/sunrise.png",
+                "platform_backgrounds_2/beach1.png",
+                "platform_backgrounds_2/beach2.png",
+                "platform_backgrounds_2/beach3.png",
+                "platform_backgrounds_2/beach4.png",
+                "platform_backgrounds_2/fantasy1.png",
+                "platform_backgrounds_2/fantasy2.png",
+                "platform_backgrounds_2/fantasy3.png",
+                "platform_backgrounds_2/fantasy4.png",
+                "platform_backgrounds_2/candy1.png",
+                "platform_backgrounds_2/candy2.png",
+                "platform_backgrounds_2/candy3.png",
+                "platform_backgrounds_2/candy4.png",
+            },
+        },
+        {
+            "topdown_backgrounds",
+            {
+                "topdown_backgrounds/floortiles.png",
+                "topdown_backgrounds/backgrounddetailed1.png",
+                "topdown_backgrounds/backgrounddetailed2.png",
+                "topdown_backgrounds/backgrounddetailed3.png",
+                "topdown_backgrounds/backgrounddetailed4.png",
+                "topdown_backgrounds/backgrounddetailed5.png",
+                "topdown_backgrounds/backgrounddetailed6.png",
+                "topdown_backgrounds/backgrounddetailed7.png",
+                "topdown_backgrounds/backgrounddetailed8.png",
+            },
+        },
+        {
+            "topdown_simple_backgrounds",
+            {
+                "topdown_backgrounds/floortiles.png",
+            },
+        },
+        {
+            "water_backgrounds",
+            {
+                "water_backgrounds/water1.png",
+                "water_backgrounds/water2.png",
+                "water_backgrounds/water3.png",
+                "water_backgrounds/water4.png",
+                "water_backgrounds/underwater1.png",
+                "water_backgrounds/underwater2.png",
+                "water_backgrounds/underwater3.png",
+            },
+        },
+        {
+            "water_surface_backgrounds",
+            {
+
+                "water_backgrounds/water1.png",
+                "water_backgrounds/water2.png",
+                "water_backgrounds/water3.png",
+                "water_backgrounds/water4.png",
+            },
+        },
+    };
+
+    for (auto const &pair : group_to_paths) {
+        auto vec = group_to_vector.at(pair.first);
+        for (const auto &path : pair.second) {
+            vec->push_back(load_resource_ptr(path, QImage::Format_RGB32));
+        }
+    }
+
+    // also add all space backgrounds as platform backgrounds
+    for (auto bg : space_backgrounds) {
+        platform_backgrounds.push_back(bg);
+    }
+}
diff --git a/procgenAISC/procgen/src/resources.h b/procgenAISC/procgen/src/resources.h
new file mode 100644
index 0000000..94257c0
--- /dev/null
+++ b/procgenAISC/procgen/src/resources.h
@@ -0,0 +1,22 @@
+#pragma once
+
+/*
+
+Load assets stored as individual image files
+
+*/
+
+#include <QtGui/QPainter>
+#include <iostream>
+#include <memory>
+
+std::shared_ptr<QImage> get_asset_ptr(std::string relpath);
+
+extern std::string global_resource_root;
+extern void images_load();
+extern std::vector<std::shared_ptr<QImage>> topdown_backgrounds;
+extern std::vector<std::shared_ptr<QImage>> topdown_simple_backgrounds;
+extern std::vector<std::shared_ptr<QImage>> platform_backgrounds;
+extern std::vector<std::shared_ptr<QImage>> space_backgrounds;
+extern std::vector<std::shared_ptr<QImage>> water_backgrounds;
+extern std::vector<std::shared_ptr<QImage>> water_surface_backgrounds;
\ No newline at end of file
diff --git a/procgenAISC/procgen/src/roomgen.cpp b/procgenAISC/procgen/src/roomgen.cpp
new file mode 100644
index 0000000..8be06c8
--- /dev/null
+++ b/procgenAISC/procgen/src/roomgen.cpp
@@ -0,0 +1,177 @@
+#include "roomgen.h"
+
+int RoomGenerator::count_neighbors(int idx, int type) {
+    int x, y;
+    game->to_grid_xy(idx, &x, &y);
+    int neighbors = 0;
+
+    for (int i = -1; i <= 1; i++) {
+        for (int j = -1; j <= 1; j++) {
+            int curr_obj = game->get_obj(x + i, y + j);
+
+            if (curr_obj == type) {
+                neighbors++;
+            }
+        }
+    }
+
+    return neighbors;
+}
+
+void RoomGenerator::update() {
+    // update cellular automata
+    std::vector<int> next_cells;
+
+    for (int i = 0; i < game->grid_size; i++) {
+        if (count_neighbors(i, WALL_OBJ) >= 5) {
+            next_cells.push_back(WALL_OBJ);
+        } else {
+            next_cells.push_back(SPACE);
+        }
+    }
+
+    for (int i = 0; i < game->grid_size; i++) {
+        game->set_obj(i, next_cells[i]);
+    }
+}
+
+void RoomGenerator::build_room(int idx, std::set<int> &room) {
+    std::queue<int> curr;
+
+    if (game->get_obj(idx) != SPACE)
+        return;
+
+    curr.push(idx);
+
+    while (curr.size() > 0) {
+        int curr_idx = curr.front();
+        curr.pop();
+
+        if (game->get_obj(curr_idx) != SPACE)
+            continue;
+
+        int x, y;
+        game->to_grid_xy(curr_idx, &x, &y);
+
+        for (int i = -1; i <= 1; i++) {
+            for (int j = -1; j <= 1; j++) {
+                if ((i == 0 || j == 0) && (i + j != 0)) {
+                    int next_idx = game->to_grid_idx(x + i, y + j);
+
+                    if (!set_contains(room, next_idx) && game->get_obj(next_idx) == SPACE) {
+                        curr.push(next_idx);
+                        room.insert(next_idx);
+                    }
+                }
+            }
+        }
+    }
+}
+
+void RoomGenerator::find_path(int src, int dst, std::vector<int> &path) {
+    std::set<int> covered;
+    std::vector<int> expanded;
+    std::vector<int> parents;
+
+    if (game->get_obj(src) != SPACE)
+        return;
+
+    expanded.push_back(src);
+    parents.push_back(-1);
+
+    int search_idx = 0;
+
+    while (search_idx < int(expanded.size())) {
+        int curr_idx = expanded[search_idx];
+
+        if (curr_idx == dst)
+            break;
+        if (game->get_obj(curr_idx) != SPACE)
+            continue;
+
+        int x, y;
+        game->to_grid_xy(curr_idx, &x, &y);
+
+        for (int i = -1; i <= 1; i++) {
+            for (int j = -1; j <= 1; j++) {
+                if ((i == 0 || j == 0) && (i + j != 0)) {
+                    int next_idx = game->to_grid_idx(x + i, y + j);
+
+                    if (!set_contains(covered, next_idx) && game->get_obj(next_idx) == SPACE) {
+                        expanded.push_back(next_idx);
+                        parents.push_back(search_idx);
+                        covered.insert(next_idx);
+                    }
+                }
+            }
+        }
+
+        search_idx++;
+    }
+
+    if (expanded[search_idx] == dst) {
+        std::vector<int> tmp;
+
+        while (search_idx >= 0) {
+            tmp.push_back(expanded[search_idx]);
+            search_idx = parents[search_idx];
+        }
+
+        for (int j = (int)(tmp.size()) - 1; j >= 0; j--) {
+            path.push_back(tmp[j]);
+        }
+    }
+}
+
+void RoomGenerator::find_best_room(std::set<int> &best_room) {
+    std::set<int> all_rooms;
+    all_rooms.clear();
+    best_room.clear();
+
+    int best_room_size = -1;
+
+    for (int i = 0; i < game->grid_size; i++) {
+        if (game->get_obj(i) == SPACE && !set_contains(all_rooms, i)) {
+            std::set<int> next_room;
+            build_room(i, next_room);
+            all_rooms.insert(next_room.begin(), next_room.end());
+
+            if (int(next_room.size()) > best_room_size) {
+                best_room_size = (int)(next_room.size());
+                best_room = next_room;
+            }
+        }
+    }
+}
+
+void RoomGenerator::expand_room(std::set<int> &set, int n) {
+    std::set<int> curr_set;
+    curr_set.insert(set.begin(), set.end());
+
+    for (int loop = 0; loop < n; loop++) {
+        std::set<int> next;
+
+        for (int curr_idx : curr_set) {
+            if (game->get_obj(curr_idx) != SPACE)
+                continue;
+
+            int x, y;
+            game->to_grid_xy(curr_idx, &x, &y);
+
+            for (int i = -1; i <= 1; i++) {
+                for (int j = -1; j <= 1; j++) {
+                    if (i != 0 || j != 0) {
+                        int next_idx = game->to_grid_idx(x + i, y + j);
+
+                        if (!set_contains(set, next_idx) && game->get_obj(next_idx) == SPACE) {
+                            set.insert(next_idx);
+                            next.insert(next_idx);
+                        }
+                    }
+                }
+            }
+        }
+
+        curr_set = next;
+    }
+}
diff --git a/procgenAISC/procgen/src/roomgen.h b/procgenAISC/procgen/src/roomgen.h
new file mode 100644
index 0000000..42e42b5
--- /dev/null
+++ b/procgenAISC/procgen/src/roomgen.h
@@ -0,0 +1,26 @@
+#pragma once
+
+/*
+
+Cellular-automata based room generation
+
+*/
+
+#include "basic-abstract-game.h"
+
+class RoomGenerator {
+  public:
+    RoomGenerator(BasicAbstractGame *game)
+        : game(game){};
+
+    void update();
+    void find_path(int src, int dst, std::vector<int> &path);
+    void find_best_room(std::set<int> &best_room);
+    void expand_room(std::set<int> &set, int n);
+
+  private:
+    BasicAbstractGame *game;
+
+    void build_room(int idx, std::set<int> &room);
+    int count_neighbors(int idx, int type);
+};
\ No newline at end of file
diff --git a/procgenAISC/procgen/src/seed b/procgenAISC/procgen/src/seed
new file mode 100644
index 0000000..b39961f
--- /dev/null
+++ b/procgenAISC/procgen/src/seed
@@ -0,0 +1 @@
+final info={'episode_steps': 1000, 'episode_return': 2.0, 'prev_level_seed': 1680787358, 'prev_level_complete': 0, 'level_seed': 580223328}
diff --git a/procgenAISC/procgen/src/vecgame.cpp b/procgenAISC/procgen/src/vecgame.cpp
new file mode 100644
index 0000000..8702d50
--- /dev/null
+++ b/procgenAISC/procgen/src/vecgame.cpp
@@ -0,0 +1,531 @@
+#include "vecgame.h"
+#include "cpp-utils.h"
+#include "vecoptions.h"
+#include "game.h"
+
+const int32_t END_OF_BUFFER = 0xCAFECAFE;
+
+extern void coinrun_old_init(int rand_seed);
+
+static std::once_flag global_init_flag;
+
+std::vector<std::string> split(std::string s, std::string delimiter) {
+    std::vector<std::string> env_names;
+
+    size_t pos = 0;
+    std::string token;
+    while ((pos = s.find(delimiter)) != std::string::npos) {
+        token = s.substr(0, pos);
+        env_names.push_back(token);
+        s.erase(0, pos + delimiter.length());
+    }
+    env_names.push_back(s);
+
+    return env_names;
+}
+
+// libenv api
+
+// convert_bufs reorganizes buffers so that they are indexed by the environment
+std::vector<std::vector<void *>> convert_bufs(void **bufs, int num_envs,
+                                              size_t space_count) {
+    auto result = std::vector<std::vector<void *>>(num_envs);
+    for (int env_idx = 0; env_idx < num_envs; env_idx++) {
+        result[env_idx].resize(space_count);
+        for (size_t space_idx = 0; space_idx < space_count; space_idx++) {
+            result[env_idx][space_idx] = bufs[space_idx * num_envs + env_idx];
+        }
+    }
+    return result;
+}
+
+extern "C" {
+int libenv_version() {
+    return LIBENV_VERSION;
+}
+
+libenv_env *libenv_make(int num_envs, const struct libenv_options options) {
+    auto venv = new VecGame(num_envs, VecOptions(options));
+    return (libenv_env *)(venv);
+}
+
+int libenv_get_tensortypes(libenv_env *handle, enum libenv_space_name name, struct libenv_tensortype *out_types) {
+    auto venv = (VecGame *)(handle);
+    std::vector<struct libenv_tensortype> types;
+    if (name == LIBENV_SPACE_OBSERVATION) {
+        types = venv->observation_types;
+    } else if (name == LIBENV_SPACE_ACTION) {
+        types = venv->action_types;
+        fassert(types.size() == 1);
+        fassert(types[0].dtype == LIBENV_DTYPE_INT32);
+    } else if (name == LIBENV_SPACE_INFO) {
+        types = venv->info_types;
+    } else {
+        return 0;
+    }
+    if (out_types != nullptr) {
+        for (size_t i = 0; i < types.size(); i++) {
+            out_types[i] = types[i];
+        }
+    }
+    return (int)(types.size());
+}
+
+void libenv_set_buffers(libenv_env *handle, struct libenv_buffers *bufs) {
+    auto venv = (VecGame *)(handle);
+    auto ac = convert_bufs(bufs->ac, venv->num_envs,
+                           venv->action_types.size());
+    auto ob = convert_bufs(bufs->ob, venv->num_envs,
+                           venv->observation_types.size());
+    auto info =
+        convert_bufs(bufs->info, venv->num_envs, venv->info_types.size());
+    venv->set_buffers(ac, ob, info, bufs->rew, bufs->first);
+}
+
+void libenv_observe(libenv_env *handle) {
+    auto venv = (VecGame *)(handle);
+    venv->observe();
+}
+
+void libenv_act(libenv_env *handle) {
+    auto venv = (VecGame *)(handle);
+    venv->act();
+}
+
+void libenv_close(libenv_env *handle) {
+    auto venv = (VecGame *)(handle);
+    delete venv;
+}
+}
+
+// end libenv api
+
+static void stepping_worker(std::mutex &stepping_thread_mutex,
+                            std::list<std::shared_ptr<Game>> &pending_games,
+                            std::condition_variable &pending_games_added,
+                            std::condition_variable &pending_game_complete, bool &time_to_die) {
+    while (1) {
+        std::shared_ptr<Game> game;
+
+        {
+            std::unique_lock<std::mutex> lock(stepping_thread_mutex);
+            while (1) {
+                if (time_to_die) {
+                    return;
+                }
+                if (!pending_games.empty()) {
+                    game = pending_games.front();
+                    pending_games.pop_front();
+                    break;
+                }
+
+                pending_games_added.wait(lock);
+            }
+        }
+
+        // the first time the threads are activated is before any step, just to initialize
+        // the environment and produce the initial observation
+        if (!game->initial_reset_complete) {
+            game->reset();
+            game->observe();
+            game->initial_reset_complete = true;
+        } else{
+            game->step();
+        }
+
+        {
+            std::unique_lock<std::mutex> lock(stepping_thread_mutex);
+            game->is_waiting_for_step = false;
+            pending_game_complete.notify_all();
+        }
+    }
+}
+
+void global_init(int rand_seed, std::string resource_root) {
+    global_resource_root = resource_root;
+
+    try {
+        images_load();
+        coinrun_old_init(rand_seed);
+    } catch (const std::exception &e) {
+        fatal("failed to load images %s\n", e.what());
+    }
+}
+
+// we want system independent hashing. std::hash doesn't give this.
+inline uint32_t hash_str_uint32(const std::string &str) {
+    uint32_t hash = 0x811c9dc5;
+    uint32_t prime = 0x1000193;
+
+    for (size_t i = 0; i < str.size(); i++) {
+        uint8_t value = str[i];
+        hash = hash ^ value;
+        hash *= prime;
+    }
+
+    return hash;
+}
+
+VecGame::VecGame(int _nenvs, VecOptions opts) {
+    render_human = false;
+    num_envs = _nenvs;
+    games.resize(num_envs);
+    std::string env_name;
+
+    int num_levels = 0;
+    int start_level = -1;
+    num_actions = -1;
+
+    int rand_seed = 0;
+    int num_threads = 4;
+    // int random_percent = 100;
+    std::string resource_root;
+
+    opts.consume_string("env_name", &env_name);
+    opts.consume_int("num_levels", &num_levels);
+    opts.consume_int("start_level", &start_level);
+    opts.consume_int("num_actions", &num_actions);
+    opts.consume_int("rand_seed", &rand_seed);
+    opts.consume_int("num_threads", &num_threads);
+    opts.consume_string("resource_root", &resource_root);
+    opts.consume_bool("render_human", &render_human);
+    // opts.consume_int("random_percent", &random_percent);
+
+    std::call_once(global_init_flag, global_init, rand_seed,
+                   resource_root);
+
+    fassert(num_threads >= 0);
+    threads.resize(num_threads);
+    for (int t = 0; t < num_threads; t++) {
+        threads[t] = std::thread(
+            stepping_worker,
+            std::ref(stepping_thread_mutex),
+            std::ref(pending_games),
+            std::ref(pending_games_added),
+            std::ref(pending_game_complete),
+            std::ref(time_to_die));
+    }
+
+    fassert(env_name != "");
+    fassert(num_actions > 0);
+    fassert(num_levels >= 0);
+    fassert(start_level >= 0);
+
+    {
+        struct libenv_tensortype s;
+        strcpy(s.name, "rgb");
+        s.scalar_type = LIBENV_SCALAR_TYPE_DISCRETE;
+        s.dtype = LIBENV_DTYPE_UINT8;
+        s.shape[0] = RES_W;
+        s.shape[1] = RES_H;
+        s.shape[2] = 3;
+        s.ndim = 3;
+        s.low.uint8 = 0;
+        s.high.uint8 = 255;
+        observation_types.push_back(s);
+    }
+
+    {
+        struct libenv_tensortype s;
+        strcpy(s.name, "action");
+        s.scalar_type = LIBENV_SCALAR_TYPE_DISCRETE;
+        s.dtype = LIBENV_DTYPE_INT32;
+        s.ndim = 0;
+        s.low.int32 = 0;
+        s.high.int32 = num_actions - 1;
+        action_types.push_back(s);
+    }
+
+    {
+        struct libenv_tensortype s;
+        strcpy(s.name, "prev_level_seed");
+        s.scalar_type = LIBENV_SCALAR_TYPE_DISCRETE;
+        s.dtype = LIBENV_DTYPE_INT32;
+        s.ndim = 0,
+        s.low.int32 = 0;
+        s.high.int32 = INT32_MAX;
+        info_types.push_back(s);
+    }
+
+    {
+        struct libenv_tensortype s;
+        strcpy(s.name, "prev_level_complete");
+        s.scalar_type = LIBENV_SCALAR_TYPE_DISCRETE;
+        s.dtype = LIBENV_DTYPE_UINT8;
+        s.ndim = 0,
+        s.low.uint8 = 0;
+        s.high.uint8 = 1;
+        info_types.push_back(s);
+    }
+
+    {
+        struct libenv_tensortype s;
+        strcpy(s.name, "level_seed");
+        s.scalar_type = LIBENV_SCALAR_TYPE_DISCRETE;
+        s.dtype = LIBENV_DTYPE_INT32;
+        s.ndim = 0,
+        s.low.int32 = 0;
+        s.high.int32 = INT32_MAX;
+        info_types.push_back(s);
+    }
+    
+    if (render_human) {
+        struct libenv_tensortype s;
+        strcpy(s.name, "rgb");
+        s.scalar_type = LIBENV_SCALAR_TYPE_DISCRETE;
+        s.dtype = LIBENV_DTYPE_UINT8;
+        s.shape[0] = RENDER_RES;
+        s.shape[1] = RENDER_RES;
+        s.shape[2] = 3;
+        s.ndim = 3,
+        s.low.uint8 = 0;
+        s.high.uint8 = 255;
+        info_types.push_back(s);
+    }
+
+// Added to track coinrun metrics.
+
+// Using libenv discrete scalar (!?) bc that was
+// what the readme example used, even tho
+// bool would be more appropriate
+	{
+	    struct libenv_tensortype s;
+	    strcpy(s.name, "invisible_coin_collected");
+	    s.scalar_type = LIBENV_SCALAR_TYPE_DISCRETE;
+	    s.dtype = LIBENV_DTYPE_INT32;
+	    s.ndim = 0,
+	    s.low.int32 = 0;
+	    s.high.int32 = INT32_MAX;
+	    info_types.push_back(s);
+	}
+
+	{
+	    struct libenv_tensortype s;
+	    strcpy(s.name, "prev_level/invisible_coin_collected");
+	    s.scalar_type = LIBENV_SCALAR_TYPE_DISCRETE;
+	    s.dtype = LIBENV_DTYPE_INT32;
+	    s.ndim = 0,
+	    s.low.int32 = 0;
+	    s.high.int32 = INT32_MAX;
+	    info_types.push_back(s);
+	}
+
+	{
+	    struct libenv_tensortype s;
+	    strcpy(s.name, "randomize_goal");
+	    s.scalar_type = LIBENV_SCALAR_TYPE_DISCRETE;
+	    s.dtype = LIBENV_DTYPE_INT32;
+	    s.ndim = 0,
+	    s.low.int32 = 0;
+	    s.high.int32 = INT32_MAX;
+	    info_types.push_back(s);
+	}
+
+	{
+	    struct libenv_tensortype s;
+	    strcpy(s.name, "prev_level/randomize_goal");
+	    s.scalar_type = LIBENV_SCALAR_TYPE_DISCRETE;
+	    s.dtype = LIBENV_DTYPE_INT32;
+	    s.ndim = 0,
+	    s.low.int32 = 0;
+	    s.high.int32 = INT32_MAX;
+	    info_types.push_back(s);
+	}
+
+	{
+	    struct libenv_tensortype s;
+	    strcpy(s.name, "prev_level/total_steps");
+	    s.scalar_type = LIBENV_SCALAR_TYPE_DISCRETE;
+	    s.dtype = LIBENV_DTYPE_INT32;
+	    s.ndim = 0,
+	    s.low.int32 = 0;
+	    s.high.int32 = INT32_MAX;
+	    info_types.push_back(s);
+	}
+
+	{
+	    struct libenv_tensortype s;
+	    strcpy(s.name, "total_steps");
+	    s.scalar_type = LIBENV_SCALAR_TYPE_DISCRETE;
+	    s.dtype = LIBENV_DTYPE_INT32;
+	    s.ndim = 0,
+	    s.low.int32 = 0;
+	    s.high.int32 = INT32_MAX;
+	    info_types.push_back(s);
+	}
+
+
+    int level_seed_low = 0;
+    int level_seed_high = 0;
+
+    if (num_levels == 0) {
+        level_seed_low = 0;
+        level_seed_high = INT32_MAX;
+    } else if (num_levels > 0) {
+        level_seed_low = start_level;
+        level_seed_high = start_level + num_levels;
+    }
+
+    std::vector<std::string> env_names = split(env_name, ",");
+
+    num_joint_games = (int)(env_names.size());
+
+    fassert(num_envs % num_joint_games == 0);
+
+    RandGen game_level_seed_gen;
+    game_level_seed_gen.seed(rand_seed);
+
+    std::map<std::string, int> info_name_to_offset;
+    for (size_t i = 0; i < info_types.size(); i++) {
+        info_name_to_offset[info_types[i].name] = i;
+    }
+
+    for (int n = 0; n < num_envs; n++) {
+        auto name = env_names[n % num_joint_games];
+
+        games[n] = globalGameRegistry->at(name)();
+        fassert(games[n]->game_name == name);
+        games[n]->level_seed_rand_gen.seed(game_level_seed_gen.randint());
+        games[n]->level_seed_high = level_seed_high;
+        games[n]->level_seed_low = level_seed_low;
+        games[n]->game_n = n;
+        games[n]->is_waiting_for_step = false;
+        games[n]->parse_options(name, opts);
+        games[n]->info_name_to_offset = info_name_to_offset;
+
+        // Auto-selected a fixed_asset_seed if one wasn't specified on
+        // construction
+        if (games[n]->fixed_asset_seed == 0) {
+            auto hashed = hash_str_uint32(name);
+            games[n]->fixed_asset_seed = int(hashed);
+        }
+
+        games[n]->game_init();
+    }
+}
+
+void VecGame::set_buffers(const std::vector<std::vector<void *>> &ac, const std::vector<std::vector<void *>> &ob, const std::vector<std::vector<void *>> &info, float *rew, uint8_t *first) {
+    {
+        std::unique_lock<std::mutex> lock(stepping_thread_mutex);
+
+        for (int e = 0; e < num_envs; e++) {
+            const auto &game = games[e];
+            // we only ever have one action
+            game->action_ptr = (int32_t *)(ac[e][0]);
+            game->obs_bufs = ob[e];
+            game->info_bufs = info[e];
+            game->reward_ptr = &rew[e];
+            game->first_ptr = &first[e];
+            
+            // render the initial state so we don't see a black screen on the first frame
+            fassert(!game->is_waiting_for_step);
+            fassert(!game->initial_reset_complete);
+            if (threads.size() == 0) {
+                // special case for no threads
+                game->reset();
+                game->observe();
+                game->initial_reset_complete = true;
+            } else {
+                game->is_waiting_for_step = true;
+                pending_games.push_back(game);
+            }
+        }
+    }
+    pending_games_added.notify_all();
+}
+
+void VecGame::observe() {
+    wait_for_stepping_threads();
+    // at this point all games belong to the python thread
+
+    if (render_human) {
+        uint8_t render_hires_buf[RENDER_RES * RENDER_RES * 4];
+
+        for (int e = 0; e < num_envs; e++) {
+            const auto &game = games[e];
+            game->render_to_buf(render_hires_buf, RENDER_RES, RENDER_RES, true);
+            bgr32_to_rgb888(game->info_bufs[game->info_name_to_offset.at("rgb")], render_hires_buf, RENDER_RES, RENDER_RES);
+        }
+    }
+}
+
+void VecGame::act() {
+    wait_for_stepping_threads();
+
+    {
+        std::unique_lock<std::mutex> lock(stepping_thread_mutex);
+
+        for (int e = 0; e < num_envs; e++) {
+            const auto &game = games[e];
+            fassert(!game->is_waiting_for_step);
+            // save the action since it's only valid for the duration of this call
+            game->action = *game->action_ptr;
+            if (threads.size() == 0) {
+                // special case for no threads
+                game->step();
+            } else {
+                game->is_waiting_for_step = true;
+                pending_games.push_back(game);
+            }
+        }
+    }
+    // at this point all games belong to the stepping threads
+
+    pending_games_added.notify_all();
+}
+
+VecGame::~VecGame() {
+    wait_for_stepping_threads();
+    {
+        std::unique_lock<std::mutex> lock(stepping_thread_mutex);
+        time_to_die = true;
+    }
+    pending_games_added.notify_all();
+
+    for (auto &t : threads) {
+        t.join();
+    }
+}
+
+void VecGame::wait_for_stepping_threads() {
+    if (threads.size() == 0) {
+        return;
+    }
+
+    std::unique_lock<std::mutex> lock(stepping_thread_mutex);
+    while (1) {
+        bool all_steps_completed = true;
+
+        for (int e = 0; e < num_envs; e++) {
+            const auto &game = games[e];
+            all_steps_completed &= !game->is_waiting_for_step;
+        }
+
+        if (all_steps_completed)
+            break;
+
+        pending_game_complete.wait(lock);
+    }
+}
+
+extern "C" {
+    LIBENV_API int get_state(libenv_env *handle, int env_idx, char *data, int length) {
+        auto venv = (VecGame *)(handle);
+        venv->wait_for_stepping_threads();
+        auto b = WriteBuffer(data, length);
+        venv->games.at(env_idx)->serialize(&b);
+        b.write_int(END_OF_BUFFER);
+        return b.offset;
+    }
+
+    LIBENV_API void set_state(libenv_env *handle, int env_idx, char *data, int length) {
+        auto venv = (VecGame *)(handle);
+        venv->wait_for_stepping_threads();
+        auto b = ReadBuffer(data, length);
+        venv->games.at(env_idx)->deserialize(&b);
+        fassert(b.read_int() == END_OF_BUFFER);
+        // after deserializing, we need to update the observation and info buffers so that the
+        // next time VecGame::observe() is called, the correct data will be in the buffers
+        venv->games.at(env_idx)->observe();
+    }
+}
diff --git a/procgenAISC/procgen/src/vecgame.h b/procgenAISC/procgen/src/vecgame.h
new file mode 100644
index 0000000..c75912a
--- /dev/null
+++ b/procgenAISC/procgen/src/vecgame.h
@@ -0,0 +1,52 @@
+#pragma once
+
+/*
+
+This implements the libenv interface and manages a vector of Game instances
+
+*/
+
+#include <memory>
+#include <vector>
+#include <mutex>
+#include <string>
+#include <condition_variable>
+#include <thread>
+#include <list>
+
+class VecOptions;
+class Game;
+
+class VecGame {
+  public:
+    std::vector<struct libenv_tensortype> observation_types;
+    std::vector<struct libenv_tensortype> action_types;
+    std::vector<struct libenv_tensortype> info_types;
+
+    int num_envs;
+    int num_joint_games;
+    int num_actions;
+    bool render_human;
+
+    std::vector<std::shared_ptr<Game>> games;
+
+    VecGame(int _nenvs, VecOptions opt_vec);
+    ~VecGame();
+
+    void set_buffers(const std::vector<std::vector<void *>> &ac, const std::vector<std::vector<void *>> &ob, const std::vector<std::vector<void *>> &info, float *rew, uint8_t *first);
+    void observe();
+    void act();
+    void wait_for_stepping_threads();
+
+  private:
+    // this mutex synchronizes access to pending_games and game->is_waiting_for_step
+    // when game->is_waiting_for_step is set to true
+    // ownership of game objects is transferred to the stepping thread until
+    // game->is_waiting_for_step is set to false
+    std::mutex stepping_thread_mutex;
+    std::list<std::shared_ptr<Game>> pending_games;
+    std::condition_variable pending_games_added;
+    std::condition_variable pending_game_complete;
+    std::vector<std::thread> threads;
+    bool time_to_die = false;
+};
diff --git a/procgenAISC/procgen/src/vecoptions.cpp b/procgenAISC/procgen/src/vecoptions.cpp
new file mode 100644
index 0000000..ff58e97
--- /dev/null
+++ b/procgenAISC/procgen/src/vecoptions.cpp
@@ -0,0 +1,55 @@
+#include "vecoptions.h"
+#include "cpp-utils.h"
+
+VecOptions::VecOptions(const struct libenv_options options) {
+    m_options = std::vector<libenv_option>(options.items, options.items + options.count);
+}
+
+void VecOptions::consume_string(std::string name, std::string *value) {
+    auto opt = find_option(name, LIBENV_DTYPE_UINT8);
+    if (opt.data == nullptr) {
+        return;
+    }
+    *value = std::string((char *)(opt.data), opt.count);
+}
+
+void VecOptions::consume_int(std::string name, int32_t *value) {
+    auto opt = find_option(name, LIBENV_DTYPE_INT32);
+    if (opt.data == nullptr) {
+        return;
+    }
+    *value = *(int32_t *)(opt.data);
+}
+
+void VecOptions::consume_bool(std::string name, bool *value) {
+    auto opt = find_option(name, LIBENV_DTYPE_UINT8);
+    if (opt.data == nullptr) {
+        return;
+    }
+    uint8_t v = *(uint8_t *)(opt.data);
+    fassert(v == 0 || v == 1);
+    *value = (bool)v;
+}
+
+void VecOptions::ensure_empty() {
+    if (m_options.size() > 0) {
+        fatal("unused options found, first unused option: %s\n", m_options[0].name);
+    }
+}
+
+libenv_option VecOptions::find_option(std::string name, enum libenv_dtype dtype) {
+    for (size_t idx = 0; idx < m_options.size(); idx++) {
+        auto opt = m_options[idx];
+        const std::string key(opt.name);
+        if (key == name) {
+            if (opt.dtype != dtype) {
+                fatal("invalid dtype for option %s\n", name.c_str());
+            }
+            m_options.erase(m_options.begin() + idx);
+            return opt;
+        }
+    }
+    libenv_option result;
+    result.data = nullptr;
+    return result;
+};
\ No newline at end of file
diff --git a/procgenAISC/procgen/src/vecoptions.h b/procgenAISC/procgen/src/vecoptions.h
new file mode 100644
index 0000000..a54d287
--- /dev/null
+++ b/procgenAISC/procgen/src/vecoptions.h
@@ -0,0 +1,26 @@
+#pragma once
+
+/*
+
+Utility class to parse options provided through the libenv interface
+
+There is no error if an option is missing, the passed value is not changed in that case.
+
+*/
+
+#include "libenv.h"
+#include <string>
+#include <vector>
+
+class VecOptions {
+  public:
+    VecOptions(const struct libenv_options options);
+    void consume_string(std::string name, std::string *value);
+    void consume_int(std::string name, int32_t *value);
+    void consume_bool(std::string name, bool *value);
+    void ensure_empty();
+
+  private:
+    std::vector<libenv_option> m_options;
+    libenv_option find_option(std::string name, enum libenv_dtype dtype);
+};
\ No newline at end of file
diff --git a/procgenAISC/procgen/state_test.py b/procgenAISC/procgen/state_test.py
new file mode 100644
index 0000000..4e3d541
--- /dev/null
+++ b/procgenAISC/procgen/state_test.py
@@ -0,0 +1,124 @@
+import numpy as np
+import pytest
+from procgen import ProcgenGym3Env
+from .env import ENV_NAMES
+import gym3
+import multiprocessing as mp
+
+
+NUM_STEPS = 10000
+
+
+def gather_rollouts(
+    env_kwargs, actions, state=None, get_state=False, set_state_every_step=False
+):
+    env = ProcgenGym3Env(**env_kwargs)
+    if state is not None:
+        env.callmethod("set_state", state)
+    result = [dict(ob=env.observe(), info=env.get_info())]
+    if get_state:
+        result[-1]["state"] = env.callmethod("get_state")
+    if set_state_every_step:
+        env.callmethod("set_state", result[-1]["state"])
+    for act in actions:
+        env.act(act)
+        result.append(dict(ob=env.observe(), info=env.get_info()))
+        if get_state:
+            result[-1]["state"] = env.callmethod("get_state")
+        if set_state_every_step:
+            env.callmethod("set_state", result[-1]["state"])
+    return result
+
+
+def fn_wrapper(fn, result_queue, **kwargs):
+    result = fn(**kwargs)
+    result_queue.put(result)
+
+
+def run_in_subproc(fn, **kwargs):
+    ctx = mp.get_context("spawn")
+    result_queue = ctx.Queue()
+    p = ctx.Process(
+        target=fn_wrapper, kwargs=dict(fn=fn, result_queue=result_queue, **kwargs)
+    )
+    p.start()
+    result = result_queue.get()
+    p.join()
+    return result
+
+
+def assert_rollouts_identical(a_rollout, b_rollout):
+    assert len(a_rollout) == len(b_rollout)
+    for a, b in zip(a_rollout, b_rollout):
+        assert a["info"] == b["info"]
+        a_rew, a_ob, a_first = a["ob"]
+        b_rew, b_ob, b_first = b["ob"]
+        assert np.array_equal(a_rew, b_rew)
+        assert np.array_equal(a_first, b_first)
+        assert sorted(a_ob.keys()) == sorted(b_ob.keys())
+        for k in sorted(a_ob.keys()):
+            assert np.array_equal(a_ob[k], b_ob[k])
+        if "state" in a and "state" in b:
+            assert a["state"] == b["state"]
+
+
+@pytest.mark.skip(reason="slow")
+@pytest.mark.parametrize("env_name", ENV_NAMES)
+def test_state(env_name):
+    run_state_test(env_name)
+
+
+def run_state_test(env_name):
+    env_kwargs = dict(num=2, env_name=env_name, rand_seed=0)
+    env = ProcgenGym3Env(**env_kwargs)
+    rng = np.random.RandomState(0)
+    actions = [
+        gym3.types_np.sample(env.ac_space, bshape=(env.num,), rng=rng)
+        for _ in range(NUM_STEPS)
+    ]
+    ref_rollouts = run_in_subproc(
+        gather_rollouts, env_kwargs=env_kwargs, actions=actions
+    )
+    assert len(ref_rollouts) == NUM_STEPS + 1
+
+    # run the same thing a second time
+    basic_rollouts = run_in_subproc(
+        gather_rollouts, env_kwargs=env_kwargs, actions=actions
+    )
+    assert_rollouts_identical(ref_rollouts, basic_rollouts)
+
+    # run but save states
+    state_rollouts = run_in_subproc(
+        gather_rollouts, env_kwargs=env_kwargs, actions=actions, get_state=True
+    )
+    assert_rollouts_identical(ref_rollouts, state_rollouts)
+
+    # make sure states are the same
+    state_rollouts_2 = run_in_subproc(
+        gather_rollouts, env_kwargs=env_kwargs, actions=actions, get_state=True
+    )
+    assert_rollouts_identical(ref_rollouts, state_rollouts_2)
+    assert_rollouts_identical(state_rollouts, state_rollouts_2)
+
+    # save and restore at each timestep
+    state_rollouts_3 = run_in_subproc(
+        gather_rollouts,
+        env_kwargs=env_kwargs,
+        actions=actions,
+        get_state=True,
+        set_state_every_step=True,
+    )
+    assert_rollouts_identical(ref_rollouts, state_rollouts_3)
+    assert_rollouts_identical(state_rollouts, state_rollouts_3)
+
+    # restore a point in the middle of the rollout and make sure that the remainder of the data looks the same
+    offset = NUM_STEPS // 2
+    state_restore_rollouts = run_in_subproc(
+        gather_rollouts,
+        env_kwargs={**env_kwargs, "rand_seed": 1},
+        actions=actions[offset:],
+        state=state_rollouts[offset]["state"],
+        get_state=True,
+    )
+    assert_rollouts_identical(ref_rollouts[offset:], state_restore_rollouts)
+    assert_rollouts_identical(state_rollouts[offset:], state_restore_rollouts)
diff --git a/procgenAISC/procgen/version.txt b/procgenAISC/procgen/version.txt
new file mode 100644
index 0000000..1bfc953
--- /dev/null
+++ b/procgenAISC/procgen/version.txt
@@ -0,0 +1 @@
+0.10.4
\ No newline at end of file
diff --git a/procgenAISC/screenshots/bigfish.png b/procgenAISC/screenshots/bigfish.png
new file mode 100644
index 0000000..6374502
Binary files /dev/null and b/procgenAISC/screenshots/bigfish.png differ
diff --git a/procgenAISC/screenshots/bossfight.png b/procgenAISC/screenshots/bossfight.png
new file mode 100644
index 0000000..c07e4bb
Binary files /dev/null and b/procgenAISC/screenshots/bossfight.png differ
diff --git a/procgenAISC/screenshots/caveflyer.png b/procgenAISC/screenshots/caveflyer.png
new file mode 100644
index 0000000..38a2cf4
Binary files /dev/null and b/procgenAISC/screenshots/caveflyer.png differ
diff --git a/procgenAISC/screenshots/chaser.png b/procgenAISC/screenshots/chaser.png
new file mode 100644
index 0000000..640749c
Binary files /dev/null and b/procgenAISC/screenshots/chaser.png differ
diff --git a/procgenAISC/screenshots/climber.png b/procgenAISC/screenshots/climber.png
new file mode 100644
index 0000000..8289364
Binary files /dev/null and b/procgenAISC/screenshots/climber.png differ
diff --git a/procgenAISC/screenshots/coinrun.png b/procgenAISC/screenshots/coinrun.png
new file mode 100644
index 0000000..77c11fd
Binary files /dev/null and b/procgenAISC/screenshots/coinrun.png differ
diff --git a/procgenAISC/screenshots/dodgeball.png b/procgenAISC/screenshots/dodgeball.png
new file mode 100644
index 0000000..b3264bd
Binary files /dev/null and b/procgenAISC/screenshots/dodgeball.png differ
diff --git a/procgenAISC/screenshots/fruitbot.png b/procgenAISC/screenshots/fruitbot.png
new file mode 100644
index 0000000..7575726
Binary files /dev/null and b/procgenAISC/screenshots/fruitbot.png differ
diff --git a/procgenAISC/screenshots/heist.png b/procgenAISC/screenshots/heist.png
new file mode 100644
index 0000000..3327421
Binary files /dev/null and b/procgenAISC/screenshots/heist.png differ
diff --git a/procgenAISC/screenshots/jumper.png b/procgenAISC/screenshots/jumper.png
new file mode 100644
index 0000000..272f261
Binary files /dev/null and b/procgenAISC/screenshots/jumper.png differ
diff --git a/procgenAISC/screenshots/leaper.png b/procgenAISC/screenshots/leaper.png
new file mode 100644
index 0000000..aaadd32
Binary files /dev/null and b/procgenAISC/screenshots/leaper.png differ
diff --git a/procgenAISC/screenshots/maze.png b/procgenAISC/screenshots/maze.png
new file mode 100644
index 0000000..a35303e
Binary files /dev/null and b/procgenAISC/screenshots/maze.png differ
diff --git a/procgenAISC/screenshots/miner.png b/procgenAISC/screenshots/miner.png
new file mode 100644
index 0000000..812860f
Binary files /dev/null and b/procgenAISC/screenshots/miner.png differ
diff --git a/procgenAISC/screenshots/ninja.png b/procgenAISC/screenshots/ninja.png
new file mode 100644
index 0000000..c8698cd
Binary files /dev/null and b/procgenAISC/screenshots/ninja.png differ
diff --git a/procgenAISC/screenshots/plunder.png b/procgenAISC/screenshots/plunder.png
new file mode 100644
index 0000000..f2c69ef
Binary files /dev/null and b/procgenAISC/screenshots/plunder.png differ
diff --git a/procgenAISC/screenshots/procgen.gif b/procgenAISC/screenshots/procgen.gif
new file mode 100644
index 0000000..f6a9d5a
Binary files /dev/null and b/procgenAISC/screenshots/procgen.gif differ
diff --git a/procgenAISC/screenshots/starpilot.png b/procgenAISC/screenshots/starpilot.png
new file mode 100644
index 0000000..ddab0a8
Binary files /dev/null and b/procgenAISC/screenshots/starpilot.png differ
diff --git a/procgenAISC/scripts/upload_wheels.py b/procgenAISC/scripts/upload_wheels.py
new file mode 100644
index 0000000..88677f4
--- /dev/null
+++ b/procgenAISC/scripts/upload_wheels.py
@@ -0,0 +1,32 @@
+"""
+Upload wheels from GCS to pypi using twine
+
+python -m pip install --upgrade twine
+"""
+
+import argparse
+import subprocess
+import tempfile
+import blobfile as bf
+
+
+def main():
+    parser = argparse.ArgumentParser()
+    parser.add_argument("--version", required=True)
+    parser.add_argument("--for-real", action="store_true")
+    args = parser.parse_args()
+
+    with tempfile.TemporaryDirectory() as tmpdir:
+        for filepath in bf.glob(f"gs://openai-procgen/builds/procgen-{args.version}-*.whl"):
+            print(filepath)
+            bf.copy(filepath, bf.join(tmpdir, bf.basename(filepath)))
+        if args.for_real:
+            options = []
+        else:
+            options = ["--repository-url", "https://test.pypi.org/legacy/"]
+        subprocess.run(["python", "-m", "twine", "upload", *options, *bf.glob(bf.join(tmpdir, "*.whl"))], check=True)
+
+    
+
+if __name__ == "__main__":
+    main()
diff --git a/procgenAISC/setup.py b/procgenAISC/setup.py
new file mode 100644
index 0000000..7b17038
--- /dev/null
+++ b/procgenAISC/setup.py
@@ -0,0 +1,102 @@
+from setuptools import setup, Extension, find_packages
+from setuptools.command.build_ext import build_ext
+import subprocess
+import os
+import sys
+import glob
+
+SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
+PACKAGE_ROOT = os.path.join(SCRIPT_DIR, "procgen")
+README = open(os.path.join(SCRIPT_DIR, "README.md"), "rb").read().decode("utf8")
+
+# dynamically determine version number based on git commit
+version = open(os.path.join(PACKAGE_ROOT, "version.txt"), "r").read().strip()
+sha = "unknown"
+
+try:
+    sha = (
+        subprocess.check_output(["git", "rev-parse", "HEAD"], cwd=SCRIPT_DIR)
+        .decode("ascii")
+        .strip()
+    )
+except Exception:
+    pass
+
+if os.environ.get("TRAVIS_TAG", "") != "":
+    tag = os.environ["TRAVIS_TAG"]
+    assert tag == version, "mismatch in tag vs version, expected: %s actual: %s" % (
+        tag,
+        version,
+    )
+elif sha != "unknown":
+    version += "+" + sha[:7]
+
+
+# build shared library
+class DummyExtension(Extension):
+    """
+    This causes build_ext to be run
+    """
+
+    def __init__(self):
+        Extension.__init__(self, "dummy", sources=[])
+
+
+class custom_build_ext(build_ext):
+    """
+    Run our custom build step
+    """
+
+    def run(self):
+        if self.inplace:
+            print("skipping inplace build, extension will be built on demand")
+            return
+        sys.path.append(PACKAGE_ROOT)
+        import build
+
+        lib_dir = build.build(package=True)
+        # move into the build_lib directory so that the shared library
+        # can be included in the package
+        # we will also check for this file at runtime to avoid doing
+        # the on-demand build
+        for filename in ["libenv.so", "libenv.dylib", "env.dll"]:
+            src = os.path.join(lib_dir, filename)
+            dst = os.path.join(self.build_lib, "procgen", "data", "prebuilt", filename)
+            if os.path.exists(src):
+                os.makedirs(os.path.dirname(dst), exist_ok=True)
+                os.replace(src, dst)
+
+
+# package_data ** globs appear to be broken, supply the asset paths manually instead
+asset_paths = glob.glob(os.path.join(PACKAGE_ROOT, "data", "**"), recursive=True)
+asset_relpaths = [os.path.relpath(path, PACKAGE_ROOT) for path in asset_paths]
+
+setup(
+    name="procgen",
+    packages=find_packages(),
+    version=version,
+    setup_requires=[
+        "gym3>=0.3.3,<1.0.0",
+    ],
+    install_requires=[
+        "numpy>=1.17.0,<2.0.0",
+        "gym>=0.15.0,<1.0.0",
+        "filelock>=3.0.0,<4.0.0",
+    ],
+    python_requires=">=3.6.0",
+    package_data={
+        "procgen": [
+            "version.txt",
+            *asset_relpaths,
+        ]
+    },
+    extras_require={"test": ["pytest==5.2.1", "pytest-benchmark==3.2.2"]},
+    ext_modules=[DummyExtension()],
+    cmdclass={"build_ext": custom_build_ext},
+
+    author="OpenAI",
+    description="Procedurally Generated Game-Like RL Environments",
+    long_description=README,
+    long_description_content_type="text/markdown",
+    url="https://github.com/openai/procgen",
+)
Submodule ravens contains untracked content
